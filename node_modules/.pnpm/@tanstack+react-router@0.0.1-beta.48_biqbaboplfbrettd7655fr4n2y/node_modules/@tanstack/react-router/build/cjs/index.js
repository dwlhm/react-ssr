/**
 * react-router
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var React = require('react');
var shim = require('use-sync-external-store/shim');
var reactivity = require('@solidjs/reactivity');
var routerCore = require('@tanstack/router-core');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function lazy(importer) {
  const lazyComp = /*#__PURE__*/React__namespace.lazy(importer);
  const finalComp = lazyComp;
  finalComp.preload = async () => {
    {
      await importer();
    }
  };
  return finalComp;
}
//

function useLinkProps(options) {
  const router = useRouter();
  const {
    // custom props
    type,
    children,
    target,
    activeProps = () => ({
      className: 'active'
    }),
    inactiveProps = () => ({}),
    activeOptions,
    disabled,
    // fromCurrent,
    hash,
    search,
    params,
    to,
    preload,
    preloadDelay,
    preloadMaxAge,
    replace,
    // element props
    style,
    className,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchStart,
    onTouchEnd,
    ...rest
  } = options;
  const linkInfo = router.buildLink(options);
  if (linkInfo.type === 'external') {
    const {
      href
    } = linkInfo;
    return {
      href
    };
  }
  const {
    handleClick,
    handleFocus,
    handleEnter,
    handleLeave,
    isActive,
    next
  } = linkInfo;
  const reactHandleClick = e => {
    if (React__namespace.startTransition) {
      // This is a hack for react < 18
      React__namespace.startTransition(() => {
        handleClick(e);
      });
    } else {
      handleClick(e);
    }
  };
  const composeHandlers = handlers => e => {
    if (e.persist) e.persist();
    handlers.filter(Boolean).forEach(handler => {
      if (e.defaultPrevented) return;
      handler(e);
    });
  };

  // Get the active props
  const resolvedActiveProps = isActive ? routerCore.functionalUpdate(activeProps, {}) ?? {} : {};

  // Get the inactive props
  const resolvedInactiveProps = isActive ? {} : routerCore.functionalUpdate(inactiveProps, {}) ?? {};
  return {
    ...resolvedActiveProps,
    ...resolvedInactiveProps,
    ...rest,
    href: disabled ? undefined : next.href,
    onClick: composeHandlers([onClick, reactHandleClick]),
    onFocus: composeHandlers([onFocus, handleFocus]),
    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
    target,
    style: {
      ...style,
      ...resolvedActiveProps.style,
      ...resolvedInactiveProps.style
    },
    className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(' ') || undefined,
    ...(disabled ? {
      role: 'link',
      'aria-disabled': true
    } : undefined),
    ['data-status']: isActive ? 'active' : undefined
  };
}
const Link = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
  const linkProps = useLinkProps(props);
  return /*#__PURE__*/React__namespace.createElement("a", _rollupPluginBabelHelpers["extends"]({
    ref: ref
  }, linkProps, {
    children: typeof props.children === 'function' ? props.children({
      isActive: linkProps['data-status'] === 'active'
    }) : props.children
  }));
});
const matchesContext = /*#__PURE__*/React__namespace.createContext(null);
const routerContext = /*#__PURE__*/React__namespace.createContext(null);
const EMPTY = {};
const __useStoreValue = (seed, selector) => {
  const valueRef = React__namespace.useRef(EMPTY);

  // If there is no selector, track the seed
  // If there is a selector, do not track the seed
  const getValue = () => !selector ? seed() : selector(reactivity.untrack(() => seed()));

  // If empty, initialize the value
  if (valueRef.current === EMPTY) {
    valueRef.current = routerCore.sharedClone(undefined, getValue());
  }

  // Snapshot should just return the current cached value
  const getSnapshot = React__namespace.useCallback(() => valueRef.current, []);
  const getStore = React__namespace.useCallback(cb => {
    // A root is necessary to track effects
    return reactivity.createRoot(() => {
      reactivity.createEffect(() => {
        // Read and update the value
        // getValue will handle which values are accessed and
        // thus tracked.
        // sharedClone will both recursively track the end result
        // and ensure that the previous value is structurally shared
        // into the new version.
        valueRef.current = reactivity.unwrap(
        // Unwrap the value to get rid of any proxy structures
        routerCore.sharedClone(valueRef.current, getValue()));
        cb();
      });
    });
  }, []);
  return shim.useSyncExternalStore(getStore, getSnapshot, getSnapshot);
};
const [store, setStore] = reactivity.createStore({
  foo: 'foo',
  bar: {
    baz: 'baz'
  }
});
reactivity.createRoot(() => {
  let prev;
  reactivity.createEffect(() => {
    console.log('effect');
    const next = routerCore.sharedClone(prev, store);
    console.log(next);
    prev = reactivity.untrack(() => next);
  });
});
setStore(s => {
  s.foo = '1';
});
setStore(s => {
  s.bar.baz = '2';
});
function createReactRouter(opts) {
  const coreRouter = routerCore.createRouter({
    ...opts,
    loadComponent: async component => {
      if (component.preload) {
        await component.preload();
      }
      return component;
    }
  });
  return coreRouter;
}
function RouterProvider(_ref) {
  let {
    router,
    ...rest
  } = _ref;
  router.update(rest);
  const [,, currentMatches] = __useStoreValue(() => router.store, s => [s.status, s.pendingMatches, s.currentMatches]);
  React__namespace.useEffect(router.mount, [router]);
  console.log('current', currentMatches);
  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, /*#__PURE__*/React__namespace.createElement(routerContext.Provider, {
    value: {
      router: router
    }
  }, /*#__PURE__*/React__namespace.createElement(matchesContext.Provider, {
    value: [undefined, ...currentMatches]
  }, /*#__PURE__*/React__namespace.createElement(Outlet, null))));
}
function useRouter() {
  const value = React__namespace.useContext(routerContext);
  routerCore.warning(!value, 'useRouter must be used inside a <Router> component!');
  return value.router;
}
function useRouterStore(selector) {
  const router = useRouter();
  return __useStoreValue(() => router.store, selector);
}
function useMatches() {
  return React__namespace.useContext(matchesContext);
}
function useMatch(opts) {
  const router = useRouter();
  const nearestMatch = useMatches()[0];
  const match = opts != null && opts.from ? router.store.currentMatches.find(d => d.routeId === (opts == null ? void 0 : opts.from)) : nearestMatch;
  routerCore.invariant(match, `Could not find ${opts != null && opts.from ? `an active match from "${opts.from}"` : 'a nearest match!'}`);
  if ((opts == null ? void 0 : opts.strict) ?? true) {
    routerCore.invariant(nearestMatch.routeId == (match == null ? void 0 : match.routeId), `useMatch("${match == null ? void 0 : match.routeId}") is being called in a component that is meant to render the '${nearestMatch.routeId}' route. Did you mean to 'useMatch("${match == null ? void 0 : match.routeId}", { strict: false })' or 'useRoute("${match == null ? void 0 : match.routeId}")' instead?`);
  }
  __useStoreValue(() => match.store);
  return match;
}
function useRoute(routeId) {
  const router = useRouter();
  const resolvedRoute = router.getRoute(routeId);
  routerCore.invariant(resolvedRoute, `Could not find a route for route "${routeId}"! Did you forget to add it to your route config?`);
  return resolvedRoute;
}
function useLoaderData(opts) {
  const match = useMatch(opts);
  return __useStoreValue(() => match == null ? void 0 : match.store.loaderData, opts == null ? void 0 : opts.select);
}
function useSearch(opts) {
  const match = useMatch(opts);
  return __useStoreValue(() => match == null ? void 0 : match.store.search, opts == null ? void 0 : opts.select);
}
function useParams(opts) {
  const router = useRouter();
  return __useStoreValue(() => {
    var _last;
    return (_last = routerCore.last(router.store.currentMatches)) == null ? void 0 : _last.params;
  }, opts == null ? void 0 : opts.select);
}
function useNavigate(defaultOpts) {
  const router = useRouter();
  return opts => {
    return router.navigate({
      ...defaultOpts,
      ...opts
    });
  };
}
function useAction(opts) {
  const route = useRoute(opts.from);
  const action = route.action;
  __useStoreValue(() => action);
  return action;
}
function useMatchRoute() {
  const router = useRouter();
  return opts => {
    const {
      pending,
      caseSensitive,
      ...rest
    } = opts;
    return router.matchRoute(rest, {
      pending,
      caseSensitive
    });
  };
}
function MatchRoute(props) {
  const matchRoute = useMatchRoute();
  const params = matchRoute(props);
  if (!params) {
    return null;
  }
  return /*#__PURE__*/React__namespace.createElement(typeof props.children === 'function' ? props.children(params) : props.children, props);
}
function Outlet() {
  const router = useRouter();
  const matches = useMatches().slice(1);
  const match = matches[0];
  const defaultPending = React__namespace.useCallback(() => null, []);
  __useStoreValue(() => match == null ? void 0 : match.store);
  const Inner = React__namespace.useCallback(props => {
    if (props.match.store.status === 'error') {
      throw props.match.store.error;
    }
    if (props.match.store.status === 'success') {
      return /*#__PURE__*/React__namespace.createElement(props.match.__.component ?? router.options.defaultComponent ?? Outlet);
    }
    if (props.match.store.status === 'loading') {
      throw props.match.__.loadPromise;
    }
    routerCore.invariant(false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');
  }, []);
  if (!match) {
    return null;
  }
  const PendingComponent = match.__.pendingComponent ?? router.options.defaultPendingComponent ?? defaultPending;
  const errorComponent = match.__.errorComponent ?? router.options.defaultErrorComponent;
  return /*#__PURE__*/React__namespace.createElement(matchesContext.Provider, {
    value: matches
  }, /*#__PURE__*/React__namespace.createElement(React__namespace.Suspense, {
    fallback: /*#__PURE__*/React__namespace.createElement(PendingComponent, null)
  }, /*#__PURE__*/React__namespace.createElement(CatchBoundary, {
    key: match.routeId,
    errorComponent: errorComponent,
    match: match
  }, /*#__PURE__*/React__namespace.createElement(Inner, {
    match: match
  }))));
}
class CatchBoundary extends React__namespace.Component {
  state = {
    error: false,
    info: undefined
  };
  componentDidCatch(error, info) {
    console.error(`Error in route match: ${this.props.match.matchId}`);
    console.error(error);
    this.setState({
      error,
      info
    });
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement(CatchBoundaryInner, _rollupPluginBabelHelpers["extends"]({}, this.props, {
      errorState: this.state,
      reset: () => this.setState({})
    }));
  }
}

// This is the messiest thing ever... I'm either seriously tired (likely) or
// there has to be a better way to reset error boundaries when the
// router's location key changes.
function CatchBoundaryInner(props) {
  const [activeErrorState, setActiveErrorState] = React__namespace.useState(props.errorState);
  const router = useRouter();
  const errorComponent = props.errorComponent ?? DefaultErrorBoundary;
  React__namespace.useEffect(() => {
    if (activeErrorState) {
      let prevKey = router.store.currentLocation.key;
      return reactivity.createRoot(() => reactivity.createEffect(() => {
        if (router.store.currentLocation.key !== prevKey) {
          prevKey = router.store.currentLocation.key;
          setActiveErrorState({});
        }
      }));
    }
    return;
  }, [activeErrorState]);
  React__namespace.useEffect(() => {
    if (props.errorState.error) {
      setActiveErrorState(props.errorState);
    }
    props.reset();
  }, [props.errorState.error]);
  if (props.errorState.error) {
    return /*#__PURE__*/React__namespace.createElement(errorComponent, activeErrorState);
  }
  return props.children;
}
function DefaultErrorBoundary(_ref2) {
  let {
    error
  } = _ref2;
  return /*#__PURE__*/React__namespace.createElement("div", {
    style: {
      padding: '.5rem',
      maxWidth: '100%'
    }
  }, /*#__PURE__*/React__namespace.createElement("strong", {
    style: {
      fontSize: '1.2rem'
    }
  }, "Something went wrong!"), /*#__PURE__*/React__namespace.createElement("div", {
    style: {
      height: '.5rem'
    }
  }), /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("pre", null, error.message ? /*#__PURE__*/React__namespace.createElement("code", {
    style: {
      fontSize: '.7em',
      border: '1px solid red',
      borderRadius: '.25rem',
      padding: '.5rem',
      color: 'red'
    }
  }, error.message) : null)));
}
function usePrompt(message, when) {
  const router = useRouter();
  React__namespace.useEffect(() => {
    if (!when) return;
    let unblock = router.history.block(transition => {
      if (window.confirm(message)) {
        unblock();
        transition.retry();
      } else {
        router.store.currentLocation.pathname = window.location.pathname;
      }
    });
    return unblock;
  }, [when, message]);
}
function Prompt(_ref3) {
  let {
    message,
    when,
    children
  } = _ref3;
  usePrompt(message, when ?? true);
  return children ?? null;
}

// function circularStringify(obj: any) {
//   const seen = new Set()

//   return (
//     JSON.stringify(obj, (_, value) => {
//       if (typeof value === 'function') {
//         return undefined
//       }
//       if (typeof value === 'object' && value !== null) {
//         if (seen.has(value)) return
//         seen.add(value)
//       }
//       return value
//     }) || ''
//   )
// }

exports.DefaultErrorBoundary = DefaultErrorBoundary;
exports.Link = Link;
exports.MatchRoute = MatchRoute;
exports.Outlet = Outlet;
exports.Prompt = Prompt;
exports.RouterProvider = RouterProvider;
exports.__useStoreValue = __useStoreValue;
exports.createReactRouter = createReactRouter;
exports.lazy = lazy;
exports.matchesContext = matchesContext;
exports.routerContext = routerContext;
exports.useAction = useAction;
exports.useLinkProps = useLinkProps;
exports.useLoaderData = useLoaderData;
exports.useMatch = useMatch;
exports.useMatchRoute = useMatchRoute;
exports.useMatches = useMatches;
exports.useNavigate = useNavigate;
exports.useParams = useParams;
exports.usePrompt = usePrompt;
exports.useRoute = useRoute;
exports.useRouter = useRouter;
exports.useRouterStore = useRouterStore;
exports.useSearch = useSearch;
Object.keys(reactivity).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return reactivity[k]; }
  });
});
Object.keys(routerCore).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return routerCore[k]; }
  });
});
//# sourceMappingURL=index.js.map

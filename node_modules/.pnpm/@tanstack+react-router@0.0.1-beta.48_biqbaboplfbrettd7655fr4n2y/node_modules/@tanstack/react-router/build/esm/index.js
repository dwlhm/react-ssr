/**
 * react-router
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import * as React from 'react';
import { useSyncExternalStore } from 'use-sync-external-store/shim';
import { createStore, createRoot, createEffect, untrack, unwrap } from '@solidjs/reactivity';
export * from '@solidjs/reactivity';
import { sharedClone, functionalUpdate, createRouter, warning, invariant, last } from '@tanstack/router-core';
export * from '@tanstack/router-core';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function lazy(importer) {
  const lazyComp = /*#__PURE__*/React.lazy(importer);
  const finalComp = lazyComp;
  finalComp.preload = async () => {
    {
      await importer();
    }
  };
  return finalComp;
}
//

function useLinkProps(options) {
  const router = useRouter();
  const {
    // custom props
    type,
    children,
    target,
    activeProps = () => ({
      className: 'active'
    }),
    inactiveProps = () => ({}),
    activeOptions,
    disabled,
    // fromCurrent,
    hash,
    search,
    params,
    to,
    preload,
    preloadDelay,
    preloadMaxAge,
    replace,
    // element props
    style,
    className,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchStart,
    onTouchEnd,
    ...rest
  } = options;
  const linkInfo = router.buildLink(options);
  if (linkInfo.type === 'external') {
    const {
      href
    } = linkInfo;
    return {
      href
    };
  }
  const {
    handleClick,
    handleFocus,
    handleEnter,
    handleLeave,
    isActive,
    next
  } = linkInfo;
  const reactHandleClick = e => {
    if (React.startTransition) {
      // This is a hack for react < 18
      React.startTransition(() => {
        handleClick(e);
      });
    } else {
      handleClick(e);
    }
  };
  const composeHandlers = handlers => e => {
    if (e.persist) e.persist();
    handlers.filter(Boolean).forEach(handler => {
      if (e.defaultPrevented) return;
      handler(e);
    });
  };

  // Get the active props
  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};

  // Get the inactive props
  const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {};
  return {
    ...resolvedActiveProps,
    ...resolvedInactiveProps,
    ...rest,
    href: disabled ? undefined : next.href,
    onClick: composeHandlers([onClick, reactHandleClick]),
    onFocus: composeHandlers([onFocus, handleFocus]),
    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
    target,
    style: {
      ...style,
      ...resolvedActiveProps.style,
      ...resolvedInactiveProps.style
    },
    className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(' ') || undefined,
    ...(disabled ? {
      role: 'link',
      'aria-disabled': true
    } : undefined),
    ['data-status']: isActive ? 'active' : undefined
  };
}
const Link = /*#__PURE__*/React.forwardRef((props, ref) => {
  const linkProps = useLinkProps(props);
  return /*#__PURE__*/React.createElement("a", _extends({
    ref: ref
  }, linkProps, {
    children: typeof props.children === 'function' ? props.children({
      isActive: linkProps['data-status'] === 'active'
    }) : props.children
  }));
});
const matchesContext = /*#__PURE__*/React.createContext(null);
const routerContext = /*#__PURE__*/React.createContext(null);
const EMPTY = {};
const __useStoreValue = (seed, selector) => {
  const valueRef = React.useRef(EMPTY);

  // If there is no selector, track the seed
  // If there is a selector, do not track the seed
  const getValue = () => !selector ? seed() : selector(untrack(() => seed()));

  // If empty, initialize the value
  if (valueRef.current === EMPTY) {
    valueRef.current = sharedClone(undefined, getValue());
  }

  // Snapshot should just return the current cached value
  const getSnapshot = React.useCallback(() => valueRef.current, []);
  const getStore = React.useCallback(cb => {
    // A root is necessary to track effects
    return createRoot(() => {
      createEffect(() => {
        // Read and update the value
        // getValue will handle which values are accessed and
        // thus tracked.
        // sharedClone will both recursively track the end result
        // and ensure that the previous value is structurally shared
        // into the new version.
        valueRef.current = unwrap(
        // Unwrap the value to get rid of any proxy structures
        sharedClone(valueRef.current, getValue()));
        cb();
      });
    });
  }, []);
  return useSyncExternalStore(getStore, getSnapshot, getSnapshot);
};
const [store, setStore] = createStore({
  foo: 'foo',
  bar: {
    baz: 'baz'
  }
});
createRoot(() => {
  let prev;
  createEffect(() => {
    console.log('effect');
    const next = sharedClone(prev, store);
    console.log(next);
    prev = untrack(() => next);
  });
});
setStore(s => {
  s.foo = '1';
});
setStore(s => {
  s.bar.baz = '2';
});
function createReactRouter(opts) {
  const coreRouter = createRouter({
    ...opts,
    loadComponent: async component => {
      if (component.preload) {
        await component.preload();
      }
      return component;
    }
  });
  return coreRouter;
}
function RouterProvider(_ref) {
  let {
    router,
    ...rest
  } = _ref;
  router.update(rest);
  const [,, currentMatches] = __useStoreValue(() => router.store, s => [s.status, s.pendingMatches, s.currentMatches]);
  React.useEffect(router.mount, [router]);
  console.log('current', currentMatches);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(routerContext.Provider, {
    value: {
      router: router
    }
  }, /*#__PURE__*/React.createElement(matchesContext.Provider, {
    value: [undefined, ...currentMatches]
  }, /*#__PURE__*/React.createElement(Outlet, null))));
}
function useRouter() {
  const value = React.useContext(routerContext);
  warning(!value, 'useRouter must be used inside a <Router> component!');
  return value.router;
}
function useRouterStore(selector) {
  const router = useRouter();
  return __useStoreValue(() => router.store, selector);
}
function useMatches() {
  return React.useContext(matchesContext);
}
function useMatch(opts) {
  const router = useRouter();
  const nearestMatch = useMatches()[0];
  const match = opts != null && opts.from ? router.store.currentMatches.find(d => d.routeId === (opts == null ? void 0 : opts.from)) : nearestMatch;
  invariant(match, `Could not find ${opts != null && opts.from ? `an active match from "${opts.from}"` : 'a nearest match!'}`);
  if ((opts == null ? void 0 : opts.strict) ?? true) {
    invariant(nearestMatch.routeId == (match == null ? void 0 : match.routeId), `useMatch("${match == null ? void 0 : match.routeId}") is being called in a component that is meant to render the '${nearestMatch.routeId}' route. Did you mean to 'useMatch("${match == null ? void 0 : match.routeId}", { strict: false })' or 'useRoute("${match == null ? void 0 : match.routeId}")' instead?`);
  }
  __useStoreValue(() => match.store);
  return match;
}
function useRoute(routeId) {
  const router = useRouter();
  const resolvedRoute = router.getRoute(routeId);
  invariant(resolvedRoute, `Could not find a route for route "${routeId}"! Did you forget to add it to your route config?`);
  return resolvedRoute;
}
function useLoaderData(opts) {
  const match = useMatch(opts);
  return __useStoreValue(() => match == null ? void 0 : match.store.loaderData, opts == null ? void 0 : opts.select);
}
function useSearch(opts) {
  const match = useMatch(opts);
  return __useStoreValue(() => match == null ? void 0 : match.store.search, opts == null ? void 0 : opts.select);
}
function useParams(opts) {
  const router = useRouter();
  return __useStoreValue(() => {
    var _last;
    return (_last = last(router.store.currentMatches)) == null ? void 0 : _last.params;
  }, opts == null ? void 0 : opts.select);
}
function useNavigate(defaultOpts) {
  const router = useRouter();
  return opts => {
    return router.navigate({
      ...defaultOpts,
      ...opts
    });
  };
}
function useAction(opts) {
  const route = useRoute(opts.from);
  const action = route.action;
  __useStoreValue(() => action);
  return action;
}
function useMatchRoute() {
  const router = useRouter();
  return opts => {
    const {
      pending,
      caseSensitive,
      ...rest
    } = opts;
    return router.matchRoute(rest, {
      pending,
      caseSensitive
    });
  };
}
function MatchRoute(props) {
  const matchRoute = useMatchRoute();
  const params = matchRoute(props);
  if (!params) {
    return null;
  }
  return /*#__PURE__*/React.createElement(typeof props.children === 'function' ? props.children(params) : props.children, props);
}
function Outlet() {
  const router = useRouter();
  const matches = useMatches().slice(1);
  const match = matches[0];
  const defaultPending = React.useCallback(() => null, []);
  __useStoreValue(() => match == null ? void 0 : match.store);
  const Inner = React.useCallback(props => {
    if (props.match.store.status === 'error') {
      throw props.match.store.error;
    }
    if (props.match.store.status === 'success') {
      return /*#__PURE__*/React.createElement(props.match.__.component ?? router.options.defaultComponent ?? Outlet);
    }
    if (props.match.store.status === 'loading') {
      throw props.match.__.loadPromise;
    }
    invariant(false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');
  }, []);
  if (!match) {
    return null;
  }
  const PendingComponent = match.__.pendingComponent ?? router.options.defaultPendingComponent ?? defaultPending;
  const errorComponent = match.__.errorComponent ?? router.options.defaultErrorComponent;
  return /*#__PURE__*/React.createElement(matchesContext.Provider, {
    value: matches
  }, /*#__PURE__*/React.createElement(React.Suspense, {
    fallback: /*#__PURE__*/React.createElement(PendingComponent, null)
  }, /*#__PURE__*/React.createElement(CatchBoundary, {
    key: match.routeId,
    errorComponent: errorComponent,
    match: match
  }, /*#__PURE__*/React.createElement(Inner, {
    match: match
  }))));
}
class CatchBoundary extends React.Component {
  state = {
    error: false,
    info: undefined
  };
  componentDidCatch(error, info) {
    console.error(`Error in route match: ${this.props.match.matchId}`);
    console.error(error);
    this.setState({
      error,
      info
    });
  }
  render() {
    return /*#__PURE__*/React.createElement(CatchBoundaryInner, _extends({}, this.props, {
      errorState: this.state,
      reset: () => this.setState({})
    }));
  }
}

// This is the messiest thing ever... I'm either seriously tired (likely) or
// there has to be a better way to reset error boundaries when the
// router's location key changes.
function CatchBoundaryInner(props) {
  const [activeErrorState, setActiveErrorState] = React.useState(props.errorState);
  const router = useRouter();
  const errorComponent = props.errorComponent ?? DefaultErrorBoundary;
  React.useEffect(() => {
    if (activeErrorState) {
      let prevKey = router.store.currentLocation.key;
      return createRoot(() => createEffect(() => {
        if (router.store.currentLocation.key !== prevKey) {
          prevKey = router.store.currentLocation.key;
          setActiveErrorState({});
        }
      }));
    }
    return;
  }, [activeErrorState]);
  React.useEffect(() => {
    if (props.errorState.error) {
      setActiveErrorState(props.errorState);
    }
    props.reset();
  }, [props.errorState.error]);
  if (props.errorState.error) {
    return /*#__PURE__*/React.createElement(errorComponent, activeErrorState);
  }
  return props.children;
}
function DefaultErrorBoundary(_ref2) {
  let {
    error
  } = _ref2;
  return /*#__PURE__*/React.createElement("div", {
    style: {
      padding: '.5rem',
      maxWidth: '100%'
    }
  }, /*#__PURE__*/React.createElement("strong", {
    style: {
      fontSize: '1.2rem'
    }
  }, "Something went wrong!"), /*#__PURE__*/React.createElement("div", {
    style: {
      height: '.5rem'
    }
  }), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("pre", null, error.message ? /*#__PURE__*/React.createElement("code", {
    style: {
      fontSize: '.7em',
      border: '1px solid red',
      borderRadius: '.25rem',
      padding: '.5rem',
      color: 'red'
    }
  }, error.message) : null)));
}
function usePrompt(message, when) {
  const router = useRouter();
  React.useEffect(() => {
    if (!when) return;
    let unblock = router.history.block(transition => {
      if (window.confirm(message)) {
        unblock();
        transition.retry();
      } else {
        router.store.currentLocation.pathname = window.location.pathname;
      }
    });
    return unblock;
  }, [when, message]);
}
function Prompt(_ref3) {
  let {
    message,
    when,
    children
  } = _ref3;
  usePrompt(message, when ?? true);
  return children ?? null;
}

// function circularStringify(obj: any) {
//   const seen = new Set()

//   return (
//     JSON.stringify(obj, (_, value) => {
//       if (typeof value === 'function') {
//         return undefined
//       }
//       if (typeof value === 'object' && value !== null) {
//         if (seen.has(value)) return
//         seen.add(value)
//       }
//       return value
//     }) || ''
//   )
// }

export { DefaultErrorBoundary, Link, MatchRoute, Outlet, Prompt, RouterProvider, __useStoreValue, createReactRouter, lazy, matchesContext, routerContext, useAction, useLinkProps, useLoaderData, useMatch, useMatchRoute, useMatches, useNavigate, useParams, usePrompt, useRoute, useRouter, useRouterStore, useSearch };
//# sourceMappingURL=index.js.map

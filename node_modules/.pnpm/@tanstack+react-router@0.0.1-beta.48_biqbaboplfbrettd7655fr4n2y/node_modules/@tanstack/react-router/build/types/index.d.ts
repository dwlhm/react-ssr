/**
 * react-router
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import * as React from 'react';
import { RegisteredAllRouteInfo, LinkOptions, ToOptions, MatchRouteOptions, RouteInfoByPath, ResolveRelativePath, NoInfer, ValidFromPath, RegisteredRouter, AnyRouteConfig, RouteConfig, AnyAllRouteInfo, AllRouteInfo, RouterOptions, Router, DefaultAllRouteInfo, RouterStore, RouteMatch, Route, Expand, Action } from '@tanstack/router-core';
export * from '@tanstack/router-core';
export * from '@solidjs/reactivity';

type ReactNode = any;
type SyncRouteComponent<TProps = {}> = (props: TProps) => ReactNode;
type RouteComponent<TProps = {}> = SyncRouteComponent<TProps> & {
    preload?: () => Promise<void>;
};
declare function lazy(importer: () => Promise<{
    default: SyncRouteComponent;
}>): RouteComponent;
type LinkPropsOptions<TFrom extends RegisteredAllRouteInfo['routePaths'] = '/', TTo extends string = '.'> = LinkOptions<RegisteredAllRouteInfo, TFrom, TTo> & {
    activeProps?: React.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>);
    inactiveProps?: React.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>);
};
type MakeUseMatchRouteOptions<TFrom extends RegisteredAllRouteInfo['routePaths'] = '/', TTo extends string = '.'> = ToOptions<RegisteredAllRouteInfo, TFrom, TTo> & MatchRouteOptions;
type MakeMatchRouteOptions<TFrom extends RegisteredAllRouteInfo['routePaths'] = '/', TTo extends string = '.'> = ToOptions<RegisteredAllRouteInfo, TFrom, TTo> & MatchRouteOptions & {
    children?: ReactNode | ((params: RouteInfoByPath<RegisteredAllRouteInfo, ResolveRelativePath<TFrom, NoInfer<TTo>>>['allParams']) => ReactNode);
};
type MakeLinkPropsOptions<TFrom extends ValidFromPath<RegisteredAllRouteInfo> = '/', TTo extends string = '.'> = LinkPropsOptions<TFrom, TTo> & React.AnchorHTMLAttributes<HTMLAnchorElement>;
type MakeLinkOptions<TFrom extends RegisteredAllRouteInfo['routePaths'] = '/', TTo extends string = '.'> = LinkPropsOptions<TFrom, TTo> & React.AnchorHTMLAttributes<HTMLAnchorElement> & Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {
    children?: ReactNode | ((state: {
        isActive: boolean;
    }) => ReactNode);
};
declare module '@tanstack/router-core' {
    interface FrameworkGenerics {
        Component: RouteComponent;
        ErrorComponent: RouteComponent<{
            error: unknown;
            info: {
                componentStack: string;
            };
        }>;
    }
    interface RouterOptions<TRouteConfig, TRouterContext> {
    }
}
type PromptProps = {
    message: string;
    when?: boolean | any;
    children?: ReactNode;
};
declare function useLinkProps<TFrom extends ValidFromPath<RegisteredAllRouteInfo> = '/', TTo extends string = '.'>(options: MakeLinkPropsOptions<TFrom, TTo>): React.AnchorHTMLAttributes<HTMLAnchorElement>;
interface LinkFn<TDefaultFrom extends RegisteredAllRouteInfo['routePaths'] = '/', TDefaultTo extends string = '.'> {
    <TFrom extends RegisteredAllRouteInfo['routePaths'] = TDefaultFrom, TTo extends string = TDefaultTo>(props: MakeLinkOptions<TFrom, TTo> & React.RefAttributes<HTMLAnchorElement>): ReactNode;
}
declare const Link: LinkFn;
type MatchesContextValue = RouteMatch[];
declare const matchesContext: React.Context<MatchesContextValue>;
declare const routerContext: React.Context<{
    router: RegisteredRouter;
}>;
type MatchesProviderProps = {
    value: MatchesContextValue;
    children: ReactNode;
};
declare const __useStoreValue: <TSeed, TReturn>(seed: () => TSeed, selector?: ((seed: TSeed) => TReturn) | undefined) => TReturn;
declare function createReactRouter<TRouteConfig extends AnyRouteConfig = RouteConfig, TAllRouteInfo extends AnyAllRouteInfo = AllRouteInfo<TRouteConfig>, TRouterContext = unknown>(opts: RouterOptions<TRouteConfig, TRouterContext>): Router<TRouteConfig, TAllRouteInfo, TRouterContext>;
type RouterProps<TRouteConfig extends AnyRouteConfig = RouteConfig, TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TRouterContext = unknown> = RouterOptions<TRouteConfig, TRouterContext> & {
    router: Router<TRouteConfig, TAllRouteInfo, TRouterContext>;
};
declare function RouterProvider<TRouteConfig extends AnyRouteConfig = RouteConfig, TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TRouterContext = unknown>({ router, ...rest }: RouterProps<TRouteConfig, TAllRouteInfo, TRouterContext>): JSX.Element;
declare function useRouter(): RegisteredRouter;
declare function useRouterStore<T = RouterStore>(selector?: (state: Router['store']) => T): T;
declare function useMatches(): RouteMatch[];
declare function useMatch<TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'], TStrict extends boolean = true, TRouteMatch = RouteMatch<RegisteredAllRouteInfo, RegisteredAllRouteInfo['routeInfoById'][TFrom]>>(opts?: {
    from: TFrom;
    strict?: TStrict;
}): TStrict extends true ? TRouteMatch : TRouteMatch | undefined;
declare function useRoute<TId extends keyof RegisteredAllRouteInfo['routeInfoById'] = '/'>(routeId: TId): Route<RegisteredAllRouteInfo, RegisteredAllRouteInfo['routeInfoById'][TId]>;
declare function useLoaderData<TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'] = '/', TStrict extends boolean = true, TLoaderData = RegisteredAllRouteInfo['routeInfoById'][TFrom]['loaderData'], TSelected = TLoaderData>(opts?: {
    from: TFrom;
    strict?: TStrict;
    select?: (loaderData: TLoaderData) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
declare function useSearch<TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'], TStrict extends boolean = true, TSearch = RegisteredAllRouteInfo['routeInfoById'][TFrom]['fullSearchSchema'], TSelected = TSearch>(opts?: {
    from: TFrom;
    strict?: TStrict;
    select?: (search: TSearch) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
declare function useParams<TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'] = '/', TDefaultSelected = Expand<RegisteredAllRouteInfo['allParams'] & RegisteredAllRouteInfo['routeInfoById'][TFrom]['allParams']>, TSelected = TDefaultSelected>(opts?: {
    from: TFrom;
    select?: (search: TDefaultSelected) => TSelected;
}): TSelected;
declare function useNavigate<TDefaultFrom extends keyof RegisteredAllRouteInfo['routeInfoById'] = '/'>(defaultOpts: {
    from?: TDefaultFrom;
}): <TFrom extends string = TDefaultFrom, TTo extends string = ".">(opts: MakeLinkOptions<TFrom, TTo>) => Promise<void>;
declare function useAction<TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'] = '/', TFromRoute extends RegisteredAllRouteInfo['routeInfoById'][TFrom] = RegisteredAllRouteInfo['routeInfoById'][TFrom]>(opts: {
    from: TFrom;
}): Action<TFromRoute['actionPayload'], TFromRoute['actionResponse']>;
declare function useMatchRoute(): <TFrom extends ValidFromPath<AnyAllRouteInfo> = "/", TTo extends string = ".">(opts: MakeUseMatchRouteOptions<TFrom, TTo>) => false;
declare function MatchRoute<TFrom extends ValidFromPath<RegisteredAllRouteInfo> = '/', TTo extends string = '.'>(props: MakeMatchRouteOptions<TFrom, TTo>): any;
declare function Outlet(): JSX.Element | null;
declare function DefaultErrorBoundary({ error }: {
    error: any;
}): JSX.Element;
declare function usePrompt(message: string, when: boolean | any): void;
declare function Prompt({ message, when, children }: PromptProps): any;

export { DefaultErrorBoundary, Link, LinkFn, LinkPropsOptions, MakeLinkOptions, MakeLinkPropsOptions, MakeMatchRouteOptions, MakeUseMatchRouteOptions, MatchRoute, MatchesProviderProps, Outlet, Prompt, PromptProps, RouteComponent, RouterProps, RouterProvider, SyncRouteComponent, __useStoreValue, createReactRouter, lazy, matchesContext, routerContext, useAction, useLinkProps, useLoaderData, useMatch, useMatchRoute, useMatches, useNavigate, useParams, usePrompt, useRoute, useRouter, useRouterStore, useSearch };

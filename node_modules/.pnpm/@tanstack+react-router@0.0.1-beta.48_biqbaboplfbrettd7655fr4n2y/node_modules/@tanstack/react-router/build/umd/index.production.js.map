{"version":3,"file":"index.production.js","sources":["../../../../node_modules/.pnpm/@solidjs+reactivity@0.0.6/node_modules/@solidjs/reactivity/dist/index.js","../../../../node_modules/.pnpm/history@5.3.0/node_modules/history/index.js","../../../../node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/extends.js","../../../../node_modules/.pnpm/tiny-invariant@1.3.1/node_modules/tiny-invariant/dist/esm/tiny-invariant.js","../../../router-core/build/esm/index.js","../../src/index.tsx"],"sourcesContent":["// src/core.ts\nvar CurrentReaction = void 0;\nvar CurrentGets = null;\nvar CurrentGetsIndex = 0;\nvar EffectQueue = null;\nvar CacheClean = 0;\nvar CacheCheck = 1;\nvar CacheDirty = 2;\nvar Root;\nvar Reactive = class {\n  value;\n  fn;\n  observers = null;\n  sources = null;\n  state;\n  effect;\n  cleanups = null;\n  alwaysUpdate = false;\n  constructor(fnOrValue, type) {\n    if (type != 0 /* Signal */) {\n      this.fn = fnOrValue;\n      this.value = void 0;\n      this.state = CacheDirty;\n      if (Root)\n        Root.push(this);\n      else\n        console.error(\"Memos and effects must be wrapped in a createRoot\");\n      this.effect = type == 2 /* Effect */;\n      if (this.effect)\n        this.update();\n    } else {\n      this.fn = void 0;\n      this.value = fnOrValue;\n      this.state = CacheClean;\n      this.effect = false;\n    }\n  }\n  get() {\n    if (CurrentReaction) {\n      if (!CurrentGets && CurrentReaction.sources && CurrentReaction.sources[CurrentGetsIndex] == this) {\n        CurrentGetsIndex++;\n      } else {\n        if (!CurrentGets)\n          CurrentGets = [this];\n        else\n          CurrentGets.push(this);\n      }\n    }\n    if (this.fn)\n      this.updateIfNecessary();\n    return this.value;\n  }\n  set(value) {\n    const notInBatch = !EffectQueue;\n    const newValue = typeof value === \"function\" ? value(this.value) : value;\n    if ((this.value !== newValue || this.alwaysUpdate) && this.observers) {\n      for (let i = 0; i < this.observers.length; i++) {\n        this.observers[i].stale(CacheDirty);\n      }\n    }\n    this.value = newValue;\n    if (notInBatch)\n      stabilize();\n    return newValue;\n  }\n  stale(state) {\n    if (this.state < state) {\n      if (this.state === CacheClean && this.effect) {\n        if (EffectQueue)\n          EffectQueue.push(this);\n        else\n          EffectQueue = [this];\n      }\n      this.state = state;\n      if (this.observers) {\n        for (let i = 0; i < this.observers.length; i++) {\n          this.observers[i].stale(CacheCheck);\n        }\n      }\n    }\n  }\n  update() {\n    const oldValue = this.value;\n    const prevReaction = CurrentReaction;\n    const prevGets = CurrentGets;\n    const prevIndex = CurrentGetsIndex;\n    CurrentReaction = this;\n    CurrentGets = null;\n    CurrentGetsIndex = 0;\n    try {\n      if (this.cleanups) {\n        this.cleanups.forEach((c) => c());\n        this.cleanups = null;\n      }\n      this.value = this.fn();\n      if (CurrentGets) {\n        this.removeParentObservers(CurrentGetsIndex);\n        if (this.sources && CurrentGetsIndex > 0) {\n          this.sources.length = CurrentGetsIndex + CurrentGets.length;\n          for (let i = 0; i < CurrentGets.length; i++) {\n            this.sources[CurrentGetsIndex + i] = CurrentGets[i];\n          }\n        } else {\n          this.sources = CurrentGets;\n        }\n        for (let i = CurrentGetsIndex; i < this.sources.length; i++) {\n          const source = this.sources[i];\n          if (!source.observers) {\n            source.observers = [this];\n          } else {\n            source.observers.push(this);\n          }\n        }\n      } else if (this.sources && CurrentGetsIndex < this.sources.length) {\n        this.removeParentObservers(CurrentGetsIndex);\n        this.sources.length = CurrentGetsIndex;\n      }\n    } finally {\n      CurrentGets = prevGets;\n      CurrentReaction = prevReaction;\n      CurrentGetsIndex = prevIndex;\n    }\n    if ((oldValue !== this.value || this.alwaysUpdate) && this.observers) {\n      for (let i = 0; i < this.observers.length; i++) {\n        this.observers[i].state = CacheDirty;\n      }\n    }\n    this.state = CacheClean;\n  }\n  updateIfNecessary() {\n    if (this.state === CacheCheck) {\n      for (const source of this.sources) {\n        source.updateIfNecessary();\n        if (this.state === CacheDirty) {\n          break;\n        }\n      }\n    }\n    if (this.state === CacheDirty) {\n      this.update();\n    }\n    this.state = CacheClean;\n  }\n  removeParentObservers(index) {\n    if (!this.sources)\n      return;\n    for (let i = index; i < this.sources.length; i++) {\n      const source = this.sources[i];\n      const swap = source.observers.findIndex((v) => v === this);\n      source.observers[swap] = source.observers[source.observers.length - 1];\n      source.observers.pop();\n    }\n  }\n  destroy() {\n    if (this.cleanups) {\n      this.cleanups.forEach((c) => c());\n      this.cleanups = null;\n    }\n    this.removeParentObservers(0);\n  }\n};\nfunction onCleanup(fn) {\n  if (CurrentReaction) {\n    if (!CurrentReaction.cleanups)\n      CurrentReaction.cleanups = [fn];\n    else\n      CurrentReaction.cleanups.push(fn);\n  } else {\n    console.error(\"onCleanup must be called from within a memo or effect\");\n  }\n}\nfunction stabilize() {\n  if (!EffectQueue)\n    return;\n  for (let i = 0; i < EffectQueue.length; i++) {\n    EffectQueue[i].get();\n  }\n  EffectQueue = null;\n}\nfunction createSignal(value, options) {\n  const signal = new Reactive(value, 0 /* Signal */);\n  if (options?.equals !== void 0)\n    signal.alwaysUpdate = true;\n  return [signal.get.bind(signal), signal.set.bind(signal)];\n}\nfunction createMemo(fn) {\n  const memo = new Reactive(fn, 1 /* Memo */);\n  return memo.get.bind(memo);\n}\nfunction createEffect(fn) {\n  const effect = new Reactive(fn, 2 /* Effect */);\n  return effect.get.bind(effect);\n}\nfunction createRoot(fn) {\n  let root = [];\n  Root = root;\n  fn();\n  Root = null;\n  return () => {\n    if (!root)\n      return;\n    root.forEach((r) => r.destroy());\n    root = null;\n  };\n}\nfunction batch(fn) {\n  EffectQueue = [];\n  let out = fn();\n  stabilize();\n  return out;\n}\nfunction untrack(fn) {\n  const listener = CurrentReaction;\n  CurrentReaction = void 0;\n  try {\n    return fn();\n  } finally {\n    CurrentReaction = listener;\n  }\n}\n\n// src/store.ts\nvar $RAW = Symbol(\"store-raw\");\nvar $TRACK = Symbol(\"track\");\nvar $PROXY = Symbol(\"store-proxy\");\nvar $NODE = Symbol(\"store-node\");\nfunction wrap(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value);\n      const desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          const get = desc[prop].get.bind(p);\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = /* @__PURE__ */ new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW])\n    return result;\n  if (!isWrappable(item) || set.has(item))\n    return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item))\n      item = item.slice(0);\n    else\n      set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v)\n        item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item))\n      item = Object.assign({}, item);\n    else\n      set.add(item);\n    const keys = Object.keys(item);\n    const desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get)\n        continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v)\n        item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes)\n    Object.defineProperty(target, $NODE, { value: nodes = {} });\n  return nodes;\n}\nfunction getDataNode(nodes, property, value) {\n  return nodes[property] || (nodes[property] = createDataNode(value));\n}\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  if (CurrentReaction) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode())).get();\n  }\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nfunction createDataNode(value) {\n  const s = new Reactive(value, 0);\n  s.alwaysUpdate = true;\n  return s;\n}\nvar Writing = false;\nvar proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW)\n      return target;\n    if (property === $PROXY)\n      return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getDataNodes(target);\n    const tracked = nodes.hasOwnProperty(property);\n    let value = tracked ? nodes[property].get() : target[property];\n    if (property === $NODE || property === \"__proto__\")\n      return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (CurrentReaction && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get))\n        value = getDataNode(nodes, property, value).get();\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === \"__proto__\")\n      return true;\n    this.get(target, property, target);\n    return property in target;\n  },\n  set(target, property, value) {\n    Writing && setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    Writing && setProperty(target, property, void 0, true);\n    return true;\n  },\n  ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value)\n    return;\n  const prev = state[property];\n  const len = state.length;\n  if (deleting)\n    delete state[property];\n  else\n    state[property] = value;\n  const nodes = getDataNodes(state);\n  let node;\n  if (node = getDataNode(nodes, property, prev))\n    node.set(() => value);\n  if (Array.isArray(state) && state.length !== len)\n    (node = getDataNode(nodes, \"length\", len)) && node.set(state.length);\n  (node = nodes._) && node.set();\n}\nfunction createStore(store) {\n  const unwrappedStore = unwrap(store);\n  const wrappedStore = wrap(unwrappedStore);\n  const setStore = (fn) => {\n    batch(() => {\n      try {\n        Writing = true;\n        fn(wrappedStore);\n      } finally {\n        Writing = false;\n      }\n    });\n  };\n  return [wrappedStore, setStore];\n}\nexport {\n  batch,\n  createEffect,\n  createMemo,\n  createRoot,\n  createSignal,\n  createStore,\n  isWrappable,\n  onCleanup,\n  untrack,\n  unwrap\n};\n","import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","/**\n * router-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { createMemoryHistory, createBrowserHistory } from 'history';\nexport { createBrowserHistory, createHashHistory, createMemoryHistory } from 'history';\nimport invariant from 'tiny-invariant';\nexport { default as invariant } from 'tiny-invariant';\nimport { createStore, batch } from '@solidjs/reactivity';\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\nfunction warning(cond, message) {\n  if (cond) {\n    if (typeof console !== 'undefined') console.warn(message);\n    try {\n      throw new Error(message);\n    } catch {}\n  }\n  return true;\n}\nfunction isFunction(d) {\n  return typeof d === 'function';\n}\nfunction functionalUpdate(updater, previous) {\n  if (isFunction(updater)) {\n    return updater(previous);\n  }\n  return updater;\n}\nfunction pick(parent, keys) {\n  return keys.reduce((obj, key) => {\n    obj[key] = parent[key];\n    return obj;\n  }, {});\n}\n\nfunction joinPaths(paths) {\n  return cleanPath(paths.filter(Boolean).join('/'));\n}\nfunction cleanPath(path) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/');\n}\nfunction trimPathLeft(path) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '');\n}\nfunction trimPathRight(path) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '');\n}\nfunction trimPath(path) {\n  return trimPathRight(trimPathLeft(path));\n}\nfunction resolvePath(basepath, base, to) {\n  base = base.replace(new RegExp(`^${basepath}`), '/');\n  to = to.replace(new RegExp(`^${basepath}`), '/');\n  let baseSegments = parsePathname(base);\n  const toSegments = parsePathname(to);\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment];\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment);\n      } else ;\n    } else if (toSegment.value === '..') {\n      var _last;\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && ((_last = last(baseSegments)) == null ? void 0 : _last.value) === '/') {\n        baseSegments.pop();\n      }\n      baseSegments.pop();\n    } else if (toSegment.value === '.') {\n      return;\n    } else {\n      baseSegments.push(toSegment);\n    }\n  });\n  const joined = joinPaths([basepath, ...baseSegments.map(d => d.value)]);\n  return cleanPath(joined);\n}\nfunction parsePathname(pathname) {\n  if (!pathname) {\n    return [];\n  }\n  pathname = cleanPath(pathname);\n  const segments = [];\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  if (!pathname) {\n    return segments;\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean);\n  segments.push(...split.map(part => {\n    if (part.startsWith('*')) {\n      return {\n        type: 'wildcard',\n        value: part\n      };\n    }\n    if (part.charAt(0) === '$') {\n      return {\n        type: 'param',\n        value: part\n      };\n    }\n    return {\n      type: 'pathname',\n      value: part\n    };\n  }));\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  return segments;\n}\nfunction interpolatePath(path, params, leaveWildcard) {\n  const interpolatedPathSegments = parsePathname(path);\n  return joinPaths(interpolatedPathSegments.map(segment => {\n    if (segment.value === '*' && !leaveWildcard) {\n      return '';\n    }\n    if (segment.type === 'param') {\n      return params[segment.value.substring(1)] ?? '';\n    }\n    return segment.value;\n  }));\n}\nfunction matchPathname(basepath, currentPathname, matchLocation) {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation);\n  // const searchMatched = matchBySearch(currentLocation.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return;\n  }\n  return pathParams ?? {};\n}\nfunction matchByPath(basepath, from, matchLocation) {\n  if (!from.startsWith(basepath)) {\n    return undefined;\n  }\n  from = basepath != '/' ? from.substring(basepath.length) : from;\n  const baseSegments = parsePathname(from);\n  const to = `${matchLocation.to ?? '*'}`;\n  const routeSegments = parsePathname(to);\n  const params = {};\n  let isMatch = (() => {\n    for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {\n      const baseSegment = baseSegments[i];\n      const routeSegment = routeSegments[i];\n      const isLastRouteSegment = i === routeSegments.length - 1;\n      const isLastBaseSegment = i === baseSegments.length - 1;\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment != null && baseSegment.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map(d => d.value));\n            return true;\n          }\n          return false;\n        }\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !(baseSegment != null && baseSegment.value)) {\n            return true;\n          }\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false;\n              }\n            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {\n              return false;\n            }\n          }\n        }\n        if (!baseSegment) {\n          return false;\n        }\n        if (routeSegment.type === 'param') {\n          if ((baseSegment == null ? void 0 : baseSegment.value) === '/') {\n            return false;\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value;\n          }\n        }\n      }\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy;\n      }\n    }\n    return true;\n  })();\n  return isMatch ? params : undefined;\n}\n\n// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nfunction encode(obj, pfx) {\n  var k,\n    i,\n    tmp,\n    str = '';\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&');\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);\n        }\n      } else {\n        str && (str += '&');\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);\n      }\n    }\n  }\n  return (pfx || '') + str;\n}\nfunction toValue(mix) {\n  if (!mix) return '';\n  var str = decodeURIComponent(mix);\n  if (str === 'false') return false;\n  if (str === 'true') return true;\n  if (str.charAt(0) === '0') return str;\n  return +str * 0 === 0 ? +str : str;\n}\nfunction decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&');\n  while (tmp = arr.shift()) {\n    tmp = tmp.split('=');\n    k = tmp.shift();\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()));\n    } else {\n      out[k] = toValue(tmp.shift());\n    }\n  }\n  return out;\n}\n\nfunction createRoute(routeConfig, options, originalIndex, parent, router) {\n  const {\n    id,\n    routeId,\n    path: routePath,\n    fullPath\n  } = routeConfig;\n  let route = {\n    routeInfo: undefined,\n    routeId: id,\n    routeRouteId: routeId,\n    originalIndex,\n    routePath,\n    fullPath,\n    options,\n    router,\n    childRoutes: undefined,\n    parentRoute: parent,\n    get action() {\n      let action = router.store.actions[id] || (() => {\n        router.setStore(s => {\n          s.actions[id] = {\n            submissions: [],\n            submit: async (submission, actionOpts) => {\n              if (!route) {\n                return;\n              }\n              const invalidate = (actionOpts == null ? void 0 : actionOpts.invalidate) ?? true;\n              const [actionStore, setActionStore] = createStore({\n                submittedAt: Date.now(),\n                status: 'pending',\n                submission,\n                isMulti: !!(actionOpts != null && actionOpts.multi)\n              });\n              router.setStore(s => {\n                if (!(actionOpts != null && actionOpts.multi)) {\n                  s.actions[id].submissions = action.submissions.filter(d => d.isMulti);\n                }\n                s.actions[id].current = actionStore;\n                s.actions[id].latest = actionStore;\n                s.actions[id].submissions.push(actionStore);\n              });\n              try {\n                const res = await (route.options.action == null ? void 0 : route.options.action(submission));\n                setActionStore(s => {\n                  s.data = res;\n                });\n                if (invalidate) {\n                  router.invalidateRoute({\n                    to: '.',\n                    fromCurrent: true\n                  });\n                  await router.reload();\n                }\n                setActionStore(s => {\n                  s.status = 'success';\n                });\n                return res;\n              } catch (err) {\n                console.error(err);\n                setActionStore(s => {\n                  s.error = err;\n                  s.status = 'error';\n                });\n              }\n            }\n          };\n        });\n        return router.store.actions[id];\n      })();\n      return action;\n    },\n    get loader() {\n      let loader = router.store.loaders[id] || (() => {\n        router.setStore(s => {\n          s.loaders[id] = {\n            pending: [],\n            fetch: async loaderContext => {\n              if (!route) {\n                return;\n              }\n              const loaderState = {\n                loadedAt: Date.now(),\n                loaderContext\n              };\n              router.setStore(s => {\n                s.loaders[id].current = loaderState;\n                s.loaders[id].latest = loaderState;\n                s.loaders[id].pending.push(loaderState);\n              });\n              try {\n                return await (route.options.loader == null ? void 0 : route.options.loader(loaderContext));\n              } finally {\n                router.setStore(s => {\n                  s.loaders[id].pending = s.loaders[id].pending.filter(d => d !== loaderState);\n                });\n              }\n            }\n          };\n        });\n        return router.store.loaders[id];\n      })();\n      return loader;\n    }\n\n    // buildLink: (options) => {\n    //   return router.buildLink({\n    //     ...options,\n    //     from: fullPath,\n    //   } as any) as any\n    // },\n\n    // navigate: (options) => {\n    //   return router.navigate({\n    //     ...options,\n    //     from: fullPath,\n    //   } as any) as any\n    // },\n\n    // matchRoute: (matchLocation, opts) => {\n    //   return router.matchRoute(\n    //     {\n    //       ...matchLocation,\n    //       from: fullPath,\n    //     } as any,\n    //     opts,\n    //   ) as any\n    // },\n  };\n\n  router.options.createRoute == null ? void 0 : router.options.createRoute({\n    router,\n    route\n  });\n  return route;\n}\n\nconst rootRouteId = '__root__';\nconst createRouteConfig = function (options, children, isRoot, parentId, parentPath) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (isRoot === void 0) {\n    isRoot = true;\n  }\n  if (isRoot) {\n    options.path = rootRouteId;\n  }\n\n  // Strip the root from parentIds\n  if (parentId === rootRouteId) {\n    parentId = '';\n  }\n  let path = isRoot ? rootRouteId : options.path;\n\n  // If the path is anything other than an index path, trim it up\n  if (path && path !== '/') {\n    path = trimPath(path);\n  }\n  const routeId = path || options.id;\n  let id = joinPaths([parentId, routeId]);\n  if (path === rootRouteId) {\n    path = '/';\n  }\n  if (id !== rootRouteId) {\n    id = joinPaths(['/', id]);\n  }\n  const fullPath = id === rootRouteId ? '/' : trimPathRight(joinPaths([parentPath, path]));\n  return {\n    id: id,\n    routeId: routeId,\n    path: path,\n    fullPath: fullPath,\n    options: options,\n    children,\n    addChildren: children => createRouteConfig(options, children, false, parentId, parentPath),\n    createRoute: childOptions => createRouteConfig(childOptions, undefined, false, id, fullPath),\n    generate: () => {\n      invariant(false, `routeConfig.generate() is used by TanStack Router's file-based routing code generation and should not actually be called during runtime. `);\n    }\n  };\n};\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nfunction sharedClone(prev, next, touchAll) {\n  const things = new Map();\n  function recurse(prev, next) {\n    if (prev === next) {\n      return prev;\n    }\n    if (things.has(next)) {\n      return things.get(next);\n    }\n    const prevIsArray = Array.isArray(prev);\n    const nextIsArray = Array.isArray(next);\n    const prevIsObj = isPlainObject(prev);\n    const nextIsObj = isPlainObject(next);\n    const isArray = prevIsArray && nextIsArray;\n    const isObj = prevIsObj && nextIsObj;\n    const isSameStructure = isArray || isObj;\n\n    // Both are arrays or objects\n    if (isSameStructure) {\n      const aSize = isArray ? prev.length : Object.keys(prev).length;\n      const bItems = isArray ? next : Object.keys(next);\n      const bSize = bItems.length;\n      const copy = isArray ? [] : {};\n      let equalItems = 0;\n      for (let i = 0; i < bSize; i++) {\n        const key = isArray ? i : bItems[i];\n        if (copy[key] === prev[key]) {\n          equalItems++;\n        }\n      }\n      if (aSize === bSize && equalItems === aSize) {\n        things.set(next, prev);\n        return prev;\n      }\n      things.set(next, copy);\n      for (let i = 0; i < bSize; i++) {\n        const key = isArray ? i : bItems[i];\n        if (typeof bItems[i] === 'function') {\n          copy[key] = prev[key];\n        } else {\n          copy[key] = recurse(prev[key], next[key]);\n        }\n        if (copy[key] === prev[key]) {\n          equalItems++;\n        }\n      }\n      return copy;\n    }\n    if (nextIsArray) {\n      const copy = [];\n      things.set(next, copy);\n      for (let i = 0; i < next.length; i++) {\n        copy[i] = recurse(undefined, next[i]);\n      }\n      return copy;\n    }\n    if (nextIsObj) {\n      const copy = {};\n      things.set(next, copy);\n      const nextKeys = Object.keys(next);\n      for (let i = 0; i < nextKeys.length; i++) {\n        const key = nextKeys[i];\n        copy[key] = recurse(undefined, next[key]);\n      }\n      return copy;\n    }\n    return next;\n  }\n  return recurse(prev, next);\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor;\n  if (typeof ctor === 'undefined') {\n    return true;\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nconst componentTypes = ['component', 'errorComponent', 'pendingComponent'];\nfunction createRouteMatch(router, route, opts) {\n  let componentsPromise;\n  let dataPromise;\n  let latestId = '';\n  let resolve = () => {};\n  function setLoaderData(loaderData) {\n    batch(() => {\n      setStore(s => {\n        s.routeLoaderData = sharedClone(s.routeLoaderData, loaderData);\n      });\n      updateLoaderData();\n    });\n  }\n  function updateLoaderData() {\n    setStore(s => {\n      var _store$parentMatch;\n      s.loaderData = sharedClone(s.loaderData, {\n        ...((_store$parentMatch = store.parentMatch) == null ? void 0 : _store$parentMatch.store.loaderData),\n        ...s.routeLoaderData\n      });\n    });\n  }\n  const [store, setStore] = createStore({\n    routeSearch: {},\n    search: {},\n    status: 'idle',\n    routeLoaderData: {},\n    loaderData: {},\n    isFetching: false,\n    invalid: false,\n    invalidAt: Infinity,\n    get isInvalid() {\n      const now = Date.now();\n      return this.invalid || this.invalidAt < now;\n    }\n  });\n  const routeMatch = {\n    ...route,\n    ...opts,\n    store,\n    // setStore,\n    router,\n    childMatches: [],\n    __: {\n      setParentMatch: parentMatch => {\n        batch(() => {\n          setStore(s => {\n            s.parentMatch = parentMatch;\n          });\n          updateLoaderData();\n        });\n      },\n      abortController: new AbortController(),\n      validate: () => {\n        var _store$parentMatch2;\n        // Validate the search params and stabilize them\n        const parentSearch = ((_store$parentMatch2 = store.parentMatch) == null ? void 0 : _store$parentMatch2.store.search) ?? router.store.currentLocation.search;\n        try {\n          const prevSearch = store.routeSearch;\n          const validator = typeof routeMatch.options.validateSearch === 'object' ? routeMatch.options.validateSearch.parse : routeMatch.options.validateSearch;\n          let nextSearch = sharedClone(prevSearch, (validator == null ? void 0 : validator(parentSearch)) ?? {});\n          batch(() => {\n            // Invalidate route matches when search param stability changes\n            if (prevSearch !== nextSearch) {\n              setStore(s => s.invalid = true);\n            }\n\n            // TODO: Alright, do we need batch() here?\n            setStore(s => {\n              s.routeSearch = nextSearch;\n              s.search = sharedClone(parentSearch, {\n                ...parentSearch,\n                ...nextSearch\n              });\n            });\n          });\n          componentTypes.map(async type => {\n            const component = routeMatch.options[type];\n            if (typeof routeMatch.__[type] !== 'function') {\n              routeMatch.__[type] = component;\n            }\n          });\n        } catch (err) {\n          console.error(err);\n          const error = new Error('Invalid search params found', {\n            cause: err\n          });\n          error.code = 'INVALID_SEARCH_PARAMS';\n          setStore(s => {\n            s.status = 'error';\n            s.error = error;\n          });\n\n          // Do not proceed with loading the route\n          return;\n        }\n      }\n    },\n    cancel: () => {\n      var _routeMatch$__$abortC;\n      (_routeMatch$__$abortC = routeMatch.__.abortController) == null ? void 0 : _routeMatch$__$abortC.abort();\n    },\n    invalidate: () => {\n      setStore(s => s.invalid = true);\n    },\n    hasLoaders: () => {\n      return !!(route.options.loader || componentTypes.some(d => {\n        var _route$options$d;\n        return (_route$options$d = route.options[d]) == null ? void 0 : _route$options$d.preload;\n      }));\n    },\n    load: async loaderOpts => {\n      const now = Date.now();\n      const minMaxAge = loaderOpts != null && loaderOpts.preload ? Math.max(loaderOpts == null ? void 0 : loaderOpts.maxAge, loaderOpts == null ? void 0 : loaderOpts.gcMaxAge) : 0;\n\n      // If this is a preload, add it to the preload cache\n      if (loaderOpts != null && loaderOpts.preload && minMaxAge > 0) {\n        // If the match is currently active, don't preload it\n        if (router.store.currentMatches.find(d => d.matchId === routeMatch.matchId)) {\n          return;\n        }\n        router.store.matchCache[routeMatch.matchId] = {\n          gc: now + loaderOpts.gcMaxAge,\n          match: routeMatch\n        };\n      }\n\n      // If the match is invalid, errored or idle, trigger it to load\n      if (store.status === 'success' && store.isInvalid || store.status === 'error' || store.status === 'idle') {\n        const maxAge = loaderOpts != null && loaderOpts.preload ? loaderOpts == null ? void 0 : loaderOpts.maxAge : undefined;\n        await routeMatch.fetch({\n          maxAge\n        });\n      }\n    },\n    fetch: async opts => {\n      const loadId = '' + Date.now() + Math.random();\n      latestId = loadId;\n      const checkLatest = async () => {\n        if (loadId !== latestId) {\n          // warning(true, 'Data loader is out of date!')\n          return new Promise(() => {});\n        }\n      };\n      batch(() => {\n        // If the match was in an error state, set it\n        // to a loading state again. Otherwise, keep it\n        // as loading or resolved\n        if (store.status === 'idle') {\n          setStore(s => s.status = 'loading');\n        }\n\n        // We started loading the route, so it's no longer invalid\n        setStore(s => s.invalid = false);\n      });\n      routeMatch.__.loadPromise = new Promise(async r => {\n        // We are now fetching, even if it's in the background of a\n        // resolved state\n        setStore(s => s.isFetching = true);\n        resolve = r;\n        componentsPromise = (async () => {\n          // then run all component and data loaders in parallel\n          // For each component type, potentially load it asynchronously\n\n          await Promise.all(componentTypes.map(async type => {\n            var _routeMatch$__$type;\n            const component = routeMatch.options[type];\n            if ((_routeMatch$__$type = routeMatch.__[type]) != null && _routeMatch$__$type.preload) {\n              routeMatch.__[type] = await router.options.loadComponent(component);\n            }\n          }));\n        })();\n        dataPromise = Promise.resolve().then(async () => {\n          try {\n            if (routeMatch.options.loader) {\n              const data = await router.loadMatchData(routeMatch);\n              await checkLatest();\n              setLoaderData(data);\n            }\n            setStore(s => {\n              s.error = undefined;\n              s.status = 'success';\n              s.updatedAt = Date.now();\n              s.invalidAt = s.updatedAt + ((opts == null ? void 0 : opts.maxAge) ?? routeMatch.options.loaderMaxAge ?? router.options.defaultLoaderMaxAge ?? 0);\n            });\n            return store.routeLoaderData;\n          } catch (err) {\n            await checkLatest();\n            if (process.env.NODE_ENV !== 'production') {\n              console.error(err);\n            }\n            setStore(s => {\n              s.error = err;\n              s.status = 'error';\n              s.updatedAt = Date.now();\n            });\n            throw err;\n          }\n        });\n        const after = async () => {\n          await checkLatest();\n          setStore(s => s.isFetching = false);\n          delete routeMatch.__.loadPromise;\n          resolve();\n        };\n        try {\n          await Promise.all([componentsPromise, dataPromise.catch(() => {})]);\n          after();\n        } catch {\n          after();\n        }\n      });\n      await routeMatch.__.loadPromise;\n      await checkLatest();\n    }\n  };\n  if (!routeMatch.hasLoaders()) {\n    setStore(s => s.status = 'success');\n  }\n  return routeMatch;\n}\n\nconst defaultParseSearch = parseSearchWith(JSON.parse);\nconst defaultStringifySearch = stringifySearchWith(JSON.stringify);\nfunction parseSearchWith(parser) {\n  return searchStr => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1);\n    }\n    let query = decode(searchStr);\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key];\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value);\n        } catch (err) {\n          //\n        }\n      }\n    }\n    return query;\n  };\n}\nfunction stringifySearchWith(stringify) {\n  return search => {\n    search = {\n      ...search\n    };\n    if (search) {\n      Object.keys(search).forEach(key => {\n        const val = search[key];\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key];\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val);\n          } catch (err) {\n            // silent\n          }\n        }\n      });\n    }\n    const searchStr = encode(search).toString();\n    return searchStr ? `?${searchStr}` : '';\n  };\n}\n\nvar _window$document;\n// Detect if we're in the DOM\nconst isServer = typeof window === 'undefined' || !((_window$document = window.document) != null && _window$document.createElement);\n\n// This is the default history object if none is defined\nconst createDefaultHistory = () => isServer ? createMemoryHistory() : createBrowserHistory();\nfunction getInitialRouterState() {\n  return {\n    status: 'idle',\n    latestLocation: null,\n    currentLocation: null,\n    currentMatches: [],\n    actions: {},\n    loaders: {},\n    lastUpdated: Date.now(),\n    matchCache: {},\n    get isFetching() {\n      return this.status === 'loading' || this.currentMatches.some(d => d.store.isFetching);\n    },\n    get isPreloading() {\n      return Object.values(this.matchCache).some(d => d.match.store.isFetching && !this.currentMatches.find(dd => dd.matchId === d.match.matchId));\n    }\n  };\n}\nfunction createRouter(userOptions) {\n  const originalOptions = {\n    defaultLoaderGcMaxAge: 5 * 60 * 1000,\n    defaultLoaderMaxAge: 0,\n    defaultPreloadMaxAge: 2000,\n    defaultPreloadDelay: 50,\n    context: undefined,\n    ...userOptions,\n    stringifySearch: (userOptions == null ? void 0 : userOptions.stringifySearch) ?? defaultStringifySearch,\n    parseSearch: (userOptions == null ? void 0 : userOptions.parseSearch) ?? defaultParseSearch\n  };\n  const [store, setStore] = createStore(getInitialRouterState());\n  let navigationPromise;\n  let startedLoadingAt = Date.now();\n  let resolveNavigation = () => {};\n  function onFocus() {\n    router.load();\n  }\n  function buildRouteTree(rootRouteConfig) {\n    const recurseRoutes = (routeConfigs, parent) => {\n      return routeConfigs.map((routeConfig, i) => {\n        const routeOptions = routeConfig.options;\n        const route = createRoute(routeConfig, routeOptions, i, parent, router);\n        const existingRoute = router.routesById[route.routeId];\n        if (existingRoute) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`Duplicate routes found with id: ${String(route.routeId)}`, router.routesById, route);\n          }\n          throw new Error();\n        }\n        router.routesById[route.routeId] = route;\n        const children = routeConfig.children;\n        route.childRoutes = children != null && children.length ? recurseRoutes(children, route) : undefined;\n        return route;\n      });\n    };\n    const routes = recurseRoutes([rootRouteConfig]);\n    return routes[0];\n  }\n  function parseLocation(location, previousLocation) {\n    const parsedSearch = router.options.parseSearch(location.search);\n    return {\n      pathname: location.pathname,\n      searchStr: location.search,\n      search: sharedClone(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),\n      hash: location.hash.split('#').reverse()[0] ?? '',\n      href: `${location.pathname}${location.search}${location.hash}`,\n      state: location.state,\n      key: location.key\n    };\n  }\n  function navigate(location) {\n    const next = router.buildNext(location);\n    return commitLocation(next, location.replace);\n  }\n  function buildLocation(dest) {\n    var _last, _dest$__preSearchFilt, _dest$__preSearchFilt2, _dest$__postSearchFil;\n    if (dest === void 0) {\n      dest = {};\n    }\n    const fromPathname = dest.fromCurrent ? store.latestLocation.pathname : dest.from ?? store.latestLocation.pathname;\n    let pathname = resolvePath(router.basepath ?? '/', fromPathname, `${dest.to ?? '.'}`);\n    const fromMatches = router.matchRoutes(store.latestLocation.pathname, {\n      strictParseParams: true\n    });\n    const toMatches = router.matchRoutes(pathname);\n    const prevParams = {\n      ...((_last = last(fromMatches)) == null ? void 0 : _last.params)\n    };\n    let nextParams = (dest.params ?? true) === true ? prevParams : functionalUpdate(dest.params, prevParams);\n    if (nextParams) {\n      toMatches.map(d => d.options.stringifyParams).filter(Boolean).forEach(fn => {\n        Object.assign({}, nextParams, fn(nextParams));\n      });\n    }\n    pathname = interpolatePath(pathname, nextParams ?? {});\n\n    // Pre filters first\n    const preFilteredSearch = (_dest$__preSearchFilt = dest.__preSearchFilters) != null && _dest$__preSearchFilt.length ? dest.__preSearchFilters.reduce((prev, next) => next(prev), store.latestLocation.search) : store.latestLocation.search;\n\n    // Then the link/navigate function\n    const destSearch = dest.search === true ? preFilteredSearch // Preserve resolvedFrom true\n    : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n    : (_dest$__preSearchFilt2 = dest.__preSearchFilters) != null && _dest$__preSearchFilt2.length ? preFilteredSearch // Preserve resolvedFrom filters\n    : {};\n\n    // Then post filters\n    const postFilteredSearch = (_dest$__postSearchFil = dest.__postSearchFilters) != null && _dest$__postSearchFil.length ? dest.__postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;\n    const search = sharedClone(store.latestLocation.search, postFilteredSearch);\n    const searchStr = router.options.stringifySearch(search);\n    let hash = dest.hash === true ? store.latestLocation.hash : functionalUpdate(dest.hash, store.latestLocation.hash);\n    hash = hash ? `#${hash}` : '';\n    return {\n      pathname,\n      search,\n      searchStr,\n      state: store.latestLocation.state,\n      hash,\n      href: `${pathname}${searchStr}${hash}`,\n      key: dest.key\n    };\n  }\n  function commitLocation(next, replace) {\n    const id = '' + Date.now() + Math.random();\n    let nextAction = 'replace';\n    if (!replace) {\n      nextAction = 'push';\n    }\n    const isSameUrl = parseLocation(router.history.location).href === next.href;\n    if (isSameUrl && !next.key) {\n      nextAction = 'replace';\n    }\n    router.history[nextAction]({\n      pathname: next.pathname,\n      hash: next.hash,\n      search: next.searchStr\n    }, {\n      id,\n      ...next.state\n    });\n    return navigationPromise = new Promise(resolve => {\n      const previousNavigationResolve = resolveNavigation;\n      resolveNavigation = () => {\n        previousNavigationResolve();\n        resolve();\n      };\n    });\n  }\n  const router = {\n    types: undefined,\n    // public api\n    history: (userOptions == null ? void 0 : userOptions.history) || createDefaultHistory(),\n    store,\n    setStore,\n    options: originalOptions,\n    basepath: '',\n    routeTree: undefined,\n    routesById: {},\n    reset: () => {\n      setStore(s => Object.assign(s, getInitialRouterState()));\n    },\n    getRoute: id => {\n      return router.routesById[id];\n    },\n    dehydrate: () => {\n      return {\n        store: {\n          ...pick(store, ['latestLocation', 'currentLocation', 'status', 'lastUpdated']),\n          currentMatches: store.currentMatches.map(match => ({\n            matchId: match.matchId,\n            store: pick(match.store, ['status', 'routeLoaderData', 'isInvalid', 'invalidAt'])\n          }))\n        },\n        context: router.options.context\n      };\n    },\n    hydrate: dehydratedRouter => {\n      setStore(s => {\n        // Update the context TODO: make this part of state?\n        router.options.context = dehydratedRouter.context;\n\n        // Match the routes\n        const currentMatches = router.matchRoutes(dehydratedRouter.store.latestLocation.pathname, {\n          strictParseParams: true\n        });\n        currentMatches.forEach((match, index) => {\n          const dehydratedMatch = dehydratedRouter.store.currentMatches[index];\n          invariant(dehydratedMatch && dehydratedMatch.matchId === match.matchId, 'Oh no! There was a hydration mismatch when attempting to restore the state of the router! ');\n          Object.assign(match, dehydratedMatch);\n        });\n        currentMatches.forEach(match => match.__.validate());\n        Object.assign(s, {\n          ...dehydratedRouter.store,\n          currentMatches\n        });\n      });\n    },\n    mount: () => {\n      // Mount only does anything on the client\n      if (!isServer) {\n        // If the router matches are empty, load the matches\n        if (!store.currentMatches.length) {\n          router.load();\n        }\n        const unsub = router.history.listen(event => {\n          router.load(parseLocation(event.location, store.latestLocation));\n        });\n\n        // addEventListener does not exist in React Native, but window does\n        // In the future, we might need to invert control here for more adapters\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (window.addEventListener) {\n          // Listen to visibilitychange and focus\n          window.addEventListener('visibilitychange', onFocus, false);\n          window.addEventListener('focus', onFocus, false);\n        }\n        return () => {\n          unsub();\n          if (window.removeEventListener) {\n            // Be sure to unsubscribe if a new handler is set\n            window.removeEventListener('visibilitychange', onFocus);\n            window.removeEventListener('focus', onFocus);\n          }\n        };\n      }\n      return () => {};\n    },\n    update: opts => {\n      const newHistory = (opts == null ? void 0 : opts.history) !== router.history;\n      if (!store.latestLocation || newHistory) {\n        if (opts != null && opts.history) {\n          router.history = opts.history;\n        }\n        setStore(s => {\n          s.latestLocation = parseLocation(router.history.location);\n          s.currentLocation = s.latestLocation;\n        });\n      }\n      Object.assign(router.options, opts);\n      const {\n        basepath,\n        routeConfig\n      } = router.options;\n      router.basepath = `/${trimPath(basepath ?? '') ?? ''}`;\n      if (routeConfig) {\n        router.routesById = {};\n        router.routeTree = buildRouteTree(routeConfig);\n      }\n      return router;\n    },\n    cancelMatches: () => {\n      [...store.currentMatches, ...(store.pendingMatches || [])].forEach(match => {\n        match.cancel();\n      });\n    },\n    load: async next => {\n      let now = Date.now();\n      const startedAt = now;\n      startedLoadingAt = startedAt;\n\n      // Cancel any pending matches\n      router.cancelMatches();\n      let matches;\n      batch(() => {\n        if (next) {\n          // Ingest the new location\n          setStore(s => {\n            s.latestLocation = next;\n          });\n        }\n\n        // Match the routes\n        matches = router.matchRoutes(store.latestLocation.pathname, {\n          strictParseParams: true\n        });\n        console.log('set loading', matches);\n        setStore(s => {\n          s.status = 'loading';\n          s.pendingMatches = matches;\n          s.pendingLocation = store.latestLocation;\n        });\n      });\n\n      // Load the matches\n      try {\n        await router.loadMatches(matches);\n      } catch (err) {\n        console.log(err);\n        invariant(false, 'Matches failed to load due to error above . Navigation cancelled!');\n      }\n      if (startedLoadingAt !== startedAt) {\n        // Ignore side-effects of outdated side-effects\n        return navigationPromise;\n      }\n      const previousMatches = store.currentMatches;\n      const exiting = [],\n        staying = [];\n      previousMatches.forEach(d => {\n        if (matches.find(dd => dd.matchId === d.matchId)) {\n          staying.push(d);\n        } else {\n          exiting.push(d);\n        }\n      });\n      const entering = matches.filter(d => {\n        return !previousMatches.find(dd => dd.matchId === d.matchId);\n      });\n      now = Date.now();\n      exiting.forEach(d => {\n        d.__.onExit == null ? void 0 : d.__.onExit({\n          params: d.params,\n          search: d.store.routeSearch\n        });\n\n        // Clear idle error states when match leaves\n        if (d.store.status === 'error' && !d.store.isFetching) {\n          d.store.status = 'idle';\n          d.store.error = undefined;\n        }\n        const gc = Math.max(d.options.loaderGcMaxAge ?? router.options.defaultLoaderGcMaxAge ?? 0, d.options.loaderMaxAge ?? router.options.defaultLoaderMaxAge ?? 0);\n        if (gc > 0) {\n          store.matchCache[d.matchId] = {\n            gc: gc == Infinity ? Number.MAX_SAFE_INTEGER : now + gc,\n            match: d\n          };\n        }\n      });\n      staying.forEach(d => {\n        d.options.onTransition == null ? void 0 : d.options.onTransition({\n          params: d.params,\n          search: d.store.routeSearch\n        });\n      });\n      entering.forEach(d => {\n        d.__.onExit = d.options.onLoaded == null ? void 0 : d.options.onLoaded({\n          params: d.params,\n          search: d.store.search\n        });\n        delete store.matchCache[d.matchId];\n      });\n      if (startedLoadingAt !== startedAt) {\n        // Ignore side-effects of match loading\n        return;\n      }\n      matches.forEach(match => {\n        // Clear actions\n        if (match.action) {\n          // TODO: Check reactivity here\n          match.action.current = undefined;\n          match.action.submissions = [];\n        }\n      });\n      setStore(s => {\n        console.log('set', matches);\n        Object.assign(s, {\n          status: 'idle',\n          currentLocation: store.latestLocation,\n          currentMatches: matches,\n          pendingLocation: undefined,\n          pendingMatches: undefined\n        });\n      });\n      resolveNavigation();\n    },\n    cleanMatchCache: () => {\n      const now = Date.now();\n      setStore(s => {\n        Object.keys(s.matchCache).forEach(matchId => {\n          const entry = s.matchCache[matchId];\n\n          // Don't remove loading matches\n          if (entry.match.store.status === 'loading') {\n            return;\n          }\n\n          // Do not remove successful matches that are still valid\n          if (entry.gc > 0 && entry.gc > now) {\n            return;\n          }\n\n          // Everything else gets removed\n          delete s.matchCache[matchId];\n        });\n      });\n    },\n    loadRoute: async function (navigateOpts) {\n      if (navigateOpts === void 0) {\n        navigateOpts = store.latestLocation;\n      }\n      const next = router.buildNext(navigateOpts);\n      const matches = router.matchRoutes(next.pathname, {\n        strictParseParams: true\n      });\n      await router.loadMatches(matches);\n      return matches;\n    },\n    preloadRoute: async function (navigateOpts, loaderOpts) {\n      if (navigateOpts === void 0) {\n        navigateOpts = store.latestLocation;\n      }\n      const next = router.buildNext(navigateOpts);\n      const matches = router.matchRoutes(next.pathname, {\n        strictParseParams: true\n      });\n      await router.loadMatches(matches, {\n        preload: true,\n        maxAge: loaderOpts.maxAge ?? router.options.defaultPreloadMaxAge ?? router.options.defaultLoaderMaxAge ?? 0,\n        gcMaxAge: loaderOpts.gcMaxAge ?? router.options.defaultPreloadGcMaxAge ?? router.options.defaultLoaderGcMaxAge ?? 0\n      });\n      return matches;\n    },\n    matchRoutes: (pathname, opts) => {\n      router.cleanMatchCache();\n      const matches = [];\n      if (!router.routeTree) {\n        return matches;\n      }\n      const existingMatches = [...store.currentMatches, ...(store.pendingMatches ?? [])];\n      const recurse = async routes => {\n        var _foundRoute$childRout;\n        const parentMatch = last(matches);\n        let params = (parentMatch == null ? void 0 : parentMatch.params) ?? {};\n        const filteredRoutes = (router.options.filterRoutes == null ? void 0 : router.options.filterRoutes(routes)) ?? routes;\n        let foundRoutes = [];\n        const findMatchInRoutes = (parentRoutes, routes) => {\n          routes.some(route => {\n            var _route$childRoutes, _route$childRoutes2;\n            if (!route.routePath && (_route$childRoutes = route.childRoutes) != null && _route$childRoutes.length) {\n              return findMatchInRoutes([...foundRoutes, route], route.childRoutes);\n            }\n            const fuzzy = !!(route.routePath !== '/' || (_route$childRoutes2 = route.childRoutes) != null && _route$childRoutes2.length);\n            const matchParams = matchPathname(router.basepath, pathname, {\n              to: route.fullPath,\n              fuzzy,\n              caseSensitive: route.options.caseSensitive ?? router.options.caseSensitive\n            });\n            if (matchParams) {\n              let parsedParams;\n              try {\n                parsedParams = (route.options.parseParams == null ? void 0 : route.options.parseParams(matchParams)) ?? matchParams;\n              } catch (err) {\n                if (opts != null && opts.strictParseParams) {\n                  throw err;\n                }\n              }\n              params = {\n                ...params,\n                ...parsedParams\n              };\n            }\n            if (!!matchParams) {\n              foundRoutes = [...parentRoutes, route];\n            }\n            return !!foundRoutes.length;\n          });\n          return !!foundRoutes.length;\n        };\n        findMatchInRoutes([], filteredRoutes);\n        if (!foundRoutes.length) {\n          return;\n        }\n        foundRoutes.forEach(foundRoute => {\n          var _store$matchCache$mat;\n          const interpolatedPath = interpolatePath(foundRoute.routePath, params);\n          const matchId = interpolatePath(foundRoute.routeId, params, true);\n          const match = existingMatches.find(d => d.matchId === matchId) || ((_store$matchCache$mat = store.matchCache[matchId]) == null ? void 0 : _store$matchCache$mat.match) || createRouteMatch(router, foundRoute, {\n            parentMatch,\n            matchId,\n            params,\n            pathname: joinPaths([router.basepath, interpolatedPath])\n          });\n          matches.push(match);\n        });\n        const foundRoute = last(foundRoutes);\n        if ((_foundRoute$childRout = foundRoute.childRoutes) != null && _foundRoute$childRout.length) {\n          recurse(foundRoute.childRoutes);\n        }\n      };\n      recurse([router.routeTree]);\n      linkMatches(matches);\n      return matches;\n    },\n    loadMatches: async (resolvedMatches, loaderOpts) => {\n      resolvedMatches.forEach(async match => {\n        // Validate the match (loads search params etc)\n        match.__.validate();\n      });\n\n      // Check each match middleware to see if the route can be accessed\n      await Promise.all(resolvedMatches.map(async match => {\n        try {\n          await (match.options.beforeLoad == null ? void 0 : match.options.beforeLoad({\n            router: router,\n            match\n          }));\n        } catch (err) {\n          if (!(loaderOpts != null && loaderOpts.preload)) {\n            match.options.onLoadError == null ? void 0 : match.options.onLoadError(err);\n          }\n          throw err;\n        }\n      }));\n      const matchPromises = resolvedMatches.map(async match => {\n        var _search$__data;\n        const search = match.store.search;\n        if ((_search$__data = search.__data) != null && _search$__data.matchId && search.__data.matchId !== match.matchId) {\n          return;\n        }\n        match.load(loaderOpts);\n        if (match.store.status !== 'success' && match.__.loadPromise) {\n          // Wait for the first sign of activity from the match\n          await match.__.loadPromise;\n        }\n      });\n      await Promise.all(matchPromises);\n    },\n    loadMatchData: async routeMatch => {\n      if (isServer || !router.options.useServerData) {\n        return (await (routeMatch.options.loader == null ? void 0 : routeMatch.options.loader({\n          // parentLoaderPromise: routeMatch.parentMatch?.__.dataPromise,\n          params: routeMatch.params,\n          search: routeMatch.store.routeSearch,\n          signal: routeMatch.__.abortController.signal\n        }))) || {};\n      } else {\n        const next = router.buildNext({\n          to: '.',\n          search: d => ({\n            ...(d ?? {}),\n            __data: {\n              matchId: routeMatch.matchId\n            }\n          })\n        });\n\n        // Refresh:\n        // '/dashboard'\n        // '/dashboard/invoices/'\n        // '/dashboard/invoices/123'\n\n        // New:\n        // '/dashboard/invoices/456'\n\n        // TODO: batch requests when possible\n\n        const res = await fetch(next.href, {\n          method: 'GET'\n          // signal: routeMatch.__.abortController.signal,\n        });\n\n        if (res.ok) {\n          return res.json();\n        }\n        throw new Error('Failed to fetch match data');\n      }\n    },\n    invalidateRoute: opts => {\n      const next = router.buildNext(opts);\n      const unloadedMatchIds = router.matchRoutes(next.pathname).map(d => d.matchId);\n      [...store.currentMatches, ...(store.pendingMatches ?? [])].forEach(match => {\n        if (unloadedMatchIds.includes(match.matchId)) {\n          match.invalidate();\n        }\n      });\n    },\n    reload: () => navigate({\n      fromCurrent: true,\n      replace: true,\n      search: true\n    }),\n    resolvePath: (from, path) => {\n      return resolvePath(router.basepath, from, cleanPath(path));\n    },\n    matchRoute: (location, opts) => {\n      // const location = router.buildNext(opts)\n\n      location = {\n        ...location,\n        to: location.to ? router.resolvePath(location.from ?? '', location.to) : undefined\n      };\n      const next = router.buildNext(location);\n      if (opts != null && opts.pending) {\n        if (!store.pendingLocation) {\n          return false;\n        }\n        return !!matchPathname(router.basepath, store.pendingLocation.pathname, {\n          ...opts,\n          to: next.pathname\n        });\n      }\n      return matchPathname(router.basepath, store.currentLocation.pathname, {\n        ...opts,\n        to: next.pathname\n      });\n    },\n    navigate: async _ref => {\n      let {\n        from,\n        to = '.',\n        search,\n        hash,\n        replace,\n        params\n      } = _ref;\n      // If this link simply reloads the current route,\n      // make sure it has a new key so it will trigger a data refresh\n\n      // If this `to` is a valid external URL, return\n      // null for LinkUtils\n      const toString = String(to);\n      const fromString = String(from);\n      let isExternal;\n      try {\n        new URL(`${toString}`);\n        isExternal = true;\n      } catch (e) {}\n      invariant(!isExternal, 'Attempting to navigate to external url with router.navigate!');\n      return navigate({\n        from: fromString,\n        to: toString,\n        search,\n        hash,\n        replace,\n        params\n      });\n    },\n    buildLink: _ref2 => {\n      let {\n        from,\n        to = '.',\n        search,\n        params,\n        hash,\n        target,\n        replace,\n        activeOptions,\n        preload,\n        preloadMaxAge: userPreloadMaxAge,\n        preloadGcMaxAge: userPreloadGcMaxAge,\n        preloadDelay: userPreloadDelay,\n        disabled\n      } = _ref2;\n      // If this link simply reloads the current route,\n      // make sure it has a new key so it will trigger a data refresh\n\n      // If this `to` is a valid external URL, return\n      // null for LinkUtils\n\n      try {\n        new URL(`${to}`);\n        return {\n          type: 'external',\n          href: to\n        };\n      } catch (e) {}\n      const nextOpts = {\n        from,\n        to,\n        search,\n        params,\n        hash,\n        replace\n      };\n      const next = router.buildNext(nextOpts);\n      preload = preload ?? router.options.defaultPreload;\n      const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;\n\n      // Compare path/hash for matches\n      const pathIsEqual = store.currentLocation.pathname === next.pathname;\n      const currentPathSplit = store.currentLocation.pathname.split('/');\n      const nextPathSplit = next.pathname.split('/');\n      const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);\n      const hashIsEqual = store.currentLocation.hash === next.hash;\n      // Combine the matches based on user options\n      const pathTest = activeOptions != null && activeOptions.exact ? pathIsEqual : pathIsFuzzyEqual;\n      const hashTest = activeOptions != null && activeOptions.includeHash ? hashIsEqual : true;\n\n      // The final \"active\" test\n      const isActive = pathTest && hashTest;\n\n      // The click handler\n      const handleClick = e => {\n        if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {\n          e.preventDefault();\n          if (pathIsEqual && !search && !hash) {\n            router.invalidateRoute(nextOpts);\n          }\n\n          // All is well? Navigate!\n          navigate(nextOpts);\n        }\n      };\n\n      // The click handler\n      const handleFocus = e => {\n        if (preload) {\n          router.preloadRoute(nextOpts, {\n            maxAge: userPreloadMaxAge,\n            gcMaxAge: userPreloadGcMaxAge\n          }).catch(err => {\n            console.log(err);\n            console.warn('Error preloading route! ');\n          });\n        }\n      };\n      const handleEnter = e => {\n        const target = e.target || {};\n        if (preload) {\n          if (target.preloadTimeout) {\n            return;\n          }\n          target.preloadTimeout = setTimeout(() => {\n            target.preloadTimeout = null;\n            router.preloadRoute(nextOpts, {\n              maxAge: userPreloadMaxAge,\n              gcMaxAge: userPreloadGcMaxAge\n            }).catch(err => {\n              console.log(err);\n              console.warn('Error preloading route! ');\n            });\n          }, preloadDelay);\n        }\n      };\n      const handleLeave = e => {\n        const target = e.target || {};\n        if (target.preloadTimeout) {\n          clearTimeout(target.preloadTimeout);\n          target.preloadTimeout = null;\n        }\n      };\n      return {\n        type: 'internal',\n        next,\n        handleFocus,\n        handleClick,\n        handleEnter,\n        handleLeave,\n        isActive,\n        disabled\n      };\n    },\n    buildNext: opts => {\n      const next = buildLocation(opts);\n      const matches = router.matchRoutes(next.pathname);\n      const __preSearchFilters = matches.map(match => match.options.preSearchFilters ?? []).flat().filter(Boolean);\n      const __postSearchFilters = matches.map(match => match.options.postSearchFilters ?? []).flat().filter(Boolean);\n      return buildLocation({\n        ...opts,\n        __preSearchFilters,\n        __postSearchFilters\n      });\n    }\n  };\n  router.update(userOptions);\n\n  // Allow frameworks to hook into the router creation\n  router.options.createRouter == null ? void 0 : router.options.createRouter(router);\n  return router;\n}\nfunction isCtrlEvent(e) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n}\nfunction linkMatches(matches) {\n  matches.forEach((match, index) => {\n    const parent = matches[index - 1];\n    if (parent) {\n      match.__.setParentMatch(parent);\n    } else {\n      match.__.setParentMatch(undefined);\n    }\n  });\n}\n\nexport { cleanPath, createRoute, createRouteConfig, createRouteMatch, createRouter, decode, defaultParseSearch, defaultStringifySearch, encode, functionalUpdate, interpolatePath, joinPaths, last, matchByPath, matchPathname, parsePathname, parseSearchWith, pick, resolvePath, rootRouteId, sharedClone, stringifySearchWith, trimPath, trimPathLeft, trimPathRight, warning };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\n\nimport { useSyncExternalStore } from 'use-sync-external-store/shim'\n// @ts-ignore\n// import { useSyncExternalStore } from './uSES/useSyncExternalStoreShim'\nimport { createEffect, createRoot, untrack, unwrap } from '@solidjs/reactivity'\nimport { createStore } from '@solidjs/reactivity'\n\nimport {\n  Route,\n  RegisteredAllRouteInfo,\n  RegisteredRouter,\n  RouterStore,\n  last,\n  sharedClone,\n  Action,\n  warning,\n  RouterOptions,\n  RouteMatch,\n  MatchRouteOptions,\n  RouteConfig,\n  AnyRouteConfig,\n  AnyAllRouteInfo,\n  DefaultAllRouteInfo,\n  functionalUpdate,\n  createRouter,\n  AllRouteInfo,\n  ValidFromPath,\n  LinkOptions,\n  RouteInfoByPath,\n  ResolveRelativePath,\n  NoInfer,\n  ToOptions,\n  invariant,\n  Router,\n  Expand,\n} from '@tanstack/router-core'\n\nexport * from '@tanstack/router-core'\n\nexport * from '@solidjs/reactivity'\n\ntype ReactNode = any\n\nexport type SyncRouteComponent<TProps = {}> = (props: TProps) => ReactNode\n\nexport type RouteComponent<TProps = {}> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport function lazy(\n  importer: () => Promise<{ default: SyncRouteComponent }>,\n): RouteComponent {\n  const lazyComp = React.lazy(importer as any)\n  let preloaded: Promise<SyncRouteComponent>\n\n  const finalComp = lazyComp as unknown as RouteComponent\n\n  finalComp.preload = async () => {\n    if (!preloaded) {\n      await importer()\n    }\n  }\n\n  return finalComp\n}\n\nexport type LinkPropsOptions<\n  TFrom extends RegisteredAllRouteInfo['routePaths'] = '/',\n  TTo extends string = '.',\n> = LinkOptions<RegisteredAllRouteInfo, TFrom, TTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n\nexport type MakeUseMatchRouteOptions<\n  TFrom extends RegisteredAllRouteInfo['routePaths'] = '/',\n  TTo extends string = '.',\n> = ToOptions<RegisteredAllRouteInfo, TFrom, TTo> & MatchRouteOptions\n\nexport type MakeMatchRouteOptions<\n  TFrom extends RegisteredAllRouteInfo['routePaths'] = '/',\n  TTo extends string = '.',\n> = ToOptions<RegisteredAllRouteInfo, TFrom, TTo> &\n  MatchRouteOptions & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | ReactNode\n      | ((\n          params: RouteInfoByPath<\n            RegisteredAllRouteInfo,\n            ResolveRelativePath<TFrom, NoInfer<TTo>>\n          >['allParams'],\n        ) => ReactNode)\n  }\n\nexport type MakeLinkPropsOptions<\n  TFrom extends ValidFromPath<RegisteredAllRouteInfo> = '/',\n  TTo extends string = '.',\n> = LinkPropsOptions<TFrom, TTo> & React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type MakeLinkOptions<\n  TFrom extends RegisteredAllRouteInfo['routePaths'] = '/',\n  TTo extends string = '.',\n> = LinkPropsOptions<TFrom, TTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement> &\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?: ReactNode | ((state: { isActive: boolean }) => ReactNode)\n  }\n\ndeclare module '@tanstack/router-core' {\n  interface FrameworkGenerics {\n    Component: RouteComponent\n    ErrorComponent: RouteComponent<{\n      error: unknown\n      info: { componentStack: string }\n    }>\n  }\n\n  interface RouterOptions<TRouteConfig, TRouterContext> {\n    // ssrFooter?: () => JSX.Element | Node\n  }\n}\n\nexport type PromptProps = {\n  message: string\n  when?: boolean | any\n  children?: ReactNode\n}\n\n//\n\nexport function useLinkProps<\n  TFrom extends ValidFromPath<RegisteredAllRouteInfo> = '/',\n  TTo extends string = '.',\n>(\n  options: MakeLinkPropsOptions<TFrom, TTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouter()\n\n  const {\n    // custom props\n    type,\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    // fromCurrent,\n    hash,\n    search,\n    params,\n    to,\n    preload,\n    preloadDelay,\n    preloadMaxAge,\n    replace,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    onTouchEnd,\n    ...rest\n  } = options\n\n  const linkInfo = router.buildLink(options as any)\n\n  if (linkInfo.type === 'external') {\n    const { href } = linkInfo\n    return { href }\n  }\n\n  const { handleClick, handleFocus, handleEnter, handleLeave, isActive, next } =\n    linkInfo\n\n  const reactHandleClick = (e: Event) => {\n    if (React.startTransition) {\n      // This is a hack for react < 18\n      React.startTransition(() => {\n        handleClick(e)\n      })\n    } else {\n      handleClick(e)\n    }\n  }\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled ? undefined : next.href,\n    onClick: composeHandlers([onClick, reactHandleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkFn<\n  TDefaultFrom extends RegisteredAllRouteInfo['routePaths'] = '/',\n  TDefaultTo extends string = '.',\n> {\n  <\n    TFrom extends RegisteredAllRouteInfo['routePaths'] = TDefaultFrom,\n    TTo extends string = TDefaultTo,\n  >(\n    props: MakeLinkOptions<TFrom, TTo> & React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkFn = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n\ntype MatchesContextValue = RouteMatch[]\n\nexport const matchesContext = React.createContext<MatchesContextValue>(null!)\nexport const routerContext = React.createContext<{ router: RegisteredRouter }>(\n  null!,\n)\n\nexport type MatchesProviderProps = {\n  value: MatchesContextValue\n  children: ReactNode\n}\n\nconst EMPTY = {}\n\nexport const __useStoreValue = <TSeed, TReturn>(\n  seed: () => TSeed,\n  selector?: (seed: TSeed) => TReturn,\n): TReturn => {\n  const valueRef = React.useRef<TReturn>(EMPTY as any)\n\n  // If there is no selector, track the seed\n  // If there is a selector, do not track the seed\n  const getValue = () =>\n    (!selector ? seed() : selector(untrack(() => seed()))) as TReturn\n\n  // If empty, initialize the value\n  if (valueRef.current === EMPTY) {\n    valueRef.current = sharedClone(undefined, getValue())\n  }\n\n  // Snapshot should just return the current cached value\n  const getSnapshot = React.useCallback(() => valueRef.current, [])\n\n  const getStore = React.useCallback((cb: () => void) => {\n    // A root is necessary to track effects\n    return createRoot(() => {\n      createEffect(() => {\n        // Read and update the value\n        // getValue will handle which values are accessed and\n        // thus tracked.\n        // sharedClone will both recursively track the end result\n        // and ensure that the previous value is structurally shared\n        // into the new version.\n        valueRef.current = unwrap(\n          // Unwrap the value to get rid of any proxy structures\n          sharedClone(valueRef.current, getValue()),\n        )\n        cb()\n      })\n    })\n  }, [])\n\n  return useSyncExternalStore(getStore, getSnapshot, getSnapshot)\n}\n\nconst [store, setStore] = createStore({ foo: 'foo', bar: { baz: 'baz' } })\n\ncreateRoot(() => {\n  let prev: any\n\n  createEffect(() => {\n    console.log('effect')\n    const next = sharedClone(prev, store)\n    console.log(next)\n    prev = untrack(() => next)\n  })\n})\n\nsetStore((s) => {\n  s.foo = '1'\n})\n\nsetStore((s) => {\n  s.bar.baz = '2'\n})\n\nexport function createReactRouter<\n  TRouteConfig extends AnyRouteConfig = RouteConfig,\n  TAllRouteInfo extends AnyAllRouteInfo = AllRouteInfo<TRouteConfig>,\n  TRouterContext = unknown,\n>(\n  opts: RouterOptions<TRouteConfig, TRouterContext>,\n): Router<TRouteConfig, TAllRouteInfo, TRouterContext> {\n  const coreRouter = createRouter<TRouteConfig>({\n    ...opts,\n    loadComponent: async (component) => {\n      if (component.preload) {\n        await component.preload()\n      }\n\n      return component as any\n    },\n  })\n\n  return coreRouter as any\n}\n\nexport type RouterProps<\n  TRouteConfig extends AnyRouteConfig = RouteConfig,\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouterContext = unknown,\n> = RouterOptions<TRouteConfig, TRouterContext> & {\n  router: Router<TRouteConfig, TAllRouteInfo, TRouterContext>\n}\n\nexport function RouterProvider<\n  TRouteConfig extends AnyRouteConfig = RouteConfig,\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouterContext = unknown,\n>({\n  router,\n  ...rest\n}: RouterProps<TRouteConfig, TAllRouteInfo, TRouterContext>) {\n  router.update(rest)\n\n  const [, , currentMatches] = __useStoreValue(\n    () => router.store,\n    (s) => [s.status, s.pendingMatches, s.currentMatches],\n  )\n\n  React.useEffect(router.mount, [router])\n\n  console.log('current', currentMatches)\n\n  return (\n    <>\n      <routerContext.Provider value={{ router: router as any }}>\n        <matchesContext.Provider value={[undefined!, ...currentMatches]}>\n          <Outlet />\n        </matchesContext.Provider>\n      </routerContext.Provider>\n    </>\n  )\n}\n\nexport function useRouter(): RegisteredRouter {\n  const value = React.useContext(routerContext)\n  warning(!value, 'useRouter must be used inside a <Router> component!')\n  return value.router\n}\n\nexport function useRouterStore<T = RouterStore>(\n  selector?: (state: Router['store']) => T,\n): T {\n  const router = useRouter()\n  return __useStoreValue(() => router.store, selector)\n}\n\nexport function useMatches(): RouteMatch[] {\n  return React.useContext(matchesContext)\n}\n\nexport function useMatch<\n  TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'],\n  TStrict extends boolean = true,\n  TRouteMatch = RouteMatch<\n    RegisteredAllRouteInfo,\n    RegisteredAllRouteInfo['routeInfoById'][TFrom]\n  >,\n  // TSelected = TRouteMatch,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  // select?: (match: TRouteMatch) => TSelected\n}): TStrict extends true ? TRouteMatch : TRouteMatch | undefined {\n  const router = useRouter()\n  const nearestMatch = useMatches()[0]!\n  const match = opts?.from\n    ? router.store.currentMatches.find((d) => d.routeId === opts?.from)\n    : nearestMatch\n\n  invariant(\n    match,\n    `Could not find ${\n      opts?.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'\n    }`,\n  )\n\n  if (opts?.strict ?? true) {\n    invariant(\n      nearestMatch.routeId == match?.routeId,\n      `useMatch(\"${\n        match?.routeId as string\n      }\") is being called in a component that is meant to render the '${\n        nearestMatch.routeId\n      }' route. Did you mean to 'useMatch(\"${\n        match?.routeId as string\n      }\", { strict: false })' or 'useRoute(\"${\n        match?.routeId as string\n      }\")' instead?`,\n    )\n  }\n\n  __useStoreValue(() => match!.store)\n\n  return match as any\n}\n\nexport function useRoute<\n  TId extends keyof RegisteredAllRouteInfo['routeInfoById'] = '/',\n>(\n  routeId: TId,\n): Route<RegisteredAllRouteInfo, RegisteredAllRouteInfo['routeInfoById'][TId]> {\n  const router = useRouter()\n  const resolvedRoute = router.getRoute(routeId as any)\n\n  invariant(\n    resolvedRoute,\n    `Could not find a route for route \"${\n      routeId as string\n    }\"! Did you forget to add it to your route config?`,\n  )\n\n  return resolvedRoute as any\n}\n\nexport function useLoaderData<\n  TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'] = '/',\n  TStrict extends boolean = true,\n  TLoaderData = RegisteredAllRouteInfo['routeInfoById'][TFrom]['loaderData'],\n  TSelected = TLoaderData,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  select?: (loaderData: TLoaderData) => TSelected\n}): TStrict extends true ? TSelected : TSelected | undefined {\n  const match = useMatch(opts) as any\n  return __useStoreValue(() => match?.store.loaderData, opts?.select)\n}\n\nexport function useSearch<\n  TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'],\n  TStrict extends boolean = true,\n  TSearch = RegisteredAllRouteInfo['routeInfoById'][TFrom]['fullSearchSchema'],\n  TSelected = TSearch,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  select?: (search: TSearch) => TSelected\n}): TStrict extends true ? TSelected : TSelected | undefined {\n  const match = useMatch(opts)\n  return __useStoreValue(() => match?.store.search, opts?.select) as any\n}\n\nexport function useParams<\n  TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'] = '/',\n  TDefaultSelected = Expand<\n    RegisteredAllRouteInfo['allParams'] &\n      RegisteredAllRouteInfo['routeInfoById'][TFrom]['allParams']\n  >,\n  TSelected = TDefaultSelected,\n>(opts?: {\n  from: TFrom\n  select?: (search: TDefaultSelected) => TSelected\n}): TSelected {\n  const router = useRouter()\n  return __useStoreValue(\n    () => last(router.store.currentMatches)?.params as any,\n    opts?.select,\n  )\n}\n\nexport function useNavigate<\n  TDefaultFrom extends keyof RegisteredAllRouteInfo['routeInfoById'] = '/',\n>(defaultOpts: { from?: TDefaultFrom }) {\n  const router = useRouter()\n  return <\n    TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'] = TDefaultFrom,\n    TTo extends string = '.',\n  >(\n    opts: MakeLinkOptions<TFrom, TTo>,\n  ) => {\n    return router.navigate({ ...defaultOpts, ...(opts as any) })\n  }\n}\n\nexport function useAction<\n  TFrom extends keyof RegisteredAllRouteInfo['routeInfoById'] = '/',\n  TFromRoute extends RegisteredAllRouteInfo['routeInfoById'][TFrom] = RegisteredAllRouteInfo['routeInfoById'][TFrom],\n>(opts: {\n  from: TFrom\n}): Action<TFromRoute['actionPayload'], TFromRoute['actionResponse']> {\n  const route = useRoute(opts.from)\n  const action = route.action\n  __useStoreValue(() => action)\n  return action as any\n}\n\nexport function useMatchRoute() {\n  const router = useRouter()\n\n  return <\n    TFrom extends ValidFromPath<RegisteredAllRouteInfo> = '/',\n    TTo extends string = '.',\n  >(\n    opts: MakeUseMatchRouteOptions<TFrom, TTo>,\n  ) => {\n    const { pending, caseSensitive, ...rest } = opts\n\n    return router.matchRoute(rest as any, {\n      pending,\n      caseSensitive,\n    })\n  }\n}\n\nexport function MatchRoute<\n  TFrom extends ValidFromPath<RegisteredAllRouteInfo> = '/',\n  TTo extends string = '.',\n>(props: MakeMatchRouteOptions<TFrom, TTo>): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props)\n\n  if (!params) {\n    return null\n  }\n\n  return React.createElement(\n    typeof props.children === 'function'\n      ? (props.children as any)(params)\n      : props.children,\n    props as any,\n  )\n}\n\nexport function Outlet() {\n  const router = useRouter()\n  const matches = useMatches().slice(1)\n  const match = matches[0]\n\n  const defaultPending = React.useCallback(() => null, [])\n\n  __useStoreValue(() => match?.store)\n\n  const Inner = React.useCallback((props: { match: RouteMatch }): any => {\n    if (props.match.store.status === 'error') {\n      throw props.match.store.error\n    }\n\n    if (props.match.store.status === 'success') {\n      return React.createElement(\n        (props.match.__.component as any) ??\n          router.options.defaultComponent ??\n          Outlet,\n      )\n    }\n\n    if (props.match.store.status === 'loading') {\n      throw props.match.__.loadPromise\n    }\n\n    invariant(\n      false,\n      'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n    )\n  }, [])\n\n  if (!match) {\n    return null\n  }\n\n  const PendingComponent = (match.__.pendingComponent ??\n    router.options.defaultPendingComponent ??\n    defaultPending) as any\n\n  const errorComponent =\n    match.__.errorComponent ?? router.options.defaultErrorComponent\n\n  return (\n    <matchesContext.Provider value={matches}>\n      <React.Suspense fallback={<PendingComponent />}>\n        <CatchBoundary\n          key={match.routeId}\n          errorComponent={errorComponent}\n          match={match as any}\n        >\n          <Inner match={match} />\n        </CatchBoundary>\n      </React.Suspense>\n      {/* Provide a suffix suspense boundary to make sure the router is\n  ready to be dehydrated on the server */}\n      {/* {router.options.ssrFooter && match.matchId === rootRouteId ? (\n        <React.Suspense fallback={null}>\n          {(() => {\n            if (router.store.pending) {\n              throw router.navigationPromise\n            }\n\n            return router.options.ssrFooter()\n          })()}\n        </React.Suspense>\n      ) : null} */}\n    </matchesContext.Provider>\n  )\n}\n\nclass CatchBoundary extends React.Component<{\n  children: any\n  errorComponent: any\n  match: RouteMatch\n}> {\n  state = {\n    error: false,\n    info: undefined,\n  }\n\n  componentDidCatch(error: any, info: any) {\n    console.error(`Error in route match: ${this.props.match.matchId}`)\n    console.error(error)\n\n    this.setState({\n      error,\n      info,\n    })\n  }\n\n  render() {\n    return (\n      <CatchBoundaryInner\n        {...this.props}\n        errorState={this.state}\n        reset={() => this.setState({})}\n      />\n    )\n  }\n}\n\n// This is the messiest thing ever... I'm either seriously tired (likely) or\n// there has to be a better way to reset error boundaries when the\n// router's location key changes.\nfunction CatchBoundaryInner(props: {\n  children: any\n  errorComponent: any\n  errorState: { error: unknown; info: any }\n  reset: () => void\n}) {\n  const [activeErrorState, setActiveErrorState] = React.useState(\n    props.errorState,\n  )\n  const router = useRouter()\n  const errorComponent = props.errorComponent ?? DefaultErrorBoundary\n\n  React.useEffect(() => {\n    if (activeErrorState) {\n      let prevKey = router.store.currentLocation.key\n      return createRoot(() =>\n        createEffect(() => {\n          if (router.store.currentLocation.key !== prevKey) {\n            prevKey = router.store.currentLocation.key\n            setActiveErrorState({} as any)\n          }\n        }),\n      )\n    }\n\n    return\n  }, [activeErrorState])\n\n  React.useEffect(() => {\n    if (props.errorState.error) {\n      setActiveErrorState(props.errorState)\n    }\n    props.reset()\n  }, [props.errorState.error])\n\n  if (props.errorState.error) {\n    return React.createElement(errorComponent, activeErrorState)\n  }\n\n  return props.children\n}\n\nexport function DefaultErrorBoundary({ error }: { error: any }) {\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <strong style={{ fontSize: '1.2rem' }}>Something went wrong!</strong>\n      <div style={{ height: '.5rem' }} />\n      <div>\n        <pre>\n          {error.message ? (\n            <code\n              style={{\n                fontSize: '.7em',\n                border: '1px solid red',\n                borderRadius: '.25rem',\n                padding: '.5rem',\n                color: 'red',\n              }}\n            >\n              {error.message}\n            </code>\n          ) : null}\n        </pre>\n      </div>\n    </div>\n  )\n}\n\nexport function usePrompt(message: string, when: boolean | any): void {\n  const router = useRouter()\n\n  React.useEffect(() => {\n    if (!when) return\n\n    let unblock = router.history.block((transition) => {\n      if (window.confirm(message)) {\n        unblock()\n        transition.retry()\n      } else {\n        router.store.currentLocation.pathname = window.location.pathname\n      }\n    })\n\n    return unblock\n  }, [when, message])\n}\n\nexport function Prompt({ message, when, children }: PromptProps) {\n  usePrompt(message, when ?? true)\n  return (children ?? null) as ReactNode\n}\n\n// function circularStringify(obj: any) {\n//   const seen = new Set()\n\n//   return (\n//     JSON.stringify(obj, (_, value) => {\n//       if (typeof value === 'function') {\n//         return undefined\n//       }\n//       if (typeof value === 'object' && value !== null) {\n//         if (seen.has(value)) return\n//         seen.add(value)\n//       }\n//       return value\n//     }) || ''\n//   )\n// }\n"],"names":["Root","CurrentReaction","CurrentGets","CurrentGetsIndex","EffectQueue","Reactive","value","fn","observers","sources","state","effect","cleanups","alwaysUpdate","constructor","fnOrValue","type","this","push","console","error","update","get","updateIfNecessary","set","notInBatch","newValue","i","length","stale","stabilize","oldValue","prevReaction","prevGets","prevIndex","forEach","c","removeParentObservers","source","index","swap","findIndex","v","pop","destroy","createEffect","bind","createRoot","root","r","batch","out","untrack","listener","$RAW","Symbol","$TRACK","$PROXY","$NODE","wrap","p","Object","defineProperty","Proxy","proxyTraps","Array","isArray","keys","desc","getOwnPropertyDescriptors","l","prop","enumerable","isWrappable","obj","proto","getPrototypeOf","prototype","unwrap","item","Set","result","unwrapped","has","isFrozen","slice","add","assign","getDataNodes","target","nodes","getDataNode","property","createDataNode","trackSelf","_","s","Action","Writing","receiver","tracked","hasOwnProperty","getOwnPropertyDescriptor","setProperty","deleteProperty","ownKeys","Reflect","configurable","writable","deleting","prev","len","node","createStore","store","wrappedStore","_extends","arguments","key","call","apply","BeforeUnloadEventType","PopStateEventType","createBrowserHistory","options","_options$window","window","document","defaultView","globalHistory","history","getIndexAndLocation","_window$location","location","pathname","search","hash","idx","usr","blockedPopTx","addEventListener","blockers","nextAction","Pop","_getIndexAndLocation","nextIndex","nextLocation","delta","action","retry","go","applyTx","_getIndexAndLocation2","listeners","createEvents","createHref","to","createPath","getNextLocation","parsePath","createKey","getHistoryStateAndUrl","allowTx","_getIndexAndLocation3","replaceState","Push","_getHistoryStateAndUr","historyState","url","pushState","replace","Replace","_getHistoryStateAndUr2","back","forward","listen","block","blocker","unblock","promptBeforeUnload","removeEventListener","createMemoryHistory","_options3","_options3$initialEntr","initialEntries","initialIndex","entries","map","entry","clamp","splice","n","lowerBound","upperBound","Math","min","max","event","preventDefault","returnValue","handlers","filter","handler","arg","random","toString","substr","_ref","_ref$pathname","_ref$search","_ref$hash","charAt","path","parsedPath","hashIndex","indexOf","searchIndex","invariant","condition","message","Error","last","arr","warning","cond","warn","functionalUpdate","updater","previous","pick","parent","reduce","joinPaths","paths","cleanPath","Boolean","join","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","RegExp","baseSegments","parsePathname","toSegments","toSegment","_last","d","segments","substring","split","part","startsWith","interpolatePath","params","leaveWildcard","segment","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","from","routeSegments","baseSegment","routeSegment","isLastRouteSegment","isLastBaseSegment","caseSensitive","toLowerCase","fuzzy","undefined","encode","pfx","k","tmp","str","encodeURIComponent","toValue","mix","decodeURIComponent","decode","shift","concat","createRoute","routeConfig","originalIndex","router","id","routeId","routePath","fullPath","route","routeInfo","routeRouteId","childRoutes","parentRoute","actions","setStore","submissions","submit","async","submission","actionOpts","invalidate","actionStore","setActionStore","submittedAt","Date","now","status","isMulti","multi","current","latest","res","data","invalidateRoute","fromCurrent","reload","err","loader","loaders","pending","fetch","loaderState","loadedAt","loaderContext","rootRouteId","createRouteConfig","children","isRoot","parentId","parentPath","addChildren","childOptions","generate","sharedClone","next","touchAll","things","Map","recurse","prevIsArray","nextIsArray","prevIsObj","isPlainObject","nextIsObj","aSize","bItems","bSize","copy","equalItems","nextKeys","o","hasObjectPrototype","ctor","prot","componentTypes","createRouteMatch","opts","componentsPromise","dataPromise","latestId","resolve","updateLoaderData","_store$parentMatch","loaderData","parentMatch","routeLoaderData","routeSearch","isFetching","invalid","invalidAt","Infinity","isInvalid","routeMatch","childMatches","__","setParentMatch","abortController","AbortController","validate","_store$parentMatch2","parentSearch","currentLocation","prevSearch","validator","validateSearch","parse","nextSearch","component","cause","code","cancel","_routeMatch$__$abortC","abort","hasLoaders","some","_route$options$d","preload","load","minMaxAge","loaderOpts","maxAge","gcMaxAge","currentMatches","find","matchId","matchCache","gc","match","loadId","checkLatest","Promise","loadPromise","all","_routeMatch$__$type","loadComponent","then","loadMatchData","updatedAt","loaderMaxAge","defaultLoaderMaxAge","after","catch","defaultParseSearch","parseSearchWith","JSON","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","query","val","_window$document","isServer","createElement","getInitialRouterState","latestLocation","lastUpdated","isPreloading","values","dd","createRouter","userOptions","originalOptions","defaultLoaderGcMaxAge","defaultPreloadMaxAge","defaultPreloadDelay","context","stringifySearch","parseSearch","navigationPromise","startedLoadingAt","resolveNavigation","onFocus","parseLocation","previousLocation","parsedSearch","reverse","href","navigate","previousNavigationResolve","commitLocation","buildNext","buildLocation","dest","_dest$__preSearchFilt","_dest$__preSearchFilt2","_dest$__postSearchFil","fromPathname","fromMatches","matchRoutes","strictParseParams","toMatches","prevParams","nextParams","stringifyParams","preFilteredSearch","__preSearchFilters","destSearch","postFilteredSearch","__postSearchFilters","types","routeTree","routesById","reset","getRoute","dehydrate","hydrate","dehydratedRouter","dehydratedMatch","mount","unsub","newHistory","rootRouteConfig","recurseRoutes","routeConfigs","buildRouteTree","cancelMatches","pendingMatches","startedAt","matches","log","pendingLocation","loadMatches","previousMatches","exiting","staying","entering","onExit","loaderGcMaxAge","Number","MAX_SAFE_INTEGER","onTransition","onLoaded","cleanMatchCache","loadRoute","navigateOpts","preloadRoute","defaultPreloadGcMaxAge","existingMatches","_foundRoute$childRout","filteredRoutes","filterRoutes","routes","foundRoutes","findMatchInRoutes","parentRoutes","_route$childRoutes","_route$childRoutes2","matchParams","parsedParams","parseParams","foundRoute","_store$matchCache$mat","interpolatedPath","linkMatches","resolvedMatches","beforeLoad","onLoadError","matchPromises","_search$__data","__data","useServerData","signal","method","ok","json","unloadedMatchIds","includes","matchRoute","String","fromString","isExternal","URL","e","buildLink","_ref2","activeOptions","preloadMaxAge","userPreloadMaxAge","preloadGcMaxAge","userPreloadGcMaxAge","preloadDelay","userPreloadDelay","disabled","nextOpts","defaultPreload","pathIsEqual","currentPathSplit","pathIsFuzzyEqual","every","hashIsEqual","pathTest","exact","hashTest","includeHash","handleFocus","handleClick","metaKey","altKey","ctrlKey","shiftKey","isCtrlEvent","defaultPrevented","button","handleEnter","preloadTimeout","setTimeout","handleLeave","clearTimeout","isActive","preSearchFilters","flat","postSearchFilters","useLinkProps","useRouter","activeProps","className","inactiveProps","style","onClick","onMouseEnter","onMouseLeave","onTouchStart","onTouchEnd","rest","linkInfo","composeHandlers","persist","resolvedActiveProps","resolvedInactiveProps","React","startTransition","role","Link","forwardRef","props","ref","linkProps","matchesContext","createContext","routerContext","EMPTY","__useStoreValue","seed","selector","valueRef","useRef","getValue","getSnapshot","useCallback","getStore","cb","useSyncExternalStore","foo","bar","baz","useContext","useMatches","useMatch","nearestMatch","strict","useRoute","resolvedRoute","useMatchRoute","Outlet","defaultPending","Inner","defaultComponent","PendingComponent","pendingComponent","defaultPendingComponent","errorComponent","defaultErrorComponent","Provider","Suspense","fallback","CatchBoundary","Component","info","componentDidCatch","setState","render","CatchBoundaryInner","errorState","activeErrorState","setActiveErrorState","useState","DefaultErrorBoundary","useEffect","prevKey","padding","maxWidth","fontSize","height","border","borderRadius","color","usePrompt","when","transition","confirm","_ref3","Fragment","_options2$window","_parsePath","_parsePath$pathname","_parsePath$search","_parsePath$hash","handlePop","_getIndexAndLocation4","_getIndexAndLocation6","querySelector","getAttribute","getBaseHref","_getIndexAndLocation7","_getHistoryStateAndUr3","_getHistoryStateAndUr4","memo","equals","importer","finalComp","lazy","select","defaultOpts"],"mappings":"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"}
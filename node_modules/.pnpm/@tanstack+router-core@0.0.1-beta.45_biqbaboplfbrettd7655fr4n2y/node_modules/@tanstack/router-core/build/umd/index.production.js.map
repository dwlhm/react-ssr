{"version":3,"file":"index.production.js","sources":["../../../../node_modules/.pnpm/@babel+runtime@7.20.6/node_modules/@babel/runtime/helpers/esm/extends.js","../../../../node_modules/.pnpm/history@5.3.0/node_modules/history/index.js","../../../../node_modules/.pnpm/tiny-invariant@1.3.1/node_modules/tiny-invariant/dist/esm/tiny-invariant.js","../../src/utils.ts","../../src/path.ts","../../src/qss.ts","../../../../node_modules/.pnpm/@solidjs+reactivity@0.0.6/node_modules/@solidjs/reactivity/dist/index.js","../../src/route.ts","../../src/routeConfig.ts","../../src/sharedClone.ts","../../src/routeMatch.ts","../../src/searchParams.ts","../../src/router.ts"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","export type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = Expand<{\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}>\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nexport function warning(cond: any, message: string): cond is true {\n  if (cond) {\n    if (typeof console !== 'undefined') console.warn(message)\n\n    try {\n      throw new Error(message)\n    } catch {}\n  }\n\n  return true\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult>,\n  previous: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n","import invariant from 'tiny-invariant'\nimport { AnyPathParams } from './routeConfig'\nimport { MatchLocation } from './router'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part.startsWith('*')) {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcard?: boolean,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.value === '*' && !leaveWildcard) {\n        return ''\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(currentLocation.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  if (!from.startsWith(basepath)) {\n    return undefined\n  }\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  const baseSegments = parsePathname(from)\n  const to = `${matchLocation.to ?? '*'}`\n  const routeSegments = parsePathname(to)\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastRouteSegment = i === routeSegments.length - 1\n      const isLastBaseSegment = i === baseSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n","// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  if (str.charAt(0) === '0') return str\n  return +str * 0 === 0 ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n","// src/core.ts\nvar CurrentReaction = void 0;\nvar CurrentGets = null;\nvar CurrentGetsIndex = 0;\nvar EffectQueue = null;\nvar CacheClean = 0;\nvar CacheCheck = 1;\nvar CacheDirty = 2;\nvar Root;\nvar Reactive = class {\n  value;\n  fn;\n  observers = null;\n  sources = null;\n  state;\n  effect;\n  cleanups = null;\n  alwaysUpdate = false;\n  constructor(fnOrValue, type) {\n    if (type != 0 /* Signal */) {\n      this.fn = fnOrValue;\n      this.value = void 0;\n      this.state = CacheDirty;\n      if (Root)\n        Root.push(this);\n      else\n        console.error(\"Memos and effects must be wrapped in a createRoot\");\n      this.effect = type == 2 /* Effect */;\n      if (this.effect)\n        this.update();\n    } else {\n      this.fn = void 0;\n      this.value = fnOrValue;\n      this.state = CacheClean;\n      this.effect = false;\n    }\n  }\n  get() {\n    if (CurrentReaction) {\n      if (!CurrentGets && CurrentReaction.sources && CurrentReaction.sources[CurrentGetsIndex] == this) {\n        CurrentGetsIndex++;\n      } else {\n        if (!CurrentGets)\n          CurrentGets = [this];\n        else\n          CurrentGets.push(this);\n      }\n    }\n    if (this.fn)\n      this.updateIfNecessary();\n    return this.value;\n  }\n  set(value) {\n    const notInBatch = !EffectQueue;\n    const newValue = typeof value === \"function\" ? value(this.value) : value;\n    if ((this.value !== newValue || this.alwaysUpdate) && this.observers) {\n      for (let i = 0; i < this.observers.length; i++) {\n        this.observers[i].stale(CacheDirty);\n      }\n    }\n    this.value = newValue;\n    if (notInBatch)\n      stabilize();\n    return newValue;\n  }\n  stale(state) {\n    if (this.state < state) {\n      if (this.state === CacheClean && this.effect) {\n        if (EffectQueue)\n          EffectQueue.push(this);\n        else\n          EffectQueue = [this];\n      }\n      this.state = state;\n      if (this.observers) {\n        for (let i = 0; i < this.observers.length; i++) {\n          this.observers[i].stale(CacheCheck);\n        }\n      }\n    }\n  }\n  update() {\n    const oldValue = this.value;\n    const prevReaction = CurrentReaction;\n    const prevGets = CurrentGets;\n    const prevIndex = CurrentGetsIndex;\n    CurrentReaction = this;\n    CurrentGets = null;\n    CurrentGetsIndex = 0;\n    try {\n      if (this.cleanups) {\n        this.cleanups.forEach((c) => c());\n        this.cleanups = null;\n      }\n      this.value = this.fn();\n      if (CurrentGets) {\n        this.removeParentObservers(CurrentGetsIndex);\n        if (this.sources && CurrentGetsIndex > 0) {\n          this.sources.length = CurrentGetsIndex + CurrentGets.length;\n          for (let i = 0; i < CurrentGets.length; i++) {\n            this.sources[CurrentGetsIndex + i] = CurrentGets[i];\n          }\n        } else {\n          this.sources = CurrentGets;\n        }\n        for (let i = CurrentGetsIndex; i < this.sources.length; i++) {\n          const source = this.sources[i];\n          if (!source.observers) {\n            source.observers = [this];\n          } else {\n            source.observers.push(this);\n          }\n        }\n      } else if (this.sources && CurrentGetsIndex < this.sources.length) {\n        this.removeParentObservers(CurrentGetsIndex);\n        this.sources.length = CurrentGetsIndex;\n      }\n    } finally {\n      CurrentGets = prevGets;\n      CurrentReaction = prevReaction;\n      CurrentGetsIndex = prevIndex;\n    }\n    if ((oldValue !== this.value || this.alwaysUpdate) && this.observers) {\n      for (let i = 0; i < this.observers.length; i++) {\n        this.observers[i].state = CacheDirty;\n      }\n    }\n    this.state = CacheClean;\n  }\n  updateIfNecessary() {\n    if (this.state === CacheCheck) {\n      for (const source of this.sources) {\n        source.updateIfNecessary();\n        if (this.state === CacheDirty) {\n          break;\n        }\n      }\n    }\n    if (this.state === CacheDirty) {\n      this.update();\n    }\n    this.state = CacheClean;\n  }\n  removeParentObservers(index) {\n    if (!this.sources)\n      return;\n    for (let i = index; i < this.sources.length; i++) {\n      const source = this.sources[i];\n      const swap = source.observers.findIndex((v) => v === this);\n      source.observers[swap] = source.observers[source.observers.length - 1];\n      source.observers.pop();\n    }\n  }\n  destroy() {\n    if (this.cleanups) {\n      this.cleanups.forEach((c) => c());\n      this.cleanups = null;\n    }\n    this.removeParentObservers(0);\n  }\n};\nfunction onCleanup(fn) {\n  if (CurrentReaction) {\n    if (!CurrentReaction.cleanups)\n      CurrentReaction.cleanups = [fn];\n    else\n      CurrentReaction.cleanups.push(fn);\n  } else {\n    console.error(\"onCleanup must be called from within a memo or effect\");\n  }\n}\nfunction stabilize() {\n  if (!EffectQueue)\n    return;\n  for (let i = 0; i < EffectQueue.length; i++) {\n    EffectQueue[i].get();\n  }\n  EffectQueue = null;\n}\nfunction createSignal(value, options) {\n  const signal = new Reactive(value, 0 /* Signal */);\n  if (options?.equals !== void 0)\n    signal.alwaysUpdate = true;\n  return [signal.get.bind(signal), signal.set.bind(signal)];\n}\nfunction createMemo(fn) {\n  const memo = new Reactive(fn, 1 /* Memo */);\n  return memo.get.bind(memo);\n}\nfunction createEffect(fn) {\n  const effect = new Reactive(fn, 2 /* Effect */);\n  return effect.get.bind(effect);\n}\nfunction createRoot(fn) {\n  let root = [];\n  Root = root;\n  fn();\n  Root = null;\n  return () => {\n    if (!root)\n      return;\n    root.forEach((r) => r.destroy());\n    root = null;\n  };\n}\nfunction batch(fn) {\n  EffectQueue = [];\n  let out = fn();\n  stabilize();\n  return out;\n}\nfunction untrack(fn) {\n  const listener = CurrentReaction;\n  CurrentReaction = void 0;\n  try {\n    return fn();\n  } finally {\n    CurrentReaction = listener;\n  }\n}\n\n// src/store.ts\nvar $RAW = Symbol(\"store-raw\");\nvar $TRACK = Symbol(\"track\");\nvar $PROXY = Symbol(\"store-proxy\");\nvar $NODE = Symbol(\"store-node\");\nfunction wrap(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value);\n      const desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          const get = desc[prop].get.bind(p);\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = /* @__PURE__ */ new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW])\n    return result;\n  if (!isWrappable(item) || set.has(item))\n    return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item))\n      item = item.slice(0);\n    else\n      set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v)\n        item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item))\n      item = Object.assign({}, item);\n    else\n      set.add(item);\n    const keys = Object.keys(item);\n    const desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get)\n        continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v)\n        item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes)\n    Object.defineProperty(target, $NODE, { value: nodes = {} });\n  return nodes;\n}\nfunction getDataNode(nodes, property, value) {\n  return nodes[property] || (nodes[property] = createDataNode(value));\n}\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  if (CurrentReaction) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode())).get();\n  }\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nfunction createDataNode(value) {\n  const s = new Reactive(value, 0);\n  s.alwaysUpdate = true;\n  return s;\n}\nvar Writing = false;\nvar proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW)\n      return target;\n    if (property === $PROXY)\n      return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getDataNodes(target);\n    const tracked = nodes.hasOwnProperty(property);\n    let value = tracked ? nodes[property].get() : target[property];\n    if (property === $NODE || property === \"__proto__\")\n      return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (CurrentReaction && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get))\n        value = getDataNode(nodes, property, value).get();\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === \"__proto__\")\n      return true;\n    this.get(target, property, target);\n    return property in target;\n  },\n  set(target, property, value) {\n    Writing && setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    Writing && setProperty(target, property, void 0, true);\n    return true;\n  },\n  ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value)\n    return;\n  const prev = state[property];\n  const len = state.length;\n  if (deleting)\n    delete state[property];\n  else\n    state[property] = value;\n  const nodes = getDataNodes(state);\n  let node;\n  if (node = getDataNode(nodes, property, prev))\n    node.set(() => value);\n  if (Array.isArray(state) && state.length !== len)\n    (node = getDataNode(nodes, \"length\", len)) && node.set(state.length);\n  (node = nodes._) && node.set();\n}\nfunction createStore(store) {\n  const unwrappedStore = unwrap(store);\n  const wrappedStore = wrap(unwrappedStore);\n  const setStore = (fn) => {\n    batch(() => {\n      try {\n        Writing = true;\n        fn(wrappedStore);\n      } finally {\n        Writing = false;\n      }\n    });\n  };\n  return [wrappedStore, setStore];\n}\nexport {\n  batch,\n  createEffect,\n  createMemo,\n  createRoot,\n  createSignal,\n  createStore,\n  isWrappable,\n  onCleanup,\n  untrack,\n  unwrap\n};\n","import {\n  CheckRelativePath,\n  LinkInfo,\n  LinkOptions,\n  ResolveRelativePath,\n  ToOptions,\n} from './link'\nimport { LoaderContext, RouteConfig, RouteOptions } from './routeConfig'\nimport {\n  AnyAllRouteInfo,\n  AnyRouteInfo,\n  DefaultAllRouteInfo,\n  RouteInfo,\n  RouteInfoByPath,\n} from './routeInfo'\nimport {\n  Action,\n  ActionState,\n  Loader,\n  LoaderState,\n  MatchRouteOptions,\n  Router,\n} from './router'\nimport { NoInfer } from './utils'\nimport { createStore } from '@solidjs/reactivity'\n\nexport interface AnyRoute extends Route<any, any, any> {}\n\nexport interface Route<\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouteInfo extends AnyRouteInfo = RouteInfo,\n  TRouterContext = unknown,\n> {\n  routeInfo: TRouteInfo\n  routeId: TRouteInfo['id']\n  routeRouteId: TRouteInfo['routeId']\n  routePath: TRouteInfo['path']\n  fullPath: TRouteInfo['fullPath']\n  parentRoute?: AnyRoute\n  childRoutes?: AnyRoute[]\n  options: RouteOptions\n  originalIndex: number\n  router: Router<TAllRouteInfo['routeConfig'], TAllRouteInfo, TRouterContext>\n  action: unknown extends TRouteInfo['actionResponse']\n    ?\n        | Action<TRouteInfo['actionPayload'], TRouteInfo['actionResponse']>\n        | undefined\n    : Action<TRouteInfo['actionPayload'], TRouteInfo['actionResponse']>\n  loader: unknown extends TRouteInfo['routeLoaderData']\n    ?\n        | Action<\n            LoaderContext<\n              TRouteInfo['fullSearchSchema'],\n              TRouteInfo['allParams']\n            >,\n            TRouteInfo['routeLoaderData']\n          >\n        | undefined\n    : Loader<\n        TRouteInfo['fullSearchSchema'],\n        TRouteInfo['allParams'],\n        TRouteInfo['routeLoaderData']\n      >\n  // buildLink: <TTo extends string = '.'>(\n  //   options: Omit<\n  //     LinkOptions<TAllRouteInfo, TRouteInfo['fullPath'], TTo>,\n  //     'from'\n  //   >,\n  // ) => LinkInfo\n  // matchRoute: <\n  //   TTo extends string = '.',\n  //   TResolved extends string = ResolveRelativePath<TRouteInfo['id'], TTo>,\n  // >(\n  //   matchLocation: CheckRelativePath<\n  //     TAllRouteInfo,\n  //     TRouteInfo['fullPath'],\n  //     NoInfer<TTo>\n  //   > &\n  //     Omit<ToOptions<TAllRouteInfo, TRouteInfo['fullPath'], TTo>, 'from'>,\n  //   opts?: MatchRouteOptions,\n  // ) => RouteInfoByPath<TAllRouteInfo, TResolved>['allParams']\n  // navigate: <TTo extends string = '.'>(\n  //   options: Omit<\n  //     LinkOptions<TAllRouteInfo, TRouteInfo['fullPath'], TTo>,\n  //     'from'\n  //   >,\n  // ) => Promise<void>\n}\n\nexport function createRoute<\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouteInfo extends AnyRouteInfo = RouteInfo,\n  TRouterContext = unknown,\n>(\n  routeConfig: RouteConfig,\n  options: TRouteInfo['options'],\n  originalIndex: number,\n  parent: undefined | Route<TAllRouteInfo, any>,\n  router: Router<TAllRouteInfo['routeConfig'], TAllRouteInfo, TRouterContext>,\n): Route<TAllRouteInfo, TRouteInfo, TRouterContext> {\n  const { id, routeId, path: routePath, fullPath } = routeConfig\n\n  let route: Route<TAllRouteInfo, TRouteInfo, TRouterContext> = {\n    routeInfo: undefined!,\n    routeId: id,\n    routeRouteId: routeId,\n    originalIndex,\n    routePath,\n    fullPath,\n    options,\n    router,\n    childRoutes: undefined!,\n    parentRoute: parent,\n    get action() {\n      let action =\n        router.store.actions[id] ||\n        (() => {\n          router.setStore((s) => {\n            s.actions[id] = {\n              submissions: [],\n              submit: async <T, U>(\n                submission: T,\n                actionOpts?: { invalidate?: boolean; multi?: boolean },\n              ) => {\n                if (!route) {\n                  return\n                }\n\n                const invalidate = actionOpts?.invalidate ?? true\n\n                const [actionStore, setActionStore] = createStore<\n                  ActionState<T, U>\n                >({\n                  submittedAt: Date.now(),\n                  status: 'pending',\n                  submission,\n                  isMulti: !!actionOpts?.multi,\n                })\n\n                router.setStore((s) => {\n                  if (!actionOpts?.multi) {\n                    s.actions[id]!.submissions = action.submissions.filter(\n                      (d) => d.isMulti,\n                    )\n                  }\n\n                  s.actions[id]!.current = actionStore\n                  s.actions[id]!.latest = actionStore\n                  s.actions[id]!.submissions.push(actionStore)\n                })\n\n                try {\n                  const res = await route.options.action?.(submission)\n\n                  setActionStore((s) => {\n                    s.data = res as U\n                  })\n\n                  if (invalidate) {\n                    router.invalidateRoute({ to: '.', fromCurrent: true })\n                    await router.reload()\n                  }\n\n                  setActionStore((s) => {\n                    s.status = 'success'\n                  })\n\n                  return res\n                } catch (err) {\n                  console.error(err)\n                  setActionStore((s) => {\n                    s.error = err\n                    s.status = 'error'\n                  })\n                }\n              },\n            }\n          })\n\n          return router.store.actions[id]!\n        })()\n\n      return action\n    },\n    get loader() {\n      let loader =\n        router.store.loaders[id] ||\n        (() => {\n          router.setStore((s) => {\n            s.loaders[id] = {\n              pending: [],\n              fetch: (async (loaderContext: LoaderContext<any, any>) => {\n                if (!route) {\n                  return\n                }\n\n                const loaderState: LoaderState<any, any> = {\n                  loadedAt: Date.now(),\n                  loaderContext,\n                }\n\n                router.setStore((s) => {\n                  s.loaders[id]!.current = loaderState\n                  s.loaders[id]!.latest = loaderState\n                  s.loaders[id]!.pending.push(loaderState)\n                })\n\n                try {\n                  return await route.options.loader?.(loaderContext)\n                } finally {\n                  router.setStore((s) => {\n                    s.loaders[id]!.pending = s.loaders[id]!.pending.filter(\n                      (d) => d !== loaderState,\n                    )\n                  })\n                }\n              }) as any,\n            }\n          })\n\n          return router.store.loaders[id]!\n        })()\n\n      return loader as any\n    },\n\n    // buildLink: (options) => {\n    //   return router.buildLink({\n    //     ...options,\n    //     from: fullPath,\n    //   } as any) as any\n    // },\n\n    // navigate: (options) => {\n    //   return router.navigate({\n    //     ...options,\n    //     from: fullPath,\n    //   } as any) as any\n    // },\n\n    // matchRoute: (matchLocation, opts) => {\n    //   return router.matchRoute(\n    //     {\n    //       ...matchLocation,\n    //       from: fullPath,\n    //     } as any,\n    //     opts,\n    //   ) as any\n    // },\n  }\n\n  router.options.createRoute?.({ router, route })\n\n  return route\n}\n","import invariant from 'tiny-invariant'\nimport { GetFrameworkGeneric } from './frameworks'\nimport { ParsePathParams } from './link'\nimport { joinPaths, trimPath, trimPathRight } from './path'\nimport { RouteInfo } from './routeInfo'\nimport { RouteMatch } from './routeMatch'\nimport { RegisteredRouter, Router } from './router'\nimport { Expand, IsAny, NoInfer, PickUnsafe } from './utils'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\n\nexport type AnyLoaderData = {}\nexport type AnyPathParams = {}\nexport type AnySearchSchema = {}\nexport interface RouteMeta {}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn, TParentSchema> =\n  | SearchSchemaValidatorObj<TReturn, TParentSchema>\n  | SearchSchemaValidatorFn<TReturn, TParentSchema>\n\nexport type SearchSchemaValidatorObj<TReturn, TParentSchema> = {\n  parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>\n}\n\nexport type SearchSchemaValidatorFn<TReturn, TParentSchema> = (\n  searchObj: Record<string, unknown>,\n) => {} extends TParentSchema\n  ? TReturn\n  : keyof TReturn extends keyof TParentSchema\n  ? {\n      error: 'Top level search params cannot be redefined by child routes!'\n      keys: keyof TReturn & keyof TParentSchema\n    }\n  : TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type LoaderFn<\n  TRouteLoaderData extends AnyLoaderData = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams extends AnyPathParams = {},\n> = (\n  loaderContext: LoaderContext<TFullSearchSchema, TAllParams>,\n) => TRouteLoaderData | Promise<TRouteLoaderData>\n\nexport interface LoaderContext<\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams extends AnyPathParams = {},\n> {\n  params: TAllParams\n  search: TFullSearchSchema\n  signal?: AbortSignal\n  // parentLoaderPromise?: Promise<TParentRouteLoaderData>\n}\n\nexport type ActionFn<TActionPayload = unknown, TActionResponse = unknown> = (\n  submission: TActionPayload,\n) => TActionResponse | Promise<TActionResponse>\n\nexport type UnloaderFn<TPath extends string> = (\n  routeMatch: RouteMatch<any, RouteInfo<string, TPath>>,\n) => void\n\nexport type RouteOptions<\n  TRouteId extends string = string,\n  TPath extends string = string,\n  TParentRouteLoaderData extends AnyLoaderData = {},\n  TRouteLoaderData extends AnyLoaderData = {},\n  TParentLoaderData extends AnyLoaderData = {},\n  TLoaderData extends AnyLoaderData = {},\n  TActionPayload = unknown,\n  TActionResponse = unknown,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = TSearchSchema,\n  TParentParams extends AnyPathParams = {},\n  TParams extends Record<ParsePathParams<TPath>, unknown> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends AnyPathParams = {},\n> = (\n  | {\n      // The path to match (relative to the nearest parent `Route` component or root basepath)\n      path: TPath\n    }\n  | {\n      id: TRouteId\n    }\n) & {\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: GetFrameworkGeneric<'Component'> // , NoInfer<TParentLoaderData>>\n  // The content to be rendered when the route encounters an error\n  errorComponent?: GetFrameworkGeneric<'ErrorComponent'> // , NoInfer<TParentLoaderData>>\n  // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n  pendingComponent?: GetFrameworkGeneric<'Component'> //, NoInfer<TParentLoaderData>>\n  // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n  loader?: LoaderFn<TRouteLoaderData, TFullSearchSchema, TAllParams>\n  // The max age to consider loader data fresh (not-stale) for this route in milliseconds from the time of fetch\n  // Defaults to 0. Only stale loader data is refetched.\n  loaderMaxAge?: number\n  // The max age to cache the loader data for this route in milliseconds from the time of route inactivity\n  // before it is garbage collected.\n  loaderGcMaxAge?: number\n  // An asynchronous function made available to the route for performing asynchronous or mutative actions that\n  // might invalidate the route's data.\n  action?: ActionFn<TActionPayload, TActionResponse>\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onLoadError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: (opts: {\n    router: Router<any, any, unknown>\n    match: RouteMatch\n  }) => Promise<void> | void\n  // This function will be called if the route's loader throws an error **during an attempted navigation**.\n  // If you want to redirect due to an error, call `router.navigate()` from within this function.\n  onLoadError?: (err: any) => void\n  // This function is called\n  // when moving from an inactive state to an active one. Likewise, when moving from\n  // an active to an inactive state, the return function (if provided) is called.\n  onLoaded?: (matchContext: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) =>\n    | void\n    | undefined\n    | ((match: { params: TAllParams; search: TFullSearchSchema }) => void)\n  // This function is called when the route remains active from one transition to the next.\n  onTransition?: (match: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) => void\n  // An object of whatever you want! This object is accessible anywhere matches are.\n  meta?: RouteMeta // TODO: Make this nested and mergeable\n} & (\n    | {\n        parseParams?: never\n        stringifyParams?: never\n      }\n    | {\n        // Parse params optionally receives path params as strings and returns them in a parsed format (like a number or boolean)\n        parseParams: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams\n        stringifyParams: (\n          params: TParams,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n  ) &\n  (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never // Detect if an existing path param is being redefined\n    ? {}\n    : 'Cannot redefined path params in child routes!')\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport interface RouteConfig<\n  TId extends string = string,\n  TRouteId extends string = string,\n  TPath extends string = string,\n  TFullPath extends string = string,\n  TParentRouteLoaderData extends AnyLoaderData = AnyLoaderData,\n  TRouteLoaderData extends AnyLoaderData = AnyLoaderData,\n  TParentLoaderData extends AnyLoaderData = {},\n  TLoaderData extends AnyLoaderData = AnyLoaderData,\n  TActionPayload = unknown,\n  TActionResponse = unknown,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TParentParams extends AnyPathParams = {},\n  TParams extends AnyPathParams = {},\n  TAllParams extends AnyPathParams = {},\n  TKnownChildren = unknown,\n> {\n  id: TId\n  routeId: TRouteId\n  path: NoInfer<TPath>\n  fullPath: TFullPath\n  options: RouteOptions<\n    TRouteId,\n    TPath,\n    TParentRouteLoaderData,\n    TRouteLoaderData,\n    TParentLoaderData,\n    TLoaderData,\n    TActionPayload,\n    TActionResponse,\n    TParentSearchSchema,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParentParams,\n    TParams,\n    TAllParams\n  >\n  children?: TKnownChildren\n  addChildren: IsAny<\n    TId,\n    any,\n    <TNewChildren extends any>(\n      children: TNewChildren extends AnyRouteConfig[]\n        ? TNewChildren\n        : { error: 'Invalid route detected'; route: TNewChildren },\n    ) => RouteConfig<\n      TId,\n      TRouteId,\n      TPath,\n      TFullPath,\n      TParentRouteLoaderData,\n      TRouteLoaderData,\n      TParentLoaderData,\n      TLoaderData,\n      TActionPayload,\n      TActionResponse,\n      TParentSearchSchema,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentParams,\n      TParams,\n      TAllParams,\n      TNewChildren\n    >\n  >\n  createRoute: CreateRouteConfigFn<\n    false,\n    TId,\n    TFullPath,\n    TRouteLoaderData,\n    TLoaderData,\n    TFullSearchSchema,\n    TAllParams\n  >\n  generate: GenerateFn<\n    TRouteId,\n    TPath,\n    TParentRouteLoaderData,\n    TParentLoaderData,\n    TParentSearchSchema,\n    TParentParams\n  >\n}\n\ntype GenerateFn<\n  TRouteId extends string = string,\n  TPath extends string = string,\n  TParentRouteLoaderData extends AnyLoaderData = AnyLoaderData,\n  TParentLoaderData extends AnyLoaderData = {},\n  TParentSearchSchema extends {} = {},\n  TParentParams extends AnyPathParams = {},\n> = <\n  TRouteLoaderData extends AnyLoaderData = AnyLoaderData,\n  TActionPayload = unknown,\n  TActionResponse = unknown,\n  TSearchSchema extends AnySearchSchema = {},\n  TParams extends Record<ParsePathParams<TPath>, unknown> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams> = AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams>,\n>(\n  options: Omit<\n    RouteOptions<\n      TRouteId,\n      TPath,\n      TParentRouteLoaderData,\n      TRouteLoaderData,\n      TParentLoaderData,\n      Expand<TParentLoaderData & NoInfer<TRouteLoaderData>>,\n      TActionPayload,\n      TActionResponse,\n      TParentSearchSchema,\n      TSearchSchema,\n      Expand<TParentSearchSchema & TSearchSchema>,\n      TParentParams,\n      TParams,\n      Expand<TParentParams & TAllParams>\n    >,\n    'path'\n  >,\n) => void\n\ntype CreateRouteConfigFn<\n  TIsRoot extends boolean = false,\n  TParentId extends string = string,\n  TParentPath extends string = string,\n  TParentRouteLoaderData extends AnyLoaderData = {},\n  TParentLoaderData extends AnyLoaderData = {},\n  TParentSearchSchema extends AnySearchSchema = {},\n  TParentParams extends AnyPathParams = {},\n> = <\n  TRouteId extends string,\n  TPath extends string,\n  TRouteLoaderData extends AnyLoaderData,\n  TActionPayload,\n  TActionResponse,\n  TSearchSchema extends AnySearchSchema = AnySearchSchema,\n  TParams extends Record<ParsePathParams<TPath>, unknown> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams> = AnyPathParams extends TParams\n    ? Record<ParsePathParams<TPath>, string>\n    : NoInfer<TParams>,\n  TKnownChildren extends RouteConfig[] = RouteConfig[],\n  TResolvedId extends string = string extends TRouteId\n    ? string extends TPath\n      ? string\n      : TPath\n    : TRouteId,\n>(\n  options?: TIsRoot extends true\n    ? Omit<\n        RouteOptions<\n          TRouteId,\n          TPath,\n          TParentRouteLoaderData,\n          TRouteLoaderData,\n          TParentLoaderData,\n          Expand<TParentLoaderData & NoInfer<TRouteLoaderData>>,\n          TActionPayload,\n          TActionResponse,\n          TParentSearchSchema,\n          TSearchSchema,\n          Expand<TParentSearchSchema & TSearchSchema>,\n          TParentParams,\n          TParams,\n          Expand<TParentParams & TAllParams>\n        >,\n        'path'\n      > & { path?: never }\n    : RouteOptions<\n        TRouteId,\n        TPath,\n        TParentRouteLoaderData,\n        TRouteLoaderData,\n        TParentLoaderData,\n        Expand<TParentLoaderData & NoInfer<TRouteLoaderData>>,\n        TActionPayload,\n        TActionResponse,\n        TParentSearchSchema,\n        TSearchSchema,\n        Expand<TParentSearchSchema & TSearchSchema>,\n        TParentParams,\n        TParams,\n        Expand<TParentParams & TAllParams>\n      >,\n  children?: TKnownChildren,\n  isRoot?: boolean,\n  parentId?: string,\n  parentPath?: string,\n) => RouteConfig<\n  RoutePrefix<TParentId, TResolvedId>,\n  TResolvedId,\n  TPath,\n  string extends TPath ? '' : RoutePath<RoutePrefix<TParentPath, TPath>>,\n  TParentRouteLoaderData,\n  TRouteLoaderData,\n  TParentLoaderData,\n  Expand<TParentLoaderData & NoInfer<TRouteLoaderData>>,\n  TActionPayload,\n  TActionResponse,\n  TParentSearchSchema,\n  TSearchSchema,\n  Expand<TParentSearchSchema & TSearchSchema>,\n  TParentParams,\n  TParams,\n  Expand<TParentParams & TAllParams>,\n  TKnownChildren\n>\n\ntype RoutePath<T extends string> = T extends RootRouteId\n  ? '/'\n  : TrimPathRight<`${T}`>\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TId extends string,\n> = string extends TId\n  ? RootRouteId\n  : TId extends string\n  ? `${TPrefix}/${TId}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TId>}`>}`\n  : never\n\nexport interface AnyRouteConfig\n  extends RouteConfig<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport interface AnyRouteConfigWithChildren<TChildren>\n  extends RouteConfig<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    TChildren\n  > {}\n\ntype TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\ntype TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}`\n  ? TrimPathLeft<U>\n  : T extends `/${infer U}`\n  ? TrimPathLeft<U>\n  : T\ntype TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\nexport const createRouteConfig: CreateRouteConfigFn<true> = (\n  options = {} as any,\n  children,\n  isRoot = true,\n  parentId,\n  parentPath,\n) => {\n  if (isRoot) {\n    ;(options as any).path = rootRouteId\n  }\n\n  // Strip the root from parentIds\n  if (parentId === rootRouteId) {\n    parentId = ''\n  }\n\n  let path: undefined | string = isRoot ? rootRouteId : options.path\n\n  // If the path is anything other than an index path, trim it up\n  if (path && path !== '/') {\n    path = trimPath(path)\n  }\n\n  const routeId = path || (options as { id?: string }).id\n\n  let id = joinPaths([parentId, routeId])\n\n  if (path === rootRouteId) {\n    path = '/'\n  }\n\n  if (id !== rootRouteId) {\n    id = joinPaths(['/', id])\n  }\n\n  const fullPath =\n    id === rootRouteId ? '/' : trimPathRight(joinPaths([parentPath, path]))\n\n  return {\n    id: id as any,\n    routeId: routeId as any,\n    path: path as any,\n    fullPath: fullPath as any,\n    options: options as any,\n    children,\n    addChildren: (children: any) =>\n      createRouteConfig(options, children, false, parentId, parentPath),\n    createRoute: (childOptions: any) =>\n      createRouteConfig(childOptions, undefined, false, id, fullPath) as any,\n    generate: () => {\n      invariant(\n        false,\n        `routeConfig.generate() is used by TanStack Router's file-based routing code generation and should not actually be called during runtime. `,\n      )\n    },\n  }\n}\n","/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function sharedClone<T>(prev: any, next: T, touchAll?: boolean): T {\n  const things = new Map()\n\n  function recurse(prev: any, next: any) {\n    if (prev === next) {\n      return prev\n    }\n\n    if (things.has(next)) {\n      return things.get(next)\n    }\n\n    const prevIsArray = Array.isArray(prev)\n    const nextIsArray = Array.isArray(next)\n    const prevIsObj = isPlainObject(prev)\n    const nextIsObj = isPlainObject(next)\n\n    const isArray = prevIsArray && nextIsArray\n    const isObj = prevIsObj && nextIsObj\n\n    const isSameStructure = isArray || isObj\n\n    // Both are arrays or objects\n    if (isSameStructure) {\n      const aSize = isArray ? prev.length : Object.keys(prev).length\n      const bItems = isArray ? next : Object.keys(next)\n      const bSize = bItems.length\n      const copy: any = isArray ? [] : {}\n\n      let equalItems = 0\n\n      for (let i = 0; i < bSize; i++) {\n        const key = isArray ? i : bItems[i]\n        if (copy[key] === prev[key]) {\n          equalItems++\n        }\n      }\n      if (aSize === bSize && equalItems === aSize) {\n        things.set(next, prev)\n        return prev\n      }\n      things.set(next, copy)\n      for (let i = 0; i < bSize; i++) {\n        const key = isArray ? i : bItems[i]\n        if (typeof bItems[i] === 'function') {\n          copy[key] = prev[key]\n        } else {\n          copy[key] = recurse(prev[key], next[key])\n        }\n        if (copy[key] === prev[key]) {\n          equalItems++\n        }\n      }\n\n      return copy\n    }\n\n    if (nextIsArray) {\n      const copy: any[] = []\n      things.set(next, copy)\n      for (let i = 0; i < next.length; i++) {\n        copy[i] = recurse(undefined, next[i])\n      }\n      return copy as T\n    }\n\n    if (nextIsObj) {\n      const copy = {} as any\n      things.set(next, copy)\n      const nextKeys = Object.keys(next)\n      for (let i = 0; i < nextKeys.length; i++) {\n        const key = nextKeys[i]!\n        copy[key] = recurse(undefined, next[key])\n      }\n      return copy as T\n    }\n\n    return next\n  }\n\n  return recurse(prev, next)\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n","import { boolean } from 'zod'\nimport { GetFrameworkGeneric } from './frameworks'\nimport { Route } from './route'\nimport {\n  AnyAllRouteInfo,\n  AnyRouteInfo,\n  DefaultAllRouteInfo,\n  RouteInfo,\n} from './routeInfo'\nimport { Router } from './router'\nimport { batch, createStore } from '@solidjs/reactivity'\nimport { Expand } from './utils'\nimport { sharedClone } from './sharedClone'\n\nexport interface RouteMatchStore<\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouteInfo extends AnyRouteInfo = RouteInfo,\n> {\n  parentMatch?: RouteMatch\n  routeSearch: TRouteInfo['searchSchema']\n  search: Expand<\n    TAllRouteInfo['fullSearchSchema'] & TRouteInfo['fullSearchSchema']\n  >\n  status: 'idle' | 'loading' | 'success' | 'error'\n  updatedAt?: number\n  error?: unknown\n  invalid: boolean\n  isInvalid: boolean\n  loaderData: TRouteInfo['loaderData']\n  routeLoaderData: TRouteInfo['routeLoaderData']\n  isFetching: boolean\n  invalidAt: number\n}\n\nexport interface RouteMatch<\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouteInfo extends AnyRouteInfo = RouteInfo,\n> extends Route<TAllRouteInfo, TRouteInfo> {\n  store: RouteMatchStore<TAllRouteInfo, TRouteInfo>\n  // setStore: WritableStore<RouteMatchStore<TAllRouteInfo, TRouteInfo>>\n  matchId: string\n  pathname: string\n  params: TRouteInfo['allParams']\n  childMatches: RouteMatch[]\n  cancel: () => void\n  load: (\n    loaderOpts?:\n      | { preload: true; maxAge: number; gcMaxAge: number }\n      | { preload?: false; maxAge?: never; gcMaxAge?: never },\n  ) => Promise<TRouteInfo['routeLoaderData']>\n  fetch: (opts?: { maxAge?: number }) => Promise<TRouteInfo['routeLoaderData']>\n  invalidate: () => void\n  hasLoaders: () => boolean\n  __: {\n    setParentMatch: (parentMatch?: RouteMatch) => void\n    component?: GetFrameworkGeneric<'Component'>\n    errorComponent?: GetFrameworkGeneric<'ErrorComponent'>\n    pendingComponent?: GetFrameworkGeneric<'Component'>\n    loadPromise?: Promise<void>\n    onExit?:\n      | void\n      | ((matchContext: {\n          params: TRouteInfo['allParams']\n          search: TRouteInfo['fullSearchSchema']\n        }) => void)\n    abortController: AbortController\n    validate: () => void\n  }\n}\n\nconst componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport function createRouteMatch<\n  TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo,\n  TRouteInfo extends AnyRouteInfo = RouteInfo,\n>(\n  router: Router<any, any, any>,\n  route: Route<TAllRouteInfo, TRouteInfo>,\n  opts: {\n    parentMatch?: RouteMatch<any, any>\n    matchId: string\n    params: TRouteInfo['allParams']\n    pathname: string\n  },\n): RouteMatch<TAllRouteInfo, TRouteInfo> {\n  let componentsPromise: Promise<void>\n  let dataPromise: Promise<TRouteInfo['routeLoaderData']>\n  let latestId = ''\n  let resolve = () => {}\n\n  function setLoaderData(loaderData: TRouteInfo['routeLoaderData']) {\n    batch(() => {\n      setStore((s) => {\n        s.routeLoaderData = sharedClone(s.routeLoaderData, loaderData)\n      })\n      updateLoaderData()\n    })\n  }\n\n  function updateLoaderData() {\n    setStore((s) => {\n      s.loaderData = sharedClone(s.loaderData, {\n        ...store.parentMatch?.store.loaderData,\n        ...s.routeLoaderData,\n      }) as TRouteInfo['loaderData']\n    })\n  }\n\n  const [store, setStore] = createStore<\n    RouteMatchStore<TAllRouteInfo, TRouteInfo>\n  >({\n    routeSearch: {},\n    search: {} as any,\n    status: 'idle',\n    routeLoaderData: {} as TRouteInfo['routeLoaderData'],\n    loaderData: {} as TRouteInfo['loaderData'],\n    isFetching: false,\n    invalid: false,\n    invalidAt: Infinity,\n    get isInvalid(): boolean {\n      const now = Date.now()\n      return this.invalid || this.invalidAt < now\n    },\n  })\n\n  const routeMatch: RouteMatch<TAllRouteInfo, TRouteInfo> = {\n    ...route,\n    ...opts,\n    store,\n    // setStore,\n    router,\n    childMatches: [],\n    __: {\n      setParentMatch: (parentMatch?: RouteMatch) => {\n        batch(() => {\n          setStore((s) => {\n            s.parentMatch = parentMatch\n          })\n\n          updateLoaderData()\n        })\n      },\n      abortController: new AbortController(),\n      validate: () => {\n        // Validate the search params and stabilize them\n        const parentSearch =\n          store.parentMatch?.store.search ?? router.store.currentLocation.search\n\n        try {\n          const prevSearch = store.routeSearch\n\n          const validator =\n            typeof routeMatch.options.validateSearch === 'object'\n              ? routeMatch.options.validateSearch.parse\n              : routeMatch.options.validateSearch\n\n          let nextSearch = sharedClone(\n            prevSearch,\n            validator?.(parentSearch) ?? {},\n          )\n\n          batch(() => {\n            // Invalidate route matches when search param stability changes\n            if (prevSearch !== nextSearch) {\n              setStore((s) => (s.invalid = true))\n            }\n\n            // TODO: Alright, do we need batch() here?\n            setStore((s) => {\n              s.routeSearch = nextSearch\n              s.search = sharedClone(parentSearch, {\n                ...parentSearch,\n                ...nextSearch,\n              })\n            })\n          })\n\n          componentTypes.map(async (type) => {\n            const component = routeMatch.options[type]\n\n            if (typeof routeMatch.__[type] !== 'function') {\n              routeMatch.__[type] = component\n            }\n          })\n        } catch (err: any) {\n          console.error(err)\n          const error = new (Error as any)('Invalid search params found', {\n            cause: err,\n          })\n          error.code = 'INVALID_SEARCH_PARAMS'\n\n          setStore((s) => {\n            s.status = 'error'\n            s.error = error\n          })\n\n          // Do not proceed with loading the route\n          return\n        }\n      },\n    },\n    cancel: () => {\n      routeMatch.__.abortController?.abort()\n    },\n    invalidate: () => {\n      setStore((s) => (s.invalid = true))\n    },\n    hasLoaders: () => {\n      return !!(\n        route.options.loader ||\n        componentTypes.some((d) => route.options[d]?.preload)\n      )\n    },\n    load: async (loaderOpts) => {\n      const now = Date.now()\n      const minMaxAge = loaderOpts?.preload\n        ? Math.max(loaderOpts?.maxAge, loaderOpts?.gcMaxAge)\n        : 0\n\n      // If this is a preload, add it to the preload cache\n      if (loaderOpts?.preload && minMaxAge > 0) {\n        // If the match is currently active, don't preload it\n        if (\n          router.store.currentMatches.find(\n            (d) => d.matchId === routeMatch.matchId,\n          )\n        ) {\n          return\n        }\n\n        router.store.matchCache[routeMatch.matchId] = {\n          gc: now + loaderOpts.gcMaxAge,\n          match: routeMatch as RouteMatch<any, any>,\n        }\n      }\n\n      // If the match is invalid, errored or idle, trigger it to load\n      if (\n        (store.status === 'success' && store.isInvalid) ||\n        store.status === 'error' ||\n        store.status === 'idle'\n      ) {\n        const maxAge = loaderOpts?.preload ? loaderOpts?.maxAge : undefined\n\n        await routeMatch.fetch({ maxAge })\n      }\n    },\n    fetch: async (opts) => {\n      const loadId = '' + Date.now() + Math.random()\n      latestId = loadId\n      const checkLatest = async () => {\n        if (loadId !== latestId) {\n          // warning(true, 'Data loader is out of date!')\n          return new Promise(() => {})\n        }\n      }\n\n      batch(() => {\n        // If the match was in an error state, set it\n        // to a loading state again. Otherwise, keep it\n        // as loading or resolved\n        if (store.status === 'idle') {\n          setStore((s) => (s.status = 'loading'))\n        }\n\n        // We started loading the route, so it's no longer invalid\n        setStore((s) => (s.invalid = false))\n      })\n\n      routeMatch.__.loadPromise = new Promise(async (r) => {\n        // We are now fetching, even if it's in the background of a\n        // resolved state\n        setStore((s) => (s.isFetching = true))\n        resolve = r as () => void\n\n        componentsPromise = (async () => {\n          // then run all component and data loaders in parallel\n          // For each component type, potentially load it asynchronously\n\n          await Promise.all(\n            componentTypes.map(async (type) => {\n              const component = routeMatch.options[type]\n\n              if (routeMatch.__[type]?.preload) {\n                routeMatch.__[type] = await router.options.loadComponent!(\n                  component,\n                )\n              }\n            }),\n          )\n        })()\n\n        dataPromise = Promise.resolve().then(async () => {\n          try {\n            if (routeMatch.options.loader) {\n              const data = await router.loadMatchData(routeMatch)\n              await checkLatest()\n\n              setLoaderData(data)\n            }\n\n            setStore((s) => {\n              s.error = undefined\n              s.status = 'success'\n              s.updatedAt = Date.now()\n              s.invalidAt =\n                s.updatedAt +\n                (opts?.maxAge ??\n                  routeMatch.options.loaderMaxAge ??\n                  router.options.defaultLoaderMaxAge ??\n                  0)\n            })\n\n            return store.routeLoaderData\n          } catch (err) {\n            await checkLatest()\n\n            if (process.env.NODE_ENV !== 'production') {\n              console.error(err)\n            }\n\n            setStore((s) => {\n              s.error = err\n              s.status = 'error'\n              s.updatedAt = Date.now()\n            })\n\n            throw err\n          }\n        })\n\n        const after = async () => {\n          await checkLatest()\n          setStore((s) => (s.isFetching = false))\n          delete routeMatch.__.loadPromise\n          resolve()\n        }\n\n        try {\n          await Promise.all([componentsPromise, dataPromise.catch(() => {})])\n          after()\n        } catch {\n          after()\n        }\n      })\n\n      await routeMatch.__.loadPromise\n      await checkLatest()\n    },\n  }\n\n  if (!routeMatch.hasLoaders()) {\n    setStore((s) => (s.status = 'success'))\n  }\n\n  return routeMatch\n}\n","import { decode, encode } from './qss'\nimport { AnySearchSchema } from './routeConfig'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(JSON.stringify)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(stringify: (search: any) => string) {\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val)\n          } catch (err) {\n            // silent\n          }\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n","import {\n  BrowserHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n  HashHistory,\n  History,\n  MemoryHistory,\n} from 'history'\nimport invariant from 'tiny-invariant'\nimport { GetFrameworkGeneric } from './frameworks'\n\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ToOptions,\n  ValidFromPath,\n  ResolveRelativePath,\n} from './link'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  resolvePath,\n  trimPath,\n} from './path'\nimport { AnyRoute, createRoute, Route } from './route'\nimport {\n  AnyLoaderData,\n  AnyPathParams,\n  AnyRouteConfig,\n  AnySearchSchema,\n  LoaderContext,\n  RouteConfig,\n  SearchFilter,\n} from './routeConfig'\nimport {\n  AllRouteInfo,\n  AnyAllRouteInfo,\n  AnyRouteInfo,\n  RouteInfo,\n  RoutesById,\n} from './routeInfo'\nimport { createRouteMatch, RouteMatch, RouteMatchStore } from './routeMatch'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport { createStore, batch, SetStoreFunction } from '@solidjs/reactivity'\nimport {\n  functionalUpdate,\n  last,\n  NoInfer,\n  pick,\n  PickAsRequired,\n  PickRequired,\n  Timeout,\n  Updater,\n} from './utils'\nimport { sharedClone } from './sharedClone'\n\nexport interface RegisterRouter {\n  // router: Router\n}\n\nexport type RegisteredRouter = RegisterRouter extends {\n  router: Router<infer TRouteConfig, infer TAllRouteInfo, infer TRouterContext>\n}\n  ? Router<TRouteConfig, TAllRouteInfo, TRouterContext>\n  : Router\n\nexport type RegisteredAllRouteInfo = RegisterRouter extends {\n  router: Router<infer TRouteConfig, infer TAllRouteInfo, infer TRouterContext>\n}\n  ? TAllRouteInfo\n  : AnyAllRouteInfo\n\nexport interface LocationState {}\n\nexport interface Location<\n  TSearchObj extends AnySearchSchema = {},\n  TState extends LocationState = LocationState,\n> {\n  href: string\n  pathname: string\n  search: TSearchObj\n  searchStr: string\n  state: TState\n  hash: string\n  key?: string\n}\n\nexport interface FromLocation {\n  pathname: string\n  search?: unknown\n  key?: string\n  hash?: string\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\nexport type FilterRoutesFn = <TRoute extends Route<any, RouteInfo>>(\n  routeConfigs: TRoute[],\n) => TRoute[]\n\nexport interface RouterOptions<\n  TRouteConfig extends AnyRouteConfig,\n  TRouterContext,\n> {\n  history?: BrowserHistory | MemoryHistory | HashHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  filterRoutes?: FilterRoutesFn\n  defaultPreload?: false | 'intent'\n  defaultPreloadMaxAge?: number\n  defaultPreloadGcMaxAge?: number\n  defaultPreloadDelay?: number\n  defaultComponent?: GetFrameworkGeneric<'Component'>\n  defaultErrorComponent?: GetFrameworkGeneric<'ErrorComponent'>\n  defaultPendingComponent?: GetFrameworkGeneric<'Component'>\n  defaultLoaderMaxAge?: number\n  defaultLoaderGcMaxAge?: number\n  caseSensitive?: boolean\n  routeConfig?: TRouteConfig\n  basepath?: string\n  useServerData?: boolean\n  createRouter?: (router: Router<any, any, any>) => void\n  createRoute?: (opts: {\n    route: AnyRoute\n    router: Router<any, any, any>\n  }) => void\n  context?: TRouterContext\n  loadComponent?: (\n    component: GetFrameworkGeneric<'Component'>,\n  ) => Promise<GetFrameworkGeneric<'Component'>>\n}\n\nexport interface Action<\n  TPayload = unknown,\n  TResponse = unknown,\n  // TError = unknown,\n> {\n  submit: (\n    submission?: TPayload,\n    actionOpts?: { invalidate?: boolean; multi?: boolean },\n  ) => Promise<TResponse>\n  current?: ActionState<TPayload, TResponse>\n  latest?: ActionState<TPayload, TResponse>\n  submissions: ActionState<TPayload, TResponse>[]\n}\n\nexport interface ActionState<\n  TPayload = unknown,\n  TResponse = unknown,\n  // TError = unknown,\n> {\n  submittedAt: number\n  status: 'idle' | 'pending' | 'success' | 'error'\n  submission: TPayload\n  isMulti: boolean\n  data?: TResponse\n  error?: unknown\n}\n\nexport interface Loader<\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams extends AnyPathParams = {},\n  TRouteLoaderData = AnyLoaderData,\n> {\n  fetch: keyof PickRequired<TFullSearchSchema> extends never\n    ? keyof TAllParams extends never\n      ? (loaderContext: { signal?: AbortSignal }) => Promise<TRouteLoaderData>\n      : (loaderContext: {\n          params: TAllParams\n          search?: TFullSearchSchema\n          signal?: AbortSignal\n        }) => Promise<TRouteLoaderData>\n    : keyof TAllParams extends never\n    ? (loaderContext: {\n        search: TFullSearchSchema\n        params: TAllParams\n        signal?: AbortSignal\n      }) => Promise<TRouteLoaderData>\n    : (loaderContext: {\n        search: TFullSearchSchema\n        signal?: AbortSignal\n      }) => Promise<TRouteLoaderData>\n  current?: LoaderState<TFullSearchSchema, TAllParams>\n  latest?: LoaderState<TFullSearchSchema, TAllParams>\n  pending: LoaderState<TFullSearchSchema, TAllParams>[]\n}\n\nexport interface LoaderState<\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams extends AnyPathParams = {},\n> {\n  loadedAt: number\n  loaderContext: LoaderContext<TFullSearchSchema, TAllParams>\n}\n\nexport interface RouterStore<\n  TSearchObj extends AnySearchSchema = {},\n  TState extends LocationState = LocationState,\n> {\n  status: 'idle' | 'loading'\n  latestLocation: Location<TSearchObj, TState>\n  currentMatches: RouteMatch[]\n  currentLocation: Location<TSearchObj, TState>\n  pendingMatches?: RouteMatch[]\n  pendingLocation?: Location<TSearchObj, TState>\n  lastUpdated: number\n  actions: Record<string, Action>\n  loaders: Record<string, Loader>\n  isFetching: boolean\n  isPreloading: boolean\n  matchCache: Record<string, MatchCacheEntry>\n}\n\ntype Listener = (router: Router<any, any, any>) => void\n\nexport type ListenerFn = () => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: LocationState\n  key?: string\n  from?: string\n  fromCurrent?: boolean\n  __preSearchFilters?: SearchFilter<any>[]\n  __postSearchFilters?: SearchFilter<any>[]\n}\n\nexport type MatchCacheEntry = {\n  gc: number\n  match: RouteMatch\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n  fromCurrent?: boolean\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  fuzzy?: boolean\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport interface DehydratedRouterState\n  extends Pick<\n    RouterStore,\n    'status' | 'latestLocation' | 'currentLocation' | 'lastUpdated'\n  > {\n  currentMatches: DehydratedRouteMatch[]\n}\n\nexport interface DehydratedRouter<TRouterContext = unknown> {\n  // location: Router['__location']\n  store: DehydratedRouterState\n  context: TRouterContext\n}\n\nexport type MatchCache = Record<string, MatchCacheEntry>\n\ninterface DehydratedRouteMatch {\n  matchId: string\n  store: Pick<\n    RouteMatchStore<any, any>,\n    'status' | 'routeLoaderData' | 'isInvalid' | 'invalidAt'\n  >\n}\n\nexport interface RouterContext {}\n\nexport interface Router<\n  TRouteConfig extends AnyRouteConfig = RouteConfig,\n  TAllRouteInfo extends AnyAllRouteInfo = AllRouteInfo<TRouteConfig>,\n  TRouterContext = unknown,\n> {\n  types: {\n    // Super secret internal stuff\n    RouteConfig: TRouteConfig\n    AllRouteInfo: TAllRouteInfo\n  }\n\n  // Public API\n  history: BrowserHistory | MemoryHistory | HashHistory\n  options: PickAsRequired<\n    RouterOptions<TRouteConfig, TRouterContext>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  store: RouterStore<TAllRouteInfo['fullSearchSchema']>\n  setStore: SetStoreFunction<RouterStore<TAllRouteInfo['fullSearchSchema']>>\n  basepath: string\n  // __location: Location<TAllRouteInfo['fullSearchSchema']>\n  routeTree: Route<TAllRouteInfo, RouteInfo>\n  routesById: RoutesById<TAllRouteInfo>\n  reset: () => void\n  mount: () => () => void\n  update: <\n    TRouteConfig extends RouteConfig = RouteConfig,\n    TAllRouteInfo extends AnyAllRouteInfo = AllRouteInfo<TRouteConfig>,\n    TRouterContext = unknown,\n  >(\n    opts?: RouterOptions<TRouteConfig, TRouterContext>,\n  ) => Router<TRouteConfig, TAllRouteInfo, TRouterContext>\n\n  buildNext: (opts: BuildNextOptions) => Location\n  cancelMatches: () => void\n  load: (next?: Location) => Promise<void>\n  cleanMatchCache: () => void\n  getRoute: <TId extends keyof TAllRouteInfo['routeInfoById']>(\n    id: TId,\n  ) => Route<TAllRouteInfo, TAllRouteInfo['routeInfoById'][TId]>\n  loadRoute: (navigateOpts: BuildNextOptions) => Promise<RouteMatch[]>\n  preloadRoute: (\n    navigateOpts: BuildNextOptions,\n    loaderOpts: { maxAge?: number; gcMaxAge?: number },\n  ) => Promise<RouteMatch[]>\n  matchRoutes: (\n    pathname: string,\n    opts?: { strictParseParams?: boolean },\n  ) => RouteMatch[]\n  loadMatches: (\n    resolvedMatches: RouteMatch[],\n    loaderOpts?:\n      | { preload: true; maxAge: number; gcMaxAge: number }\n      | { preload?: false; maxAge?: never; gcMaxAge?: never },\n  ) => Promise<void>\n  loadMatchData: (\n    routeMatch: RouteMatch<any, any>,\n  ) => Promise<Record<string, unknown>>\n  invalidateRoute: (opts: MatchLocation) => void\n  reload: () => Promise<void>\n  resolvePath: (from: string, path: string) => string\n  navigate: <\n    TFrom extends ValidFromPath<TAllRouteInfo> = '/',\n    TTo extends string = '.',\n  >(\n    opts: NavigateOptions<TAllRouteInfo, TFrom, TTo>,\n  ) => Promise<void>\n  matchRoute: <\n    TFrom extends ValidFromPath<TAllRouteInfo> = '/',\n    TTo extends string = '.',\n  >(\n    matchLocation: ToOptions<TAllRouteInfo, TFrom, TTo>,\n    opts?: MatchRouteOptions,\n  ) =>\n    | false\n    | TAllRouteInfo['routeInfoById'][ResolveRelativePath<\n        TFrom,\n        NoInfer<TTo>\n      >]['allParams']\n  buildLink: <\n    TFrom extends ValidFromPath<TAllRouteInfo> = '/',\n    TTo extends string = '.',\n  >(\n    opts: LinkOptions<TAllRouteInfo, TFrom, TTo>,\n  ) => LinkInfo\n  dehydrate: () => DehydratedRouter<TRouterContext>\n  hydrate: (dehydratedRouter: DehydratedRouter<TRouterContext>) => void\n}\n\n// Detect if we're in the DOM\nconst isServer =\n  typeof window === 'undefined' || !window.document?.createElement\n\n// This is the default history object if none is defined\nconst createDefaultHistory = () =>\n  isServer ? createMemoryHistory() : createBrowserHistory()\n\nfunction getInitialRouterState(): RouterStore {\n  return {\n    status: 'idle',\n    latestLocation: null!,\n    currentLocation: null!,\n    currentMatches: [],\n    actions: {},\n    loaders: {},\n    lastUpdated: Date.now(),\n    matchCache: {},\n    get isFetching() {\n      return (\n        this.status === 'loading' ||\n        this.currentMatches.some((d) => d.store.isFetching)\n      )\n    },\n    get isPreloading() {\n      return Object.values(this.matchCache).some(\n        (d) =>\n          d.match.store.isFetching &&\n          !this.currentMatches.find((dd) => dd.matchId === d.match.matchId),\n      )\n    },\n  }\n}\n\nexport function createRouter<\n  TRouteConfig extends AnyRouteConfig = RouteConfig,\n  TAllRouteInfo extends AnyAllRouteInfo = AllRouteInfo<TRouteConfig>,\n  TRouterContext = unknown,\n>(\n  userOptions?: RouterOptions<TRouteConfig, TRouterContext>,\n): Router<TRouteConfig, TAllRouteInfo, TRouterContext> {\n  const originalOptions = {\n    defaultLoaderGcMaxAge: 5 * 60 * 1000,\n    defaultLoaderMaxAge: 0,\n    defaultPreloadMaxAge: 2000,\n    defaultPreloadDelay: 50,\n    context: undefined!,\n    ...userOptions,\n    stringifySearch: userOptions?.stringifySearch ?? defaultStringifySearch,\n    parseSearch: userOptions?.parseSearch ?? defaultParseSearch,\n  }\n\n  const [store, setStore] = createStore<RouterStore>(getInitialRouterState())\n\n  let navigateTimeout: undefined | Timeout\n  let nextAction: undefined | 'push' | 'replace'\n  let navigationPromise: undefined | Promise<void>\n\n  let startedLoadingAt = Date.now()\n  let resolveNavigation = () => {}\n\n  function onFocus() {\n    router.load()\n  }\n\n  function buildRouteTree(rootRouteConfig: RouteConfig) {\n    const recurseRoutes = (\n      routeConfigs: RouteConfig[],\n      parent?: Route<TAllRouteInfo, any, any>,\n    ): Route<TAllRouteInfo, any, any>[] => {\n      return routeConfigs.map((routeConfig, i) => {\n        const routeOptions = routeConfig.options\n        const route = createRoute(routeConfig, routeOptions, i, parent, router)\n        const existingRoute = (router.routesById as any)[route.routeId]\n\n        if (existingRoute) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `Duplicate routes found with id: ${String(route.routeId)}`,\n              router.routesById,\n              route,\n            )\n          }\n          throw new Error()\n        }\n\n        ;(router.routesById as any)[route.routeId] = route\n\n        const children = routeConfig.children as RouteConfig[]\n\n        route.childRoutes = children?.length\n          ? recurseRoutes(children, route)\n          : undefined\n\n        return route\n      })\n    }\n\n    const routes = recurseRoutes([rootRouteConfig])\n\n    return routes[0]!\n  }\n\n  function parseLocation(\n    location: History['location'],\n    previousLocation?: Location,\n  ): Location {\n    const parsedSearch = router.options.parseSearch(location.search)\n\n    return {\n      pathname: location.pathname,\n      searchStr: location.search,\n      search: sharedClone(previousLocation?.search, parsedSearch),\n      hash: location.hash.split('#').reverse()[0] ?? '',\n      href: `${location.pathname}${location.search}${location.hash}`,\n      state: location.state as LocationState,\n      key: location.key,\n    }\n  }\n\n  function navigate(location: BuildNextOptions & { replace?: boolean }) {\n    const next = router.buildNext(location)\n    return commitLocation(next, location.replace)\n  }\n\n  function buildLocation(dest: BuildNextOptions = {}): Location {\n    const fromPathname = dest.fromCurrent\n      ? store.latestLocation.pathname\n      : dest.from ?? store.latestLocation.pathname\n\n    let pathname = resolvePath(\n      router.basepath ?? '/',\n      fromPathname,\n      `${dest.to ?? '.'}`,\n    )\n\n    const fromMatches = router.matchRoutes(store.latestLocation.pathname, {\n      strictParseParams: true,\n    })\n\n    const toMatches = router.matchRoutes(pathname)\n\n    const prevParams = { ...last(fromMatches)?.params }\n\n    let nextParams =\n      (dest.params ?? true) === true\n        ? prevParams\n        : functionalUpdate(dest.params!, prevParams)\n\n    if (nextParams) {\n      toMatches\n        .map((d) => d.options.stringifyParams)\n        .filter(Boolean)\n        .forEach((fn) => {\n          Object.assign({}, nextParams!, fn!(nextParams!))\n        })\n    }\n\n    pathname = interpolatePath(pathname, nextParams ?? {})\n\n    // Pre filters first\n    const preFilteredSearch = dest.__preSearchFilters?.length\n      ? dest.__preSearchFilters.reduce(\n          (prev, next) => next(prev),\n          store.latestLocation.search,\n        )\n      : store.latestLocation.search\n\n    // Then the link/navigate function\n    const destSearch =\n      dest.search === true\n        ? preFilteredSearch // Preserve resolvedFrom true\n        : dest.search\n        ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n        : dest.__preSearchFilters?.length\n        ? preFilteredSearch // Preserve resolvedFrom filters\n        : {}\n\n    // Then post filters\n    const postFilteredSearch = dest.__postSearchFilters?.length\n      ? dest.__postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n      : destSearch\n\n    const search = sharedClone(store.latestLocation.search, postFilteredSearch)\n\n    const searchStr = router.options.stringifySearch(search)\n    let hash =\n      dest.hash === true\n        ? store.latestLocation.hash\n        : functionalUpdate(dest.hash!, store.latestLocation.hash)\n    hash = hash ? `#${hash}` : ''\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      state: store.latestLocation.state,\n      hash,\n      href: `${pathname}${searchStr}${hash}`,\n      key: dest.key,\n    }\n  }\n\n  function commitLocation(next: Location, replace?: boolean): Promise<void> {\n    const id = '' + Date.now() + Math.random()\n\n    if (navigateTimeout) clearTimeout(navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!replace) {\n      nextAction = 'push'\n    }\n\n    const isSameUrl = parseLocation(router.history.location).href === next.href\n\n    if (isSameUrl && !next.key) {\n      nextAction = 'replace'\n    }\n\n    router.history[nextAction](\n      {\n        pathname: next.pathname,\n        hash: next.hash,\n        search: next.searchStr,\n      },\n      {\n        id,\n        ...next.state,\n      },\n    )\n\n    return (navigationPromise = new Promise((resolve) => {\n      const previousNavigationResolve = resolveNavigation\n\n      resolveNavigation = () => {\n        previousNavigationResolve()\n        resolve()\n      }\n    }))\n  }\n\n  const router: Router<TRouteConfig, TAllRouteInfo, TRouterContext> = {\n    types: undefined!,\n\n    // public api\n    history: userOptions?.history || createDefaultHistory(),\n    store,\n    setStore,\n    options: originalOptions,\n    basepath: '',\n    routeTree: undefined!,\n    routesById: {} as any,\n\n    reset: () => {\n      setStore((s) => Object.assign(s, getInitialRouterState()))\n    },\n\n    getRoute: (id) => {\n      return router.routesById[id]\n    },\n\n    dehydrate: () => {\n      return {\n        store: {\n          ...pick(store, [\n            'latestLocation',\n            'currentLocation',\n            'status',\n            'lastUpdated',\n          ]),\n          currentMatches: store.currentMatches.map((match) => ({\n            matchId: match.matchId,\n            store: pick(match.store, [\n              'status',\n              'routeLoaderData',\n              'isInvalid',\n              'invalidAt',\n            ]),\n          })),\n        },\n        context: router.options.context as TRouterContext,\n      }\n    },\n\n    hydrate: (dehydratedRouter) => {\n      setStore((s) => {\n        // Update the context TODO: make this part of state?\n        router.options.context = dehydratedRouter.context\n\n        // Match the routes\n        const currentMatches = router.matchRoutes(\n          dehydratedRouter.store.latestLocation.pathname,\n          {\n            strictParseParams: true,\n          },\n        )\n\n        currentMatches.forEach((match, index) => {\n          const dehydratedMatch = dehydratedRouter.store.currentMatches[index]\n          invariant(\n            dehydratedMatch && dehydratedMatch.matchId === match.matchId,\n            'Oh no! There was a hydration mismatch when attempting to restore the state of the router! 😬',\n          )\n          Object.assign(match, dehydratedMatch)\n        })\n\n        currentMatches.forEach((match) => match.__.validate())\n\n        Object.assign(s, { ...dehydratedRouter.store, currentMatches })\n      })\n    },\n\n    mount: () => {\n      // Mount only does anything on the client\n      if (!isServer) {\n        // If the router matches are empty, load the matches\n        if (!store.currentMatches.length) {\n          router.load()\n        }\n\n        const unsub = router.history.listen((event) => {\n          router.load(parseLocation(event.location, store.latestLocation))\n        })\n\n        // addEventListener does not exist in React Native, but window does\n        // In the future, we might need to invert control here for more adapters\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (window.addEventListener) {\n          // Listen to visibilitychange and focus\n          window.addEventListener('visibilitychange', onFocus, false)\n          window.addEventListener('focus', onFocus, false)\n        }\n\n        return () => {\n          unsub()\n          if (window.removeEventListener) {\n            // Be sure to unsubscribe if a new handler is set\n            window.removeEventListener('visibilitychange', onFocus)\n            window.removeEventListener('focus', onFocus)\n          }\n        }\n      }\n\n      return () => {}\n    },\n\n    update: (opts) => {\n      const newHistory = opts?.history !== router.history\n      if (!store.latestLocation || newHistory) {\n        if (opts?.history) {\n          router.history = opts.history\n        }\n        setStore((s) => {\n          s.latestLocation = parseLocation(router.history.location)\n          s.currentLocation = s.latestLocation\n        })\n      }\n\n      Object.assign(router.options, opts)\n\n      const { basepath, routeConfig } = router.options\n\n      router.basepath = `/${trimPath(basepath ?? '') ?? ''}`\n\n      if (routeConfig) {\n        router.routesById = {} as any\n        router.routeTree = buildRouteTree(routeConfig)\n      }\n\n      return router as any\n    },\n\n    cancelMatches: () => {\n      ;[...store.currentMatches, ...(store.pendingMatches || [])].forEach(\n        (match) => {\n          match.cancel()\n        },\n      )\n    },\n\n    load: async (next?: Location) => {\n      let now = Date.now()\n      const startedAt = now\n      startedLoadingAt = startedAt\n\n      // Cancel any pending matches\n      router.cancelMatches()\n\n      let matches!: RouteMatch<any, any>[]\n\n      batch(() => {\n        if (next) {\n          // Ingest the new location\n          setStore((s) => {\n            s.latestLocation = next\n          })\n        }\n\n        // Match the routes\n        matches = router.matchRoutes(store.latestLocation.pathname, {\n          strictParseParams: true,\n        })\n\n        console.log('set loading', matches)\n        setStore((s) => {\n          s.status = 'loading'\n          s.pendingMatches = matches\n          s.pendingLocation = store.latestLocation\n        })\n      })\n\n      // Load the matches\n      try {\n        await router.loadMatches(matches)\n      } catch (err: any) {\n        console.log(err)\n        invariant(\n          false,\n          'Matches failed to load due to error above ☝️. Navigation cancelled!',\n        )\n      }\n\n      if (startedLoadingAt !== startedAt) {\n        // Ignore side-effects of outdated side-effects\n        return navigationPromise\n      }\n\n      const previousMatches = store.currentMatches\n\n      const exiting: RouteMatch[] = [],\n        staying: RouteMatch[] = []\n\n      previousMatches.forEach((d) => {\n        if (matches.find((dd) => dd.matchId === d.matchId)) {\n          staying.push(d)\n        } else {\n          exiting.push(d)\n        }\n      })\n\n      const entering = matches.filter((d) => {\n        return !previousMatches.find((dd) => dd.matchId === d.matchId)\n      })\n\n      now = Date.now()\n\n      exiting.forEach((d) => {\n        d.__.onExit?.({\n          params: d.params,\n          search: d.store.routeSearch,\n        })\n\n        // Clear idle error states when match leaves\n        if (d.store.status === 'error' && !d.store.isFetching) {\n          d.store.status = 'idle'\n          d.store.error = undefined\n        }\n\n        const gc = Math.max(\n          d.options.loaderGcMaxAge ?? router.options.defaultLoaderGcMaxAge ?? 0,\n          d.options.loaderMaxAge ?? router.options.defaultLoaderMaxAge ?? 0,\n        )\n\n        if (gc > 0) {\n          store.matchCache[d.matchId] = {\n            gc: gc == Infinity ? Number.MAX_SAFE_INTEGER : now + gc,\n            match: d,\n          }\n        }\n      })\n\n      staying.forEach((d) => {\n        d.options.onTransition?.({\n          params: d.params,\n          search: d.store.routeSearch,\n        })\n      })\n\n      entering.forEach((d) => {\n        d.__.onExit = d.options.onLoaded?.({\n          params: d.params,\n          search: d.store.search,\n        })\n        delete store.matchCache[d.matchId]\n      })\n\n      if (startedLoadingAt !== startedAt) {\n        // Ignore side-effects of match loading\n        return\n      }\n\n      matches.forEach((match) => {\n        // Clear actions\n        if (match.action) {\n          // TODO: Check reactivity here\n          match.action.current = undefined\n          match.action.submissions = []\n        }\n      })\n\n      setStore((s) => {\n        console.log('set', matches)\n        Object.assign(s, {\n          status: 'idle',\n          currentLocation: store.latestLocation,\n          currentMatches: matches,\n          pendingLocation: undefined,\n          pendingMatches: undefined,\n        })\n      })\n\n      resolveNavigation()\n    },\n\n    cleanMatchCache: () => {\n      const now = Date.now()\n\n      setStore((s) => {\n        Object.keys(s.matchCache).forEach((matchId) => {\n          const entry = s.matchCache[matchId]!\n\n          // Don't remove loading matches\n          if (entry.match.store.status === 'loading') {\n            return\n          }\n\n          // Do not remove successful matches that are still valid\n          if (entry.gc > 0 && entry.gc > now) {\n            return\n          }\n\n          // Everything else gets removed\n          delete s.matchCache[matchId]\n        })\n      })\n    },\n\n    loadRoute: async (navigateOpts = store.latestLocation) => {\n      const next = router.buildNext(navigateOpts)\n      const matches = router.matchRoutes(next.pathname, {\n        strictParseParams: true,\n      })\n      await router.loadMatches(matches)\n      return matches\n    },\n\n    preloadRoute: async (navigateOpts = store.latestLocation, loaderOpts) => {\n      const next = router.buildNext(navigateOpts)\n      const matches = router.matchRoutes(next.pathname, {\n        strictParseParams: true,\n      })\n\n      await router.loadMatches(matches, {\n        preload: true,\n        maxAge:\n          loaderOpts.maxAge ??\n          router.options.defaultPreloadMaxAge ??\n          router.options.defaultLoaderMaxAge ??\n          0,\n        gcMaxAge:\n          loaderOpts.gcMaxAge ??\n          router.options.defaultPreloadGcMaxAge ??\n          router.options.defaultLoaderGcMaxAge ??\n          0,\n      })\n      return matches\n    },\n\n    matchRoutes: (pathname, opts) => {\n      router.cleanMatchCache()\n\n      const matches: RouteMatch[] = []\n\n      if (!router.routeTree) {\n        return matches\n      }\n\n      const existingMatches = [\n        ...store.currentMatches,\n        ...(store.pendingMatches ?? []),\n      ]\n\n      const recurse = async (routes: Route<any, any>[]): Promise<void> => {\n        const parentMatch = last(matches)\n        let params = parentMatch?.params ?? {}\n\n        const filteredRoutes = router.options.filterRoutes?.(routes) ?? routes\n\n        let foundRoutes: Route[] = []\n\n        const findMatchInRoutes = (parentRoutes: Route[], routes: Route[]) => {\n          routes.some((route) => {\n            if (!route.routePath && route.childRoutes?.length) {\n              return findMatchInRoutes(\n                [...foundRoutes, route],\n                route.childRoutes,\n              )\n            }\n\n            const fuzzy = !!(\n              route.routePath !== '/' || route.childRoutes?.length\n            )\n\n            const matchParams = matchPathname(router.basepath, pathname, {\n              to: route.fullPath,\n              fuzzy,\n              caseSensitive:\n                route.options.caseSensitive ?? router.options.caseSensitive,\n            })\n\n            if (matchParams) {\n              let parsedParams\n\n              try {\n                parsedParams =\n                  route.options.parseParams?.(matchParams!) ?? matchParams\n              } catch (err) {\n                if (opts?.strictParseParams) {\n                  throw err\n                }\n              }\n\n              params = {\n                ...params,\n                ...parsedParams,\n              }\n            }\n\n            if (!!matchParams) {\n              foundRoutes = [...parentRoutes, route]\n            }\n\n            return !!foundRoutes.length\n          })\n\n          return !!foundRoutes.length\n        }\n\n        findMatchInRoutes([], filteredRoutes)\n\n        if (!foundRoutes.length) {\n          return\n        }\n\n        foundRoutes.forEach((foundRoute) => {\n          const interpolatedPath = interpolatePath(foundRoute.routePath, params)\n          const matchId = interpolatePath(foundRoute.routeId, params, true)\n\n          const match =\n            existingMatches.find((d) => d.matchId === matchId) ||\n            store.matchCache[matchId]?.match ||\n            createRouteMatch(router, foundRoute, {\n              parentMatch,\n              matchId,\n              params,\n              pathname: joinPaths([router.basepath, interpolatedPath]),\n            })\n\n          matches.push(match)\n        })\n\n        const foundRoute = last(foundRoutes)!\n\n        if (foundRoute.childRoutes?.length) {\n          recurse(foundRoute.childRoutes)\n        }\n      }\n\n      recurse([router.routeTree])\n\n      linkMatches(matches)\n\n      return matches\n    },\n\n    loadMatches: async (resolvedMatches, loaderOpts) => {\n      resolvedMatches.forEach(async (match) => {\n        // Validate the match (loads search params etc)\n        match.__.validate()\n      })\n\n      // Check each match middleware to see if the route can be accessed\n      await Promise.all(\n        resolvedMatches.map(async (match) => {\n          try {\n            await match.options.beforeLoad?.({\n              router: router as any,\n              match,\n            })\n          } catch (err) {\n            if (!loaderOpts?.preload) {\n              match.options.onLoadError?.(err)\n            }\n\n            throw err\n          }\n        }),\n      )\n\n      const matchPromises = resolvedMatches.map(async (match) => {\n        const search = match.store.search as { __data?: any }\n\n        if (search.__data?.matchId && search.__data.matchId !== match.matchId) {\n          return\n        }\n\n        match.load(loaderOpts)\n\n        if (match.store.status !== 'success' && match.__.loadPromise) {\n          // Wait for the first sign of activity from the match\n          await match.__.loadPromise\n        }\n      })\n\n      await Promise.all(matchPromises)\n    },\n\n    loadMatchData: async (routeMatch) => {\n      if (isServer || !router.options.useServerData) {\n        return (\n          (await routeMatch.options.loader?.({\n            // parentLoaderPromise: routeMatch.parentMatch?.__.dataPromise,\n            params: routeMatch.params,\n            search: routeMatch.store.routeSearch,\n            signal: routeMatch.__.abortController.signal,\n          })) || {}\n        )\n      } else {\n        const next = router.buildNext({\n          to: '.',\n          search: (d: any) => ({\n            ...(d ?? {}),\n            __data: {\n              matchId: routeMatch.matchId,\n            },\n          }),\n        })\n\n        // Refresh:\n        // '/dashboard'\n        // '/dashboard/invoices/'\n        // '/dashboard/invoices/123'\n\n        // New:\n        // '/dashboard/invoices/456'\n\n        // TODO: batch requests when possible\n\n        const res = await fetch(next.href, {\n          method: 'GET',\n          // signal: routeMatch.__.abortController.signal,\n        })\n\n        if (res.ok) {\n          return res.json()\n        }\n\n        throw new Error('Failed to fetch match data')\n      }\n    },\n\n    invalidateRoute: (opts: MatchLocation) => {\n      const next = router.buildNext(opts)\n      const unloadedMatchIds = router\n        .matchRoutes(next.pathname)\n        .map((d) => d.matchId)\n      ;[...store.currentMatches, ...(store.pendingMatches ?? [])].forEach(\n        (match) => {\n          if (unloadedMatchIds.includes(match.matchId)) {\n            match.invalidate()\n          }\n        },\n      )\n    },\n\n    reload: () =>\n      navigate({\n        fromCurrent: true,\n        replace: true,\n        search: true,\n      }),\n\n    resolvePath: (from: string, path: string) => {\n      return resolvePath(router.basepath!, from, cleanPath(path))\n    },\n\n    matchRoute: (location, opts) => {\n      // const location = router.buildNext(opts)\n\n      location = {\n        ...location,\n        to: location.to\n          ? router.resolvePath(location.from ?? '', location.to)\n          : undefined,\n      }\n\n      const next = router.buildNext(location)\n\n      if (opts?.pending) {\n        if (!store.pendingLocation) {\n          return false\n        }\n\n        return !!matchPathname(\n          router.basepath,\n          store.pendingLocation.pathname,\n          {\n            ...opts,\n            to: next.pathname,\n          },\n        )\n      }\n\n      return matchPathname(router.basepath, store.currentLocation.pathname, {\n        ...opts,\n        to: next.pathname,\n      }) as any\n    },\n\n    navigate: async ({ from, to = '.', search, hash, replace, params }) => {\n      // If this link simply reloads the current route,\n      // make sure it has a new key so it will trigger a data refresh\n\n      // If this `to` is a valid external URL, return\n      // null for LinkUtils\n      const toString = String(to)\n      const fromString = String(from)\n\n      let isExternal\n\n      try {\n        new URL(`${toString}`)\n        isExternal = true\n      } catch (e) {}\n\n      invariant(\n        !isExternal,\n        'Attempting to navigate to external url with router.navigate!',\n      )\n\n      return navigate({\n        from: fromString,\n        to: toString,\n        search,\n        hash,\n        replace,\n        params,\n      })\n    },\n\n    buildLink: ({\n      from,\n      to = '.',\n      search,\n      params,\n      hash,\n      target,\n      replace,\n      activeOptions,\n      preload,\n      preloadMaxAge: userPreloadMaxAge,\n      preloadGcMaxAge: userPreloadGcMaxAge,\n      preloadDelay: userPreloadDelay,\n      disabled,\n    }) => {\n      // If this link simply reloads the current route,\n      // make sure it has a new key so it will trigger a data refresh\n\n      // If this `to` is a valid external URL, return\n      // null for LinkUtils\n\n      try {\n        new URL(`${to}`)\n        return {\n          type: 'external',\n          href: to,\n        }\n      } catch (e) {}\n\n      const nextOpts = {\n        from,\n        to,\n        search,\n        params,\n        hash,\n        replace,\n      }\n\n      const next = router.buildNext(nextOpts)\n\n      preload = preload ?? router.options.defaultPreload\n      const preloadDelay =\n        userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0\n\n      // Compare path/hash for matches\n      const pathIsEqual = store.currentLocation.pathname === next.pathname\n      const currentPathSplit = store.currentLocation.pathname.split('/')\n      const nextPathSplit = next.pathname.split('/')\n      const pathIsFuzzyEqual = nextPathSplit.every(\n        (d, i) => d === currentPathSplit[i],\n      )\n      const hashIsEqual = store.currentLocation.hash === next.hash\n      // Combine the matches based on user options\n      const pathTest = activeOptions?.exact ? pathIsEqual : pathIsFuzzyEqual\n      const hashTest = activeOptions?.includeHash ? hashIsEqual : true\n\n      // The final \"active\" test\n      const isActive = pathTest && hashTest\n\n      // The click handler\n      const handleClick = (e: MouseEvent) => {\n        if (\n          !disabled &&\n          !isCtrlEvent(e) &&\n          !e.defaultPrevented &&\n          (!target || target === '_self') &&\n          e.button === 0\n        ) {\n          e.preventDefault()\n          if (pathIsEqual && !search && !hash) {\n            router.invalidateRoute(nextOpts)\n          }\n\n          // All is well? Navigate!\n          navigate(nextOpts)\n        }\n      }\n\n      // The click handler\n      const handleFocus = (e: MouseEvent) => {\n        if (preload) {\n          router\n            .preloadRoute(nextOpts, {\n              maxAge: userPreloadMaxAge,\n              gcMaxAge: userPreloadGcMaxAge,\n            })\n            .catch((err) => {\n              console.log(err)\n              console.warn('Error preloading route! ☝️')\n            })\n        }\n      }\n\n      const handleEnter = (e: MouseEvent) => {\n        const target = (e.target || {}) as LinkCurrentTargetElement\n\n        if (preload) {\n          if (target.preloadTimeout) {\n            return\n          }\n\n          target.preloadTimeout = setTimeout(() => {\n            target.preloadTimeout = null\n            router\n              .preloadRoute(nextOpts, {\n                maxAge: userPreloadMaxAge,\n                gcMaxAge: userPreloadGcMaxAge,\n              })\n              .catch((err) => {\n                console.log(err)\n                console.warn('Error preloading route! ☝️')\n              })\n          }, preloadDelay)\n        }\n      }\n\n      const handleLeave = (e: MouseEvent) => {\n        const target = (e.target || {}) as LinkCurrentTargetElement\n\n        if (target.preloadTimeout) {\n          clearTimeout(target.preloadTimeout)\n          target.preloadTimeout = null\n        }\n      }\n\n      return {\n        type: 'internal',\n        next,\n        handleFocus,\n        handleClick,\n        handleEnter,\n        handleLeave,\n        isActive,\n        disabled,\n      }\n    },\n    buildNext: (opts: BuildNextOptions) => {\n      const next = buildLocation(opts)\n\n      const matches = router.matchRoutes(next.pathname)\n\n      const __preSearchFilters = matches\n        .map((match) => match.options.preSearchFilters ?? [])\n        .flat()\n        .filter(Boolean)\n\n      const __postSearchFilters = matches\n        .map((match) => match.options.postSearchFilters ?? [])\n        .flat()\n        .filter(Boolean)\n\n      return buildLocation({\n        ...opts,\n        __preSearchFilters,\n        __postSearchFilters,\n      })\n    },\n  }\n\n  router.update(userOptions)\n\n  // Allow frameworks to hook into the router creation\n  router.options.createRouter?.(router)\n\n  return router\n}\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nfunction linkMatches(matches: RouteMatch<any, any>[]) {\n  matches.forEach((match, index) => {\n    const parent = matches[index - 1]\n\n    if (parent) {\n      match.__.setParentMatch(parent)\n    } else {\n      match.__.setParentMatch(undefined)\n    }\n  })\n}\n"],"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","Action","BeforeUnloadEventType","PopStateEventType","createBrowserHistory","options","_options$window","window","document","defaultView","globalHistory","history","getIndexAndLocation","_window$location","location","pathname","search","hash","state","idx","usr","blockedPopTx","addEventListener","blockers","nextAction","Pop","_getIndexAndLocation","nextIndex","nextLocation","delta","index","action","retry","go","applyTx","_getIndexAndLocation2","listeners","createEvents","createHref","to","createPath","getNextLocation","parsePath","createKey","getHistoryStateAndUrl","allowTx","_getIndexAndLocation3","replaceState","push","Push","_getHistoryStateAndUr","historyState","url","pushState","error","replace","Replace","_getHistoryStateAndUr2","back","forward","listen","listener","block","blocker","unblock","promptBeforeUnload","removeEventListener","createMemoryHistory","_options3","_options3$initialEntr","initialEntries","initialIndex","entries","map","entry","clamp","splice","n","lowerBound","upperBound","Math","min","max","event","preventDefault","returnValue","handlers","fn","filter","handler","arg","forEach","random","toString","substr","_ref","_ref$pathname","_ref$search","_ref$hash","charAt","path","parsedPath","hashIndex","indexOf","searchIndex","invariant","condition","message","Error","last","arr","functionalUpdate","updater","previous","pick","parent","keys","reduce","obj","joinPaths","paths","cleanPath","Boolean","join","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","RegExp","baseSegments","parsePathname","toSegments","toSegment","value","_last","pop","d","segments","slice","substring","type","split","part","startsWith","interpolatePath","params","leaveWildcard","segment","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","from","routeSegments","baseSegment","routeSegment","isLastRouteSegment","isLastBaseSegment","caseSensitive","toLowerCase","fuzzy","undefined","encode","pfx","k","tmp","str","Array","isArray","encodeURIComponent","toValue","mix","decodeURIComponent","decode","out","shift","concat","CurrentReaction","CurrentGets","CurrentGetsIndex","EffectQueue","stabilize","get","batch","$RAW","Symbol","$TRACK","$PROXY","$NODE","wrap","p","defineProperty","Proxy","proxyTraps","desc","getOwnPropertyDescriptors","l","prop","enumerable","isWrappable","proto","getPrototypeOf","unwrap","item","set","Set","result","unwrapped","v","has","isFrozen","add","getDataNodes","nodes","getDataNode","property","createDataNode","trackSelf","_","s","observers","sources","effect","cleanups","alwaysUpdate","constructor","fnOrValue","console","update","updateIfNecessary","notInBatch","newValue","stale","oldValue","prevReaction","prevGets","prevIndex","c","removeParentObservers","swap","findIndex","destroy","Writing","receiver","tracked","getOwnPropertyDescriptor","setProperty","deleteProperty","ownKeys","Reflect","configurable","writable","deleting","prev","len","node","createStore","store","wrappedStore","createRoute","routeConfig","originalIndex","router","id","routeId","routePath","fullPath","route","routeInfo","routeRouteId","childRoutes","parentRoute","actions","setStore","submissions","submit","async","submission","actionOpts","invalidate","actionStore","setActionStore","submittedAt","Date","now","status","isMulti","multi","current","latest","res","data","invalidateRoute","fromCurrent","reload","err","loader","loaders","pending","fetch","loaderState","loadedAt","loaderContext","rootRouteId","createRouteConfig","children","isRoot","parentId","parentPath","addChildren","childOptions","generate","sharedClone","next","touchAll","things","Map","recurse","prevIsArray","nextIsArray","prevIsObj","isPlainObject","nextIsObj","aSize","bItems","bSize","copy","equalItems","nextKeys","o","hasObjectPrototype","ctor","prot","componentTypes","createRouteMatch","opts","componentsPromise","dataPromise","latestId","resolve","updateLoaderData","_store$parentMatch","loaderData","parentMatch","routeLoaderData","routeSearch","isFetching","invalid","invalidAt","Infinity","isInvalid","routeMatch","childMatches","__","setParentMatch","abortController","AbortController","validate","_store$parentMatch2","parentSearch","currentLocation","prevSearch","validator","validateSearch","parse","nextSearch","component","cause","code","cancel","_routeMatch$__$abortC","abort","hasLoaders","some","_route$options$d","preload","load","minMaxAge","loaderOpts","maxAge","gcMaxAge","currentMatches","find","matchId","matchCache","gc","match","loadId","checkLatest","Promise","loadPromise","r","all","_routeMatch$__$type","loadComponent","then","loadMatchData","updatedAt","loaderMaxAge","defaultLoaderMaxAge","after","catch","defaultParseSearch","parseSearchWith","JSON","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","query","val","isServer","_window$document","createElement","getInitialRouterState","latestLocation","lastUpdated","isPreloading","values","dd","_options2$window","_parsePath","_parsePath$pathname","_parsePath$search","_parsePath$hash","handlePop","_getIndexAndLocation4","_getIndexAndLocation6","querySelector","href","getAttribute","getBaseHref","_getIndexAndLocation7","_getHistoryStateAndUr3","_getHistoryStateAndUr4","userOptions","originalOptions","defaultLoaderGcMaxAge","defaultPreloadMaxAge","defaultPreloadDelay","context","stringifySearch","parseSearch","navigationPromise","startedLoadingAt","resolveNavigation","onFocus","parseLocation","previousLocation","parsedSearch","reverse","navigate","previousNavigationResolve","commitLocation","buildNext","buildLocation","dest","_dest$__preSearchFilt","_dest$__preSearchFilt2","_dest$__postSearchFil","fromPathname","fromMatches","matchRoutes","strictParseParams","toMatches","prevParams","nextParams","stringifyParams","preFilteredSearch","__preSearchFilters","destSearch","postFilteredSearch","__postSearchFilters","types","routeTree","routesById","reset","getRoute","dehydrate","hydrate","dehydratedRouter","dehydratedMatch","mount","unsub","newHistory","rootRouteConfig","recurseRoutes","routeConfigs","buildRouteTree","cancelMatches","pendingMatches","startedAt","matches","log","pendingLocation","loadMatches","previousMatches","exiting","staying","entering","onExit","loaderGcMaxAge","Number","MAX_SAFE_INTEGER","onTransition","onLoaded","cleanMatchCache","loadRoute","navigateOpts","preloadRoute","defaultPreloadGcMaxAge","existingMatches","_foundRoute$childRout","filteredRoutes","filterRoutes","routes","foundRoutes","findMatchInRoutes","parentRoutes","_route$childRoutes","_route$childRoutes2","matchParams","parsedParams","parseParams","foundRoute","_store$matchCache$mat","interpolatedPath","linkMatches","resolvedMatches","beforeLoad","onLoadError","matchPromises","_search$__data","__data","useServerData","signal","method","ok","json","unloadedMatchIds","includes","matchRoute","String","fromString","isExternal","URL","e","buildLink","_ref2","activeOptions","preloadMaxAge","userPreloadMaxAge","preloadGcMaxAge","userPreloadGcMaxAge","preloadDelay","userPreloadDelay","disabled","nextOpts","defaultPreload","pathIsEqual","currentPathSplit","pathIsFuzzyEqual","every","hashIsEqual","pathTest","exact","hashTest","includeHash","handleFocus","warn","handleClick","metaKey","altKey","ctrlKey","shiftKey","isCtrlEvent","defaultPrevented","button","handleEnter","preloadTimeout","setTimeout","handleLeave","clearTimeout","isActive","preSearchFilters","flat","postSearchFilters","createRouter","cond"],"mappings":"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"}
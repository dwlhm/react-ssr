/**
 * router-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.RouterCore = {}));
})(this, (function (exports) { 'use strict';

  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  /**
   * Actions represent the type of change to a location value.
   *
   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action
   */
  var Action;

  (function (Action) {
    /**
     * A POP indicates a change to an arbitrary index in the history stack, such
     * as a back or forward navigation. It does not describe the direction of the
     * navigation, only that the current index changed.
     *
     * Note: This is the default action for newly created history objects.
     */
    Action["Pop"] = "POP";
    /**
     * A PUSH indicates a new entry being added to the history stack, such as when
     * a link is clicked and a new page loads. When this happens, all subsequent
     * entries in the stack are lost.
     */

    Action["Push"] = "PUSH";
    /**
     * A REPLACE indicates the entry at the current index in the history stack
     * being replaced by a new one.
     */

    Action["Replace"] = "REPLACE";
  })(Action || (Action = {}));

  var readOnly = function (obj) {
    return Object.freeze(obj);
  } ;

  function warning$1(cond, message) {
    if (!cond) {
      // eslint-disable-next-line no-console
      if (typeof console !== 'undefined') console.warn(message);

      try {
        // Welcome to debugging history!
        //
        // This error is thrown as a convenience so you can more easily
        // find the source for a warning that appears in the console by
        // enabling "pause on exceptions" in your JavaScript debugger.
        throw new Error(message); // eslint-disable-next-line no-empty
      } catch (e) {}
    }
  }

  var BeforeUnloadEventType = 'beforeunload';
  var HashChangeEventType = 'hashchange';
  var PopStateEventType = 'popstate';
  /**
   * Browser history stores the location in regular URLs. This is the standard for
   * most web apps, but it requires some configuration on the server to ensure you
   * serve the same app at multiple URLs.
   *
   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
   */

  function createBrowserHistory(options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$window = _options.window,
        window = _options$window === void 0 ? document.defaultView : _options$window;
    var globalHistory = window.history;

    function getIndexAndLocation() {
      var _window$location = window.location,
          pathname = _window$location.pathname,
          search = _window$location.search,
          hash = _window$location.hash;
      var state = globalHistory.state || {};
      return [state.idx, readOnly({
        pathname: pathname,
        search: search,
        hash: hash,
        state: state.usr || null,
        key: state.key || 'default'
      })];
    }

    var blockedPopTx = null;

    function handlePop() {
      if (blockedPopTx) {
        blockers.call(blockedPopTx);
        blockedPopTx = null;
      } else {
        var nextAction = Action.Pop;

        var _getIndexAndLocation = getIndexAndLocation(),
            nextIndex = _getIndexAndLocation[0],
            nextLocation = _getIndexAndLocation[1];

        if (blockers.length) {
          if (nextIndex != null) {
            var delta = index - nextIndex;

            if (delta) {
              // Revert the POP
              blockedPopTx = {
                action: nextAction,
                location: nextLocation,
                retry: function retry() {
                  go(delta * -1);
                }
              };
              go(delta);
            }
          } else {
            // Trying to POP to a location with no index. We did not create
            // this location, so we can't effectively block the navigation.
            warning$1(false, // TODO: Write up a doc that explains our blocking strategy in
            // detail and link to it here so people can understand better what
            // is going on and how to avoid it.
            "You are trying to block a POP navigation to a location that was not " + "created by the history library. The block will fail silently in " + "production, but in general you should do all navigation with the " + "history library (instead of using window.history.pushState directly) " + "to avoid this situation.") ;
          }
        } else {
          applyTx(nextAction);
        }
      }
    }

    window.addEventListener(PopStateEventType, handlePop);
    var action = Action.Pop;

    var _getIndexAndLocation2 = getIndexAndLocation(),
        index = _getIndexAndLocation2[0],
        location = _getIndexAndLocation2[1];

    var listeners = createEvents();
    var blockers = createEvents();

    if (index == null) {
      index = 0;
      globalHistory.replaceState(_extends({}, globalHistory.state, {
        idx: index
      }), '');
    }

    function createHref(to) {
      return typeof to === 'string' ? to : createPath(to);
    } // state defaults to `null` because `window.history.state` does


    function getNextLocation(to, state) {
      if (state === void 0) {
        state = null;
      }

      return readOnly(_extends({
        pathname: location.pathname,
        hash: '',
        search: ''
      }, typeof to === 'string' ? parsePath(to) : to, {
        state: state,
        key: createKey()
      }));
    }

    function getHistoryStateAndUrl(nextLocation, index) {
      return [{
        usr: nextLocation.state,
        key: nextLocation.key,
        idx: index
      }, createHref(nextLocation)];
    }

    function allowTx(action, location, retry) {
      return !blockers.length || (blockers.call({
        action: action,
        location: location,
        retry: retry
      }), false);
    }

    function applyTx(nextAction) {
      action = nextAction;

      var _getIndexAndLocation3 = getIndexAndLocation();

      index = _getIndexAndLocation3[0];
      location = _getIndexAndLocation3[1];
      listeners.call({
        action: action,
        location: location
      });
    }

    function push(to, state) {
      var nextAction = Action.Push;
      var nextLocation = getNextLocation(to, state);

      function retry() {
        push(to, state);
      }

      if (allowTx(nextAction, nextLocation, retry)) {
        var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),
            historyState = _getHistoryStateAndUr[0],
            url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading
        // try...catch because iOS limits us to 100 pushState calls :/


        try {
          globalHistory.pushState(historyState, '', url);
        } catch (error) {
          // They are going to lose state here, but there is no real
          // way to warn them about it since the page will refresh...
          window.location.assign(url);
        }

        applyTx(nextAction);
      }
    }

    function replace(to, state) {
      var nextAction = Action.Replace;
      var nextLocation = getNextLocation(to, state);

      function retry() {
        replace(to, state);
      }

      if (allowTx(nextAction, nextLocation, retry)) {
        var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),
            historyState = _getHistoryStateAndUr2[0],
            url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading


        globalHistory.replaceState(historyState, '', url);
        applyTx(nextAction);
      }
    }

    function go(delta) {
      globalHistory.go(delta);
    }

    var history = {
      get action() {
        return action;
      },

      get location() {
        return location;
      },

      createHref: createHref,
      push: push,
      replace: replace,
      go: go,
      back: function back() {
        go(-1);
      },
      forward: function forward() {
        go(1);
      },
      listen: function listen(listener) {
        return listeners.push(listener);
      },
      block: function block(blocker) {
        var unblock = blockers.push(blocker);

        if (blockers.length === 1) {
          window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }

        return function () {
          unblock(); // Remove the beforeunload listener so the document may
          // still be salvageable in the pagehide event.
          // See https://html.spec.whatwg.org/#unloading-documents

          if (!blockers.length) {
            window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
          }
        };
      }
    };
    return history;
  }
  /**
   * Hash history stores the location in window.location.hash. This makes it ideal
   * for situations where you don't want to send the location to the server for
   * some reason, either because you do cannot configure it or the URL space is
   * reserved for something else.
   *
   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
   */

  function createHashHistory(options) {
    if (options === void 0) {
      options = {};
    }

    var _options2 = options,
        _options2$window = _options2.window,
        window = _options2$window === void 0 ? document.defaultView : _options2$window;
    var globalHistory = window.history;

    function getIndexAndLocation() {
      var _parsePath = parsePath(window.location.hash.substr(1)),
          _parsePath$pathname = _parsePath.pathname,
          pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,
          _parsePath$search = _parsePath.search,
          search = _parsePath$search === void 0 ? '' : _parsePath$search,
          _parsePath$hash = _parsePath.hash,
          hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;

      var state = globalHistory.state || {};
      return [state.idx, readOnly({
        pathname: pathname,
        search: search,
        hash: hash,
        state: state.usr || null,
        key: state.key || 'default'
      })];
    }

    var blockedPopTx = null;

    function handlePop() {
      if (blockedPopTx) {
        blockers.call(blockedPopTx);
        blockedPopTx = null;
      } else {
        var nextAction = Action.Pop;

        var _getIndexAndLocation4 = getIndexAndLocation(),
            nextIndex = _getIndexAndLocation4[0],
            nextLocation = _getIndexAndLocation4[1];

        if (blockers.length) {
          if (nextIndex != null) {
            var delta = index - nextIndex;

            if (delta) {
              // Revert the POP
              blockedPopTx = {
                action: nextAction,
                location: nextLocation,
                retry: function retry() {
                  go(delta * -1);
                }
              };
              go(delta);
            }
          } else {
            // Trying to POP to a location with no index. We did not create
            // this location, so we can't effectively block the navigation.
            warning$1(false, // TODO: Write up a doc that explains our blocking strategy in
            // detail and link to it here so people can understand better
            // what is going on and how to avoid it.
            "You are trying to block a POP navigation to a location that was not " + "created by the history library. The block will fail silently in " + "production, but in general you should do all navigation with the " + "history library (instead of using window.history.pushState directly) " + "to avoid this situation.") ;
          }
        } else {
          applyTx(nextAction);
        }
      }
    }

    window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge
    // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event

    window.addEventListener(HashChangeEventType, function () {
      var _getIndexAndLocation5 = getIndexAndLocation(),
          nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.


      if (createPath(nextLocation) !== createPath(location)) {
        handlePop();
      }
    });
    var action = Action.Pop;

    var _getIndexAndLocation6 = getIndexAndLocation(),
        index = _getIndexAndLocation6[0],
        location = _getIndexAndLocation6[1];

    var listeners = createEvents();
    var blockers = createEvents();

    if (index == null) {
      index = 0;
      globalHistory.replaceState(_extends({}, globalHistory.state, {
        idx: index
      }), '');
    }

    function getBaseHref() {
      var base = document.querySelector('base');
      var href = '';

      if (base && base.getAttribute('href')) {
        var url = window.location.href;
        var hashIndex = url.indexOf('#');
        href = hashIndex === -1 ? url : url.slice(0, hashIndex);
      }

      return href;
    }

    function createHref(to) {
      return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));
    }

    function getNextLocation(to, state) {
      if (state === void 0) {
        state = null;
      }

      return readOnly(_extends({
        pathname: location.pathname,
        hash: '',
        search: ''
      }, typeof to === 'string' ? parsePath(to) : to, {
        state: state,
        key: createKey()
      }));
    }

    function getHistoryStateAndUrl(nextLocation, index) {
      return [{
        usr: nextLocation.state,
        key: nextLocation.key,
        idx: index
      }, createHref(nextLocation)];
    }

    function allowTx(action, location, retry) {
      return !blockers.length || (blockers.call({
        action: action,
        location: location,
        retry: retry
      }), false);
    }

    function applyTx(nextAction) {
      action = nextAction;

      var _getIndexAndLocation7 = getIndexAndLocation();

      index = _getIndexAndLocation7[0];
      location = _getIndexAndLocation7[1];
      listeners.call({
        action: action,
        location: location
      });
    }

    function push(to, state) {
      var nextAction = Action.Push;
      var nextLocation = getNextLocation(to, state);

      function retry() {
        push(to, state);
      }

      warning$1(nextLocation.pathname.charAt(0) === '/', "Relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")") ;

      if (allowTx(nextAction, nextLocation, retry)) {
        var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),
            historyState = _getHistoryStateAndUr3[0],
            url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading
        // try...catch because iOS limits us to 100 pushState calls :/


        try {
          globalHistory.pushState(historyState, '', url);
        } catch (error) {
          // They are going to lose state here, but there is no real
          // way to warn them about it since the page will refresh...
          window.location.assign(url);
        }

        applyTx(nextAction);
      }
    }

    function replace(to, state) {
      var nextAction = Action.Replace;
      var nextLocation = getNextLocation(to, state);

      function retry() {
        replace(to, state);
      }

      warning$1(nextLocation.pathname.charAt(0) === '/', "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(to) + ")") ;

      if (allowTx(nextAction, nextLocation, retry)) {
        var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),
            historyState = _getHistoryStateAndUr4[0],
            url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading


        globalHistory.replaceState(historyState, '', url);
        applyTx(nextAction);
      }
    }

    function go(delta) {
      globalHistory.go(delta);
    }

    var history = {
      get action() {
        return action;
      },

      get location() {
        return location;
      },

      createHref: createHref,
      push: push,
      replace: replace,
      go: go,
      back: function back() {
        go(-1);
      },
      forward: function forward() {
        go(1);
      },
      listen: function listen(listener) {
        return listeners.push(listener);
      },
      block: function block(blocker) {
        var unblock = blockers.push(blocker);

        if (blockers.length === 1) {
          window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }

        return function () {
          unblock(); // Remove the beforeunload listener so the document may
          // still be salvageable in the pagehide event.
          // See https://html.spec.whatwg.org/#unloading-documents

          if (!blockers.length) {
            window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
          }
        };
      }
    };
    return history;
  }
  /**
   * Memory history stores the current location in memory. It is designed for use
   * in stateful non-browser environments like tests and React Native.
   *
   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory
   */

  function createMemoryHistory(options) {
    if (options === void 0) {
      options = {};
    }

    var _options3 = options,
        _options3$initialEntr = _options3.initialEntries,
        initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,
        initialIndex = _options3.initialIndex;
    var entries = initialEntries.map(function (entry) {
      var location = readOnly(_extends({
        pathname: '/',
        search: '',
        hash: '',
        state: null,
        key: createKey()
      }, typeof entry === 'string' ? parsePath(entry) : entry));
      warning$1(location.pathname.charAt(0) === '/', "Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: " + JSON.stringify(entry) + ")") ;
      return location;
    });
    var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);
    var action = Action.Pop;
    var location = entries[index];
    var listeners = createEvents();
    var blockers = createEvents();

    function createHref(to) {
      return typeof to === 'string' ? to : createPath(to);
    }

    function getNextLocation(to, state) {
      if (state === void 0) {
        state = null;
      }

      return readOnly(_extends({
        pathname: location.pathname,
        search: '',
        hash: ''
      }, typeof to === 'string' ? parsePath(to) : to, {
        state: state,
        key: createKey()
      }));
    }

    function allowTx(action, location, retry) {
      return !blockers.length || (blockers.call({
        action: action,
        location: location,
        retry: retry
      }), false);
    }

    function applyTx(nextAction, nextLocation) {
      action = nextAction;
      location = nextLocation;
      listeners.call({
        action: action,
        location: location
      });
    }

    function push(to, state) {
      var nextAction = Action.Push;
      var nextLocation = getNextLocation(to, state);

      function retry() {
        push(to, state);
      }

      warning$1(location.pathname.charAt(0) === '/', "Relative pathnames are not supported in memory history.push(" + JSON.stringify(to) + ")") ;

      if (allowTx(nextAction, nextLocation, retry)) {
        index += 1;
        entries.splice(index, entries.length, nextLocation);
        applyTx(nextAction, nextLocation);
      }
    }

    function replace(to, state) {
      var nextAction = Action.Replace;
      var nextLocation = getNextLocation(to, state);

      function retry() {
        replace(to, state);
      }

      warning$1(location.pathname.charAt(0) === '/', "Relative pathnames are not supported in memory history.replace(" + JSON.stringify(to) + ")") ;

      if (allowTx(nextAction, nextLocation, retry)) {
        entries[index] = nextLocation;
        applyTx(nextAction, nextLocation);
      }
    }

    function go(delta) {
      var nextIndex = clamp(index + delta, 0, entries.length - 1);
      var nextAction = Action.Pop;
      var nextLocation = entries[nextIndex];

      function retry() {
        go(delta);
      }

      if (allowTx(nextAction, nextLocation, retry)) {
        index = nextIndex;
        applyTx(nextAction, nextLocation);
      }
    }

    var history = {
      get index() {
        return index;
      },

      get action() {
        return action;
      },

      get location() {
        return location;
      },

      createHref: createHref,
      push: push,
      replace: replace,
      go: go,
      back: function back() {
        go(-1);
      },
      forward: function forward() {
        go(1);
      },
      listen: function listen(listener) {
        return listeners.push(listener);
      },
      block: function block(blocker) {
        return blockers.push(blocker);
      }
    };
    return history;
  } ////////////////////////////////////////////////////////////////////////////////
  // UTILS
  ////////////////////////////////////////////////////////////////////////////////

  function clamp(n, lowerBound, upperBound) {
    return Math.min(Math.max(n, lowerBound), upperBound);
  }

  function promptBeforeUnload(event) {
    // Cancel the event.
    event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.

    event.returnValue = '';
  }

  function createEvents() {
    var handlers = [];
    return {
      get length() {
        return handlers.length;
      },

      push: function push(fn) {
        handlers.push(fn);
        return function () {
          handlers = handlers.filter(function (handler) {
            return handler !== fn;
          });
        };
      },
      call: function call(arg) {
        handlers.forEach(function (fn) {
          return fn && fn(arg);
        });
      }
    };
  }

  function createKey() {
    return Math.random().toString(36).substr(2, 8);
  }
  /**
   * Creates a string URL path from the given pathname, search, and hash components.
   *
   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath
   */


  function createPath(_ref) {
    var _ref$pathname = _ref.pathname,
        pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,
        _ref$search = _ref.search,
        search = _ref$search === void 0 ? '' : _ref$search,
        _ref$hash = _ref.hash,
        hash = _ref$hash === void 0 ? '' : _ref$hash;
    if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;
    if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;
    return pathname;
  }
  /**
   * Parses a string URL path into its separate pathname, search, and hash components.
   *
   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath
   */

  function parsePath(path) {
    var parsedPath = {};

    if (path) {
      var hashIndex = path.indexOf('#');

      if (hashIndex >= 0) {
        parsedPath.hash = path.substr(hashIndex);
        path = path.substr(0, hashIndex);
      }

      var searchIndex = path.indexOf('?');

      if (searchIndex >= 0) {
        parsedPath.search = path.substr(searchIndex);
        path = path.substr(0, searchIndex);
      }

      if (path) {
        parsedPath.pathname = path;
      }
    }

    return parsedPath;
  }

  var prefix = 'Invariant failed';
  function invariant(condition, message) {
      if (condition) {
          return;
      }
      var provided = typeof message === 'function' ? message() : message;
      var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value);
  }

  function last(arr) {
    return arr[arr.length - 1];
  }
  function warning(cond, message) {
    if (cond) {
      if (typeof console !== 'undefined') console.warn(message);
      try {
        throw new Error(message);
      } catch {}
    }
    return true;
  }
  function isFunction(d) {
    return typeof d === 'function';
  }
  function functionalUpdate(updater, previous) {
    if (isFunction(updater)) {
      return updater(previous);
    }
    return updater;
  }
  function pick(parent, keys) {
    return keys.reduce((obj, key) => {
      obj[key] = parent[key];
      return obj;
    }, {});
  }

  function joinPaths(paths) {
    return cleanPath(paths.filter(Boolean).join('/'));
  }
  function cleanPath(path) {
    // remove double slashes
    return path.replace(/\/{2,}/g, '/');
  }
  function trimPathLeft(path) {
    return path === '/' ? path : path.replace(/^\/{1,}/, '');
  }
  function trimPathRight(path) {
    return path === '/' ? path : path.replace(/\/{1,}$/, '');
  }
  function trimPath(path) {
    return trimPathRight(trimPathLeft(path));
  }
  function resolvePath(basepath, base, to) {
    base = base.replace(new RegExp(`^${basepath}`), '/');
    to = to.replace(new RegExp(`^${basepath}`), '/');
    let baseSegments = parsePathname(base);
    const toSegments = parsePathname(to);
    toSegments.forEach((toSegment, index) => {
      if (toSegment.value === '/') {
        if (!index) {
          // Leading slash
          baseSegments = [toSegment];
        } else if (index === toSegments.length - 1) {
          // Trailing Slash
          baseSegments.push(toSegment);
        } else ;
      } else if (toSegment.value === '..') {
        var _last;
        // Extra trailing slash? pop it off
        if (baseSegments.length > 1 && ((_last = last(baseSegments)) == null ? void 0 : _last.value) === '/') {
          baseSegments.pop();
        }
        baseSegments.pop();
      } else if (toSegment.value === '.') {
        return;
      } else {
        baseSegments.push(toSegment);
      }
    });
    const joined = joinPaths([basepath, ...baseSegments.map(d => d.value)]);
    return cleanPath(joined);
  }
  function parsePathname(pathname) {
    if (!pathname) {
      return [];
    }
    pathname = cleanPath(pathname);
    const segments = [];
    if (pathname.slice(0, 1) === '/') {
      pathname = pathname.substring(1);
      segments.push({
        type: 'pathname',
        value: '/'
      });
    }
    if (!pathname) {
      return segments;
    }

    // Remove empty segments and '.' segments
    const split = pathname.split('/').filter(Boolean);
    segments.push(...split.map(part => {
      if (part.startsWith('*')) {
        return {
          type: 'wildcard',
          value: part
        };
      }
      if (part.charAt(0) === '$') {
        return {
          type: 'param',
          value: part
        };
      }
      return {
        type: 'pathname',
        value: part
      };
    }));
    if (pathname.slice(-1) === '/') {
      pathname = pathname.substring(1);
      segments.push({
        type: 'pathname',
        value: '/'
      });
    }
    return segments;
  }
  function interpolatePath(path, params, leaveWildcard) {
    const interpolatedPathSegments = parsePathname(path);
    return joinPaths(interpolatedPathSegments.map(segment => {
      if (segment.value === '*' && !leaveWildcard) {
        return '';
      }
      if (segment.type === 'param') {
        return params[segment.value.substring(1)] ?? '';
      }
      return segment.value;
    }));
  }
  function matchPathname(basepath, currentPathname, matchLocation) {
    const pathParams = matchByPath(basepath, currentPathname, matchLocation);
    // const searchMatched = matchBySearch(currentLocation.search, matchLocation)

    if (matchLocation.to && !pathParams) {
      return;
    }
    return pathParams ?? {};
  }
  function matchByPath(basepath, from, matchLocation) {
    if (!from.startsWith(basepath)) {
      return undefined;
    }
    from = basepath != '/' ? from.substring(basepath.length) : from;
    const baseSegments = parsePathname(from);
    const to = `${matchLocation.to ?? '*'}`;
    const routeSegments = parsePathname(to);
    const params = {};
    let isMatch = (() => {
      for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
        const baseSegment = baseSegments[i];
        const routeSegment = routeSegments[i];
        const isLastRouteSegment = i === routeSegments.length - 1;
        const isLastBaseSegment = i === baseSegments.length - 1;
        if (routeSegment) {
          if (routeSegment.type === 'wildcard') {
            if (baseSegment != null && baseSegment.value) {
              params['*'] = joinPaths(baseSegments.slice(i).map(d => d.value));
              return true;
            }
            return false;
          }
          if (routeSegment.type === 'pathname') {
            if (routeSegment.value === '/' && !(baseSegment != null && baseSegment.value)) {
              return true;
            }
            if (baseSegment) {
              if (matchLocation.caseSensitive) {
                if (routeSegment.value !== baseSegment.value) {
                  return false;
                }
              } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {
                return false;
              }
            }
          }
          if (!baseSegment) {
            return false;
          }
          if (routeSegment.type === 'param') {
            if ((baseSegment == null ? void 0 : baseSegment.value) === '/') {
              return false;
            }
            if (baseSegment.value.charAt(0) !== '$') {
              params[routeSegment.value.substring(1)] = baseSegment.value;
            }
          }
        }
        if (isLastRouteSegment && !isLastBaseSegment) {
          return !!matchLocation.fuzzy;
        }
      }
      return true;
    })();
    return isMatch ? params : undefined;
  }

  // @ts-nocheck

  // qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.

  function encode(obj, pfx) {
    var k,
      i,
      tmp,
      str = '';
    for (k in obj) {
      if ((tmp = obj[k]) !== void 0) {
        if (Array.isArray(tmp)) {
          for (i = 0; i < tmp.length; i++) {
            str && (str += '&');
            str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);
          }
        } else {
          str && (str += '&');
          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);
        }
      }
    }
    return (pfx || '') + str;
  }
  function toValue(mix) {
    if (!mix) return '';
    var str = decodeURIComponent(mix);
    if (str === 'false') return false;
    if (str === 'true') return true;
    if (str.charAt(0) === '0') return str;
    return +str * 0 === 0 ? +str : str;
  }
  function decode(str) {
    var tmp,
      k,
      out = {},
      arr = str.split('&');
    while (tmp = arr.shift()) {
      tmp = tmp.split('=');
      k = tmp.shift();
      if (out[k] !== void 0) {
        out[k] = [].concat(out[k], toValue(tmp.shift()));
      } else {
        out[k] = toValue(tmp.shift());
      }
    }
    return out;
  }

  // src/core.ts
  var CurrentReaction = void 0;
  var CurrentGets = null;
  var CurrentGetsIndex = 0;
  var EffectQueue = null;
  var CacheClean = 0;
  var CacheCheck = 1;
  var CacheDirty = 2;
  var Reactive = class {
    value;
    fn;
    observers = null;
    sources = null;
    state;
    effect;
    cleanups = null;
    alwaysUpdate = false;
    constructor(fnOrValue, type) {
      if (type != 0 /* Signal */) {
        this.fn = fnOrValue;
        this.value = void 0;
        this.state = CacheDirty;
        console.error("Memos and effects must be wrapped in a createRoot");
        this.effect = type == 2 /* Effect */;
        if (this.effect)
          this.update();
      } else {
        this.fn = void 0;
        this.value = fnOrValue;
        this.state = CacheClean;
        this.effect = false;
      }
    }
    get() {
      if (CurrentReaction) {
        if (!CurrentGets && CurrentReaction.sources && CurrentReaction.sources[CurrentGetsIndex] == this) {
          CurrentGetsIndex++;
        } else {
          if (!CurrentGets)
            CurrentGets = [this];
          else
            CurrentGets.push(this);
        }
      }
      if (this.fn)
        this.updateIfNecessary();
      return this.value;
    }
    set(value) {
      const notInBatch = !EffectQueue;
      const newValue = typeof value === "function" ? value(this.value) : value;
      if ((this.value !== newValue || this.alwaysUpdate) && this.observers) {
        for (let i = 0; i < this.observers.length; i++) {
          this.observers[i].stale(CacheDirty);
        }
      }
      this.value = newValue;
      if (notInBatch)
        stabilize();
      return newValue;
    }
    stale(state) {
      if (this.state < state) {
        if (this.state === CacheClean && this.effect) {
          if (EffectQueue)
            EffectQueue.push(this);
          else
            EffectQueue = [this];
        }
        this.state = state;
        if (this.observers) {
          for (let i = 0; i < this.observers.length; i++) {
            this.observers[i].stale(CacheCheck);
          }
        }
      }
    }
    update() {
      const oldValue = this.value;
      const prevReaction = CurrentReaction;
      const prevGets = CurrentGets;
      const prevIndex = CurrentGetsIndex;
      CurrentReaction = this;
      CurrentGets = null;
      CurrentGetsIndex = 0;
      try {
        if (this.cleanups) {
          this.cleanups.forEach((c) => c());
          this.cleanups = null;
        }
        this.value = this.fn();
        if (CurrentGets) {
          this.removeParentObservers(CurrentGetsIndex);
          if (this.sources && CurrentGetsIndex > 0) {
            this.sources.length = CurrentGetsIndex + CurrentGets.length;
            for (let i = 0; i < CurrentGets.length; i++) {
              this.sources[CurrentGetsIndex + i] = CurrentGets[i];
            }
          } else {
            this.sources = CurrentGets;
          }
          for (let i = CurrentGetsIndex; i < this.sources.length; i++) {
            const source = this.sources[i];
            if (!source.observers) {
              source.observers = [this];
            } else {
              source.observers.push(this);
            }
          }
        } else if (this.sources && CurrentGetsIndex < this.sources.length) {
          this.removeParentObservers(CurrentGetsIndex);
          this.sources.length = CurrentGetsIndex;
        }
      } finally {
        CurrentGets = prevGets;
        CurrentReaction = prevReaction;
        CurrentGetsIndex = prevIndex;
      }
      if ((oldValue !== this.value || this.alwaysUpdate) && this.observers) {
        for (let i = 0; i < this.observers.length; i++) {
          this.observers[i].state = CacheDirty;
        }
      }
      this.state = CacheClean;
    }
    updateIfNecessary() {
      if (this.state === CacheCheck) {
        for (const source of this.sources) {
          source.updateIfNecessary();
          if (this.state === CacheDirty) {
            break;
          }
        }
      }
      if (this.state === CacheDirty) {
        this.update();
      }
      this.state = CacheClean;
    }
    removeParentObservers(index) {
      if (!this.sources)
        return;
      for (let i = index; i < this.sources.length; i++) {
        const source = this.sources[i];
        const swap = source.observers.findIndex((v) => v === this);
        source.observers[swap] = source.observers[source.observers.length - 1];
        source.observers.pop();
      }
    }
    destroy() {
      if (this.cleanups) {
        this.cleanups.forEach((c) => c());
        this.cleanups = null;
      }
      this.removeParentObservers(0);
    }
  };
  function stabilize() {
    if (!EffectQueue)
      return;
    for (let i = 0; i < EffectQueue.length; i++) {
      EffectQueue[i].get();
    }
    EffectQueue = null;
  }
  function batch(fn) {
    EffectQueue = [];
    let out = fn();
    stabilize();
    return out;
  }

  // src/store.ts
  var $RAW = Symbol("store-raw");
  var $TRACK = Symbol("track");
  var $PROXY = Symbol("store-proxy");
  var $NODE = Symbol("store-node");
  function wrap(value) {
    let p = value[$PROXY];
    if (!p) {
      Object.defineProperty(value, $PROXY, {
        value: p = new Proxy(value, proxyTraps)
      });
      if (!Array.isArray(value)) {
        const keys = Object.keys(value);
        const desc = Object.getOwnPropertyDescriptors(value);
        for (let i = 0, l = keys.length; i < l; i++) {
          const prop = keys[i];
          if (desc[prop].get) {
            const get = desc[prop].get.bind(p);
            Object.defineProperty(value, prop, {
              enumerable: desc[prop].enumerable,
              get
            });
          }
        }
      }
    }
    return p;
  }
  function isWrappable(obj) {
    let proto;
    return obj != null && typeof obj === "object" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));
  }
  function unwrap(item, set = /* @__PURE__ */ new Set()) {
    let result, unwrapped, v, prop;
    if (result = item != null && item[$RAW])
      return result;
    if (!isWrappable(item) || set.has(item))
      return item;
    if (Array.isArray(item)) {
      if (Object.isFrozen(item))
        item = item.slice(0);
      else
        set.add(item);
      for (let i = 0, l = item.length; i < l; i++) {
        v = item[i];
        if ((unwrapped = unwrap(v, set)) !== v)
          item[i] = unwrapped;
      }
    } else {
      if (Object.isFrozen(item))
        item = Object.assign({}, item);
      else
        set.add(item);
      const keys = Object.keys(item);
      const desc = Object.getOwnPropertyDescriptors(item);
      for (let i = 0, l = keys.length; i < l; i++) {
        prop = keys[i];
        if (desc[prop].get)
          continue;
        v = item[prop];
        if ((unwrapped = unwrap(v, set)) !== v)
          item[prop] = unwrapped;
      }
    }
    return item;
  }
  function getDataNodes(target) {
    let nodes = target[$NODE];
    if (!nodes)
      Object.defineProperty(target, $NODE, { value: nodes = {} });
    return nodes;
  }
  function getDataNode(nodes, property, value) {
    return nodes[property] || (nodes[property] = createDataNode(value));
  }
  function proxyDescriptor(target, property) {
    const desc = Reflect.getOwnPropertyDescriptor(target, property);
    if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)
      return desc;
    delete desc.value;
    delete desc.writable;
    desc.get = () => target[$PROXY][property];
    return desc;
  }
  function trackSelf(target) {
    if (CurrentReaction) {
      const nodes = getDataNodes(target);
      (nodes._ || (nodes._ = createDataNode())).get();
    }
  }
  function ownKeys(target) {
    trackSelf(target);
    return Reflect.ownKeys(target);
  }
  function createDataNode(value) {
    const s = new Reactive(value, 0);
    s.alwaysUpdate = true;
    return s;
  }
  var Writing = false;
  var proxyTraps = {
    get(target, property, receiver) {
      if (property === $RAW)
        return target;
      if (property === $PROXY)
        return receiver;
      if (property === $TRACK) {
        trackSelf(target);
        return receiver;
      }
      const nodes = getDataNodes(target);
      const tracked = nodes.hasOwnProperty(property);
      let value = tracked ? nodes[property].get() : target[property];
      if (property === $NODE || property === "__proto__")
        return value;
      if (!tracked) {
        const desc = Object.getOwnPropertyDescriptor(target, property);
        if (CurrentReaction && (typeof value !== "function" || target.hasOwnProperty(property)) && !(desc && desc.get))
          value = getDataNode(nodes, property, value).get();
      }
      return isWrappable(value) ? wrap(value) : value;
    },
    has(target, property) {
      if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === "__proto__")
        return true;
      this.get(target, property, target);
      return property in target;
    },
    set(target, property, value) {
      Writing && setProperty(target, property, unwrap(value));
      return true;
    },
    deleteProperty(target, property) {
      Writing && setProperty(target, property, void 0, true);
      return true;
    },
    ownKeys,
    getOwnPropertyDescriptor: proxyDescriptor
  };
  function setProperty(state, property, value, deleting = false) {
    if (!deleting && state[property] === value)
      return;
    const prev = state[property];
    const len = state.length;
    if (deleting)
      delete state[property];
    else
      state[property] = value;
    const nodes = getDataNodes(state);
    let node;
    if (node = getDataNode(nodes, property, prev))
      node.set(() => value);
    if (Array.isArray(state) && state.length !== len)
      (node = getDataNode(nodes, "length", len)) && node.set(state.length);
    (node = nodes._) && node.set();
  }
  function createStore(store) {
    const unwrappedStore = unwrap(store);
    const wrappedStore = wrap(unwrappedStore);
    const setStore = (fn) => {
      batch(() => {
        try {
          Writing = true;
          fn(wrappedStore);
        } finally {
          Writing = false;
        }
      });
    };
    return [wrappedStore, setStore];
  }

  function createRoute(routeConfig, options, originalIndex, parent, router) {
    const {
      id,
      routeId,
      path: routePath,
      fullPath
    } = routeConfig;
    let route = {
      routeInfo: undefined,
      routeId: id,
      routeRouteId: routeId,
      originalIndex,
      routePath,
      fullPath,
      options,
      router,
      childRoutes: undefined,
      parentRoute: parent,
      get action() {
        let action = router.store.actions[id] || (() => {
          router.setStore(s => {
            s.actions[id] = {
              submissions: [],
              submit: async (submission, actionOpts) => {
                if (!route) {
                  return;
                }
                const invalidate = (actionOpts == null ? void 0 : actionOpts.invalidate) ?? true;
                const [actionStore, setActionStore] = createStore({
                  submittedAt: Date.now(),
                  status: 'pending',
                  submission,
                  isMulti: !!(actionOpts != null && actionOpts.multi)
                });
                router.setStore(s => {
                  if (!(actionOpts != null && actionOpts.multi)) {
                    s.actions[id].submissions = action.submissions.filter(d => d.isMulti);
                  }
                  s.actions[id].current = actionStore;
                  s.actions[id].latest = actionStore;
                  s.actions[id].submissions.push(actionStore);
                });
                try {
                  const res = await (route.options.action == null ? void 0 : route.options.action(submission));
                  setActionStore(s => {
                    s.data = res;
                  });
                  if (invalidate) {
                    router.invalidateRoute({
                      to: '.',
                      fromCurrent: true
                    });
                    await router.reload();
                  }
                  setActionStore(s => {
                    s.status = 'success';
                  });
                  return res;
                } catch (err) {
                  console.error(err);
                  setActionStore(s => {
                    s.error = err;
                    s.status = 'error';
                  });
                }
              }
            };
          });
          return router.store.actions[id];
        })();
        return action;
      },
      get loader() {
        let loader = router.store.loaders[id] || (() => {
          router.setStore(s => {
            s.loaders[id] = {
              pending: [],
              fetch: async loaderContext => {
                if (!route) {
                  return;
                }
                const loaderState = {
                  loadedAt: Date.now(),
                  loaderContext
                };
                router.setStore(s => {
                  s.loaders[id].current = loaderState;
                  s.loaders[id].latest = loaderState;
                  s.loaders[id].pending.push(loaderState);
                });
                try {
                  return await (route.options.loader == null ? void 0 : route.options.loader(loaderContext));
                } finally {
                  router.setStore(s => {
                    s.loaders[id].pending = s.loaders[id].pending.filter(d => d !== loaderState);
                  });
                }
              }
            };
          });
          return router.store.loaders[id];
        })();
        return loader;
      }

      // buildLink: (options) => {
      //   return router.buildLink({
      //     ...options,
      //     from: fullPath,
      //   } as any) as any
      // },

      // navigate: (options) => {
      //   return router.navigate({
      //     ...options,
      //     from: fullPath,
      //   } as any) as any
      // },

      // matchRoute: (matchLocation, opts) => {
      //   return router.matchRoute(
      //     {
      //       ...matchLocation,
      //       from: fullPath,
      //     } as any,
      //     opts,
      //   ) as any
      // },
    };

    router.options.createRoute == null ? void 0 : router.options.createRoute({
      router,
      route
    });
    return route;
  }

  const rootRouteId = '__root__';
  const createRouteConfig = function (options, children, isRoot, parentId, parentPath) {
    if (options === void 0) {
      options = {};
    }
    if (isRoot === void 0) {
      isRoot = true;
    }
    if (isRoot) {
      options.path = rootRouteId;
    }

    // Strip the root from parentIds
    if (parentId === rootRouteId) {
      parentId = '';
    }
    let path = isRoot ? rootRouteId : options.path;

    // If the path is anything other than an index path, trim it up
    if (path && path !== '/') {
      path = trimPath(path);
    }
    const routeId = path || options.id;
    let id = joinPaths([parentId, routeId]);
    if (path === rootRouteId) {
      path = '/';
    }
    if (id !== rootRouteId) {
      id = joinPaths(['/', id]);
    }
    const fullPath = id === rootRouteId ? '/' : trimPathRight(joinPaths([parentPath, path]));
    return {
      id: id,
      routeId: routeId,
      path: path,
      fullPath: fullPath,
      options: options,
      children,
      addChildren: children => createRouteConfig(options, children, false, parentId, parentPath),
      createRoute: childOptions => createRouteConfig(childOptions, undefined, false, id, fullPath),
      generate: () => {
        invariant(false, `routeConfig.generate() is used by TanStack Router's file-based routing code generation and should not actually be called during runtime. `);
      }
    };
  };

  /**
   * This function returns `a` if `b` is deeply equal.
   * If not, it will replace any deeply equal children of `b` with those of `a`.
   * This can be used for structural sharing between JSON values for example.
   */
  function sharedClone(prev, next, touchAll) {
    const things = new Map();
    function recurse(prev, next) {
      if (prev === next) {
        return prev;
      }
      if (things.has(next)) {
        return things.get(next);
      }
      const prevIsArray = Array.isArray(prev);
      const nextIsArray = Array.isArray(next);
      const prevIsObj = isPlainObject(prev);
      const nextIsObj = isPlainObject(next);
      const isArray = prevIsArray && nextIsArray;
      const isObj = prevIsObj && nextIsObj;
      const isSameStructure = isArray || isObj;

      // Both are arrays or objects
      if (isSameStructure) {
        const aSize = isArray ? prev.length : Object.keys(prev).length;
        const bItems = isArray ? next : Object.keys(next);
        const bSize = bItems.length;
        const copy = isArray ? [] : {};
        let equalItems = 0;
        for (let i = 0; i < bSize; i++) {
          const key = isArray ? i : bItems[i];
          if (copy[key] === prev[key]) {
            equalItems++;
          }
        }
        if (aSize === bSize && equalItems === aSize) {
          things.set(next, prev);
          return prev;
        }
        things.set(next, copy);
        for (let i = 0; i < bSize; i++) {
          const key = isArray ? i : bItems[i];
          if (typeof bItems[i] === 'function') {
            copy[key] = prev[key];
          } else {
            copy[key] = recurse(prev[key], next[key]);
          }
          if (copy[key] === prev[key]) {
            equalItems++;
          }
        }
        return copy;
      }
      if (nextIsArray) {
        const copy = [];
        things.set(next, copy);
        for (let i = 0; i < next.length; i++) {
          copy[i] = recurse(undefined, next[i]);
        }
        return copy;
      }
      if (nextIsObj) {
        const copy = {};
        things.set(next, copy);
        const nextKeys = Object.keys(next);
        for (let i = 0; i < nextKeys.length; i++) {
          const key = nextKeys[i];
          copy[key] = recurse(undefined, next[key]);
        }
        return copy;
      }
      return next;
    }
    return recurse(prev, next);
  }

  // Copied from: https://github.com/jonschlinkert/is-plain-object
  function isPlainObject(o) {
    if (!hasObjectPrototype(o)) {
      return false;
    }

    // If has modified constructor
    const ctor = o.constructor;
    if (typeof ctor === 'undefined') {
      return true;
    }

    // If has modified prototype
    const prot = ctor.prototype;
    if (!hasObjectPrototype(prot)) {
      return false;
    }

    // If constructor does not have an Object-specific method
    if (!prot.hasOwnProperty('isPrototypeOf')) {
      return false;
    }

    // Most likely a plain Object
    return true;
  }
  function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  }

  const componentTypes = ['component', 'errorComponent', 'pendingComponent'];
  function createRouteMatch(router, route, opts) {
    let componentsPromise;
    let dataPromise;
    let latestId = '';
    let resolve = () => {};
    function setLoaderData(loaderData) {
      batch(() => {
        setStore(s => {
          s.routeLoaderData = sharedClone(s.routeLoaderData, loaderData);
        });
        updateLoaderData();
      });
    }
    function updateLoaderData() {
      setStore(s => {
        var _store$parentMatch;
        s.loaderData = sharedClone(s.loaderData, {
          ...((_store$parentMatch = store.parentMatch) == null ? void 0 : _store$parentMatch.store.loaderData),
          ...s.routeLoaderData
        });
      });
    }
    const [store, setStore] = createStore({
      routeSearch: {},
      search: {},
      status: 'idle',
      routeLoaderData: {},
      loaderData: {},
      isFetching: false,
      invalid: false,
      invalidAt: Infinity,
      get isInvalid() {
        const now = Date.now();
        return this.invalid || this.invalidAt < now;
      }
    });
    const routeMatch = {
      ...route,
      ...opts,
      store,
      // setStore,
      router,
      childMatches: [],
      __: {
        setParentMatch: parentMatch => {
          batch(() => {
            setStore(s => {
              s.parentMatch = parentMatch;
            });
            updateLoaderData();
          });
        },
        abortController: new AbortController(),
        validate: () => {
          var _store$parentMatch2;
          // Validate the search params and stabilize them
          const parentSearch = ((_store$parentMatch2 = store.parentMatch) == null ? void 0 : _store$parentMatch2.store.search) ?? router.store.currentLocation.search;
          try {
            const prevSearch = store.routeSearch;
            const validator = typeof routeMatch.options.validateSearch === 'object' ? routeMatch.options.validateSearch.parse : routeMatch.options.validateSearch;
            let nextSearch = sharedClone(prevSearch, (validator == null ? void 0 : validator(parentSearch)) ?? {});
            batch(() => {
              // Invalidate route matches when search param stability changes
              if (prevSearch !== nextSearch) {
                setStore(s => s.invalid = true);
              }

              // TODO: Alright, do we need batch() here?
              setStore(s => {
                s.routeSearch = nextSearch;
                s.search = sharedClone(parentSearch, {
                  ...parentSearch,
                  ...nextSearch
                });
              });
            });
            componentTypes.map(async type => {
              const component = routeMatch.options[type];
              if (typeof routeMatch.__[type] !== 'function') {
                routeMatch.__[type] = component;
              }
            });
          } catch (err) {
            console.error(err);
            const error = new Error('Invalid search params found', {
              cause: err
            });
            error.code = 'INVALID_SEARCH_PARAMS';
            setStore(s => {
              s.status = 'error';
              s.error = error;
            });

            // Do not proceed with loading the route
            return;
          }
        }
      },
      cancel: () => {
        var _routeMatch$__$abortC;
        (_routeMatch$__$abortC = routeMatch.__.abortController) == null ? void 0 : _routeMatch$__$abortC.abort();
      },
      invalidate: () => {
        setStore(s => s.invalid = true);
      },
      hasLoaders: () => {
        return !!(route.options.loader || componentTypes.some(d => {
          var _route$options$d;
          return (_route$options$d = route.options[d]) == null ? void 0 : _route$options$d.preload;
        }));
      },
      load: async loaderOpts => {
        const now = Date.now();
        const minMaxAge = loaderOpts != null && loaderOpts.preload ? Math.max(loaderOpts == null ? void 0 : loaderOpts.maxAge, loaderOpts == null ? void 0 : loaderOpts.gcMaxAge) : 0;

        // If this is a preload, add it to the preload cache
        if (loaderOpts != null && loaderOpts.preload && minMaxAge > 0) {
          // If the match is currently active, don't preload it
          if (router.store.currentMatches.find(d => d.matchId === routeMatch.matchId)) {
            return;
          }
          router.store.matchCache[routeMatch.matchId] = {
            gc: now + loaderOpts.gcMaxAge,
            match: routeMatch
          };
        }

        // If the match is invalid, errored or idle, trigger it to load
        if (store.status === 'success' && store.isInvalid || store.status === 'error' || store.status === 'idle') {
          const maxAge = loaderOpts != null && loaderOpts.preload ? loaderOpts == null ? void 0 : loaderOpts.maxAge : undefined;
          await routeMatch.fetch({
            maxAge
          });
        }
      },
      fetch: async opts => {
        const loadId = '' + Date.now() + Math.random();
        latestId = loadId;
        const checkLatest = async () => {
          if (loadId !== latestId) {
            // warning(true, 'Data loader is out of date!')
            return new Promise(() => {});
          }
        };
        batch(() => {
          // If the match was in an error state, set it
          // to a loading state again. Otherwise, keep it
          // as loading or resolved
          if (store.status === 'idle') {
            setStore(s => s.status = 'loading');
          }

          // We started loading the route, so it's no longer invalid
          setStore(s => s.invalid = false);
        });
        routeMatch.__.loadPromise = new Promise(async r => {
          // We are now fetching, even if it's in the background of a
          // resolved state
          setStore(s => s.isFetching = true);
          resolve = r;
          componentsPromise = (async () => {
            // then run all component and data loaders in parallel
            // For each component type, potentially load it asynchronously

            await Promise.all(componentTypes.map(async type => {
              var _routeMatch$__$type;
              const component = routeMatch.options[type];
              if ((_routeMatch$__$type = routeMatch.__[type]) != null && _routeMatch$__$type.preload) {
                routeMatch.__[type] = await router.options.loadComponent(component);
              }
            }));
          })();
          dataPromise = Promise.resolve().then(async () => {
            try {
              if (routeMatch.options.loader) {
                const data = await router.loadMatchData(routeMatch);
                await checkLatest();
                setLoaderData(data);
              }
              setStore(s => {
                s.error = undefined;
                s.status = 'success';
                s.updatedAt = Date.now();
                s.invalidAt = s.updatedAt + ((opts == null ? void 0 : opts.maxAge) ?? routeMatch.options.loaderMaxAge ?? router.options.defaultLoaderMaxAge ?? 0);
              });
              return store.routeLoaderData;
            } catch (err) {
              await checkLatest();
              {
                console.error(err);
              }
              setStore(s => {
                s.error = err;
                s.status = 'error';
                s.updatedAt = Date.now();
              });
              throw err;
            }
          });
          const after = async () => {
            await checkLatest();
            setStore(s => s.isFetching = false);
            delete routeMatch.__.loadPromise;
            resolve();
          };
          try {
            await Promise.all([componentsPromise, dataPromise.catch(() => {})]);
            after();
          } catch {
            after();
          }
        });
        await routeMatch.__.loadPromise;
        await checkLatest();
      }
    };
    if (!routeMatch.hasLoaders()) {
      setStore(s => s.status = 'success');
    }
    return routeMatch;
  }

  const defaultParseSearch = parseSearchWith(JSON.parse);
  const defaultStringifySearch = stringifySearchWith(JSON.stringify);
  function parseSearchWith(parser) {
    return searchStr => {
      if (searchStr.substring(0, 1) === '?') {
        searchStr = searchStr.substring(1);
      }
      let query = decode(searchStr);

      // Try to parse any query params that might be json
      for (let key in query) {
        const value = query[key];
        if (typeof value === 'string') {
          try {
            query[key] = parser(value);
          } catch (err) {
            //
          }
        }
      }
      return query;
    };
  }
  function stringifySearchWith(stringify) {
    return search => {
      search = {
        ...search
      };
      if (search) {
        Object.keys(search).forEach(key => {
          const val = search[key];
          if (typeof val === 'undefined' || val === undefined) {
            delete search[key];
          } else if (val && typeof val === 'object' && val !== null) {
            try {
              search[key] = stringify(val);
            } catch (err) {
              // silent
            }
          }
        });
      }
      const searchStr = encode(search).toString();
      return searchStr ? `?${searchStr}` : '';
    };
  }

  var _window$document;
  // Detect if we're in the DOM
  const isServer = typeof window === 'undefined' || !((_window$document = window.document) != null && _window$document.createElement);

  // This is the default history object if none is defined
  const createDefaultHistory = () => isServer ? createMemoryHistory() : createBrowserHistory();
  function getInitialRouterState() {
    return {
      status: 'idle',
      latestLocation: null,
      currentLocation: null,
      currentMatches: [],
      actions: {},
      loaders: {},
      lastUpdated: Date.now(),
      matchCache: {},
      get isFetching() {
        return this.status === 'loading' || this.currentMatches.some(d => d.store.isFetching);
      },
      get isPreloading() {
        return Object.values(this.matchCache).some(d => d.match.store.isFetching && !this.currentMatches.find(dd => dd.matchId === d.match.matchId));
      }
    };
  }
  function createRouter(userOptions) {
    const originalOptions = {
      defaultLoaderGcMaxAge: 5 * 60 * 1000,
      defaultLoaderMaxAge: 0,
      defaultPreloadMaxAge: 2000,
      defaultPreloadDelay: 50,
      context: undefined,
      ...userOptions,
      stringifySearch: (userOptions == null ? void 0 : userOptions.stringifySearch) ?? defaultStringifySearch,
      parseSearch: (userOptions == null ? void 0 : userOptions.parseSearch) ?? defaultParseSearch
    };
    const [store, setStore] = createStore(getInitialRouterState());
    let navigationPromise;
    let startedLoadingAt = Date.now();
    let resolveNavigation = () => {};
    function onFocus() {
      router.load();
    }
    function buildRouteTree(rootRouteConfig) {
      const recurseRoutes = (routeConfigs, parent) => {
        return routeConfigs.map((routeConfig, i) => {
          const routeOptions = routeConfig.options;
          const route = createRoute(routeConfig, routeOptions, i, parent, router);
          const existingRoute = router.routesById[route.routeId];
          if (existingRoute) {
            {
              console.warn(`Duplicate routes found with id: ${String(route.routeId)}`, router.routesById, route);
            }
            throw new Error();
          }
          router.routesById[route.routeId] = route;
          const children = routeConfig.children;
          route.childRoutes = children != null && children.length ? recurseRoutes(children, route) : undefined;
          return route;
        });
      };
      const routes = recurseRoutes([rootRouteConfig]);
      return routes[0];
    }
    function parseLocation(location, previousLocation) {
      const parsedSearch = router.options.parseSearch(location.search);
      return {
        pathname: location.pathname,
        searchStr: location.search,
        search: sharedClone(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
        hash: location.hash.split('#').reverse()[0] ?? '',
        href: `${location.pathname}${location.search}${location.hash}`,
        state: location.state,
        key: location.key
      };
    }
    function navigate(location) {
      const next = router.buildNext(location);
      return commitLocation(next, location.replace);
    }
    function buildLocation(dest) {
      var _last, _dest$__preSearchFilt, _dest$__preSearchFilt2, _dest$__postSearchFil;
      if (dest === void 0) {
        dest = {};
      }
      const fromPathname = dest.fromCurrent ? store.latestLocation.pathname : dest.from ?? store.latestLocation.pathname;
      let pathname = resolvePath(router.basepath ?? '/', fromPathname, `${dest.to ?? '.'}`);
      const fromMatches = router.matchRoutes(store.latestLocation.pathname, {
        strictParseParams: true
      });
      const toMatches = router.matchRoutes(pathname);
      const prevParams = {
        ...((_last = last(fromMatches)) == null ? void 0 : _last.params)
      };
      let nextParams = (dest.params ?? true) === true ? prevParams : functionalUpdate(dest.params, prevParams);
      if (nextParams) {
        toMatches.map(d => d.options.stringifyParams).filter(Boolean).forEach(fn => {
          Object.assign({}, nextParams, fn(nextParams));
        });
      }
      pathname = interpolatePath(pathname, nextParams ?? {});

      // Pre filters first
      const preFilteredSearch = (_dest$__preSearchFilt = dest.__preSearchFilters) != null && _dest$__preSearchFilt.length ? dest.__preSearchFilters.reduce((prev, next) => next(prev), store.latestLocation.search) : store.latestLocation.search;

      // Then the link/navigate function
      const destSearch = dest.search === true ? preFilteredSearch // Preserve resolvedFrom true
      : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater
      : (_dest$__preSearchFilt2 = dest.__preSearchFilters) != null && _dest$__preSearchFilt2.length ? preFilteredSearch // Preserve resolvedFrom filters
      : {};

      // Then post filters
      const postFilteredSearch = (_dest$__postSearchFil = dest.__postSearchFilters) != null && _dest$__postSearchFil.length ? dest.__postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
      const search = sharedClone(store.latestLocation.search, postFilteredSearch);
      const searchStr = router.options.stringifySearch(search);
      let hash = dest.hash === true ? store.latestLocation.hash : functionalUpdate(dest.hash, store.latestLocation.hash);
      hash = hash ? `#${hash}` : '';
      return {
        pathname,
        search,
        searchStr,
        state: store.latestLocation.state,
        hash,
        href: `${pathname}${searchStr}${hash}`,
        key: dest.key
      };
    }
    function commitLocation(next, replace) {
      const id = '' + Date.now() + Math.random();
      let nextAction = 'replace';
      if (!replace) {
        nextAction = 'push';
      }
      const isSameUrl = parseLocation(router.history.location).href === next.href;
      if (isSameUrl && !next.key) {
        nextAction = 'replace';
      }
      router.history[nextAction]({
        pathname: next.pathname,
        hash: next.hash,
        search: next.searchStr
      }, {
        id,
        ...next.state
      });
      return navigationPromise = new Promise(resolve => {
        const previousNavigationResolve = resolveNavigation;
        resolveNavigation = () => {
          previousNavigationResolve();
          resolve();
        };
      });
    }
    const router = {
      types: undefined,
      // public api
      history: (userOptions == null ? void 0 : userOptions.history) || createDefaultHistory(),
      store,
      setStore,
      options: originalOptions,
      basepath: '',
      routeTree: undefined,
      routesById: {},
      reset: () => {
        setStore(s => Object.assign(s, getInitialRouterState()));
      },
      getRoute: id => {
        return router.routesById[id];
      },
      dehydrate: () => {
        return {
          store: {
            ...pick(store, ['latestLocation', 'currentLocation', 'status', 'lastUpdated']),
            currentMatches: store.currentMatches.map(match => ({
              matchId: match.matchId,
              store: pick(match.store, ['status', 'routeLoaderData', 'isInvalid', 'invalidAt'])
            }))
          },
          context: router.options.context
        };
      },
      hydrate: dehydratedRouter => {
        setStore(s => {
          // Update the context TODO: make this part of state?
          router.options.context = dehydratedRouter.context;

          // Match the routes
          const currentMatches = router.matchRoutes(dehydratedRouter.store.latestLocation.pathname, {
            strictParseParams: true
          });
          currentMatches.forEach((match, index) => {
            const dehydratedMatch = dehydratedRouter.store.currentMatches[index];
            invariant(dehydratedMatch && dehydratedMatch.matchId === match.matchId, 'Oh no! There was a hydration mismatch when attempting to restore the state of the router! 😬');
            Object.assign(match, dehydratedMatch);
          });
          currentMatches.forEach(match => match.__.validate());
          Object.assign(s, {
            ...dehydratedRouter.store,
            currentMatches
          });
        });
      },
      mount: () => {
        // Mount only does anything on the client
        if (!isServer) {
          // If the router matches are empty, load the matches
          if (!store.currentMatches.length) {
            router.load();
          }
          const unsub = router.history.listen(event => {
            router.load(parseLocation(event.location, store.latestLocation));
          });

          // addEventListener does not exist in React Native, but window does
          // In the future, we might need to invert control here for more adapters
          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
          if (window.addEventListener) {
            // Listen to visibilitychange and focus
            window.addEventListener('visibilitychange', onFocus, false);
            window.addEventListener('focus', onFocus, false);
          }
          return () => {
            unsub();
            if (window.removeEventListener) {
              // Be sure to unsubscribe if a new handler is set
              window.removeEventListener('visibilitychange', onFocus);
              window.removeEventListener('focus', onFocus);
            }
          };
        }
        return () => {};
      },
      update: opts => {
        const newHistory = (opts == null ? void 0 : opts.history) !== router.history;
        if (!store.latestLocation || newHistory) {
          if (opts != null && opts.history) {
            router.history = opts.history;
          }
          setStore(s => {
            s.latestLocation = parseLocation(router.history.location);
            s.currentLocation = s.latestLocation;
          });
        }
        Object.assign(router.options, opts);
        const {
          basepath,
          routeConfig
        } = router.options;
        router.basepath = `/${trimPath(basepath ?? '') ?? ''}`;
        if (routeConfig) {
          router.routesById = {};
          router.routeTree = buildRouteTree(routeConfig);
        }
        return router;
      },
      cancelMatches: () => {
        [...store.currentMatches, ...(store.pendingMatches || [])].forEach(match => {
          match.cancel();
        });
      },
      load: async next => {
        let now = Date.now();
        const startedAt = now;
        startedLoadingAt = startedAt;

        // Cancel any pending matches
        router.cancelMatches();
        let matches;
        batch(() => {
          if (next) {
            // Ingest the new location
            setStore(s => {
              s.latestLocation = next;
            });
          }

          // Match the routes
          matches = router.matchRoutes(store.latestLocation.pathname, {
            strictParseParams: true
          });
          console.log('set loading', matches);
          setStore(s => {
            s.status = 'loading';
            s.pendingMatches = matches;
            s.pendingLocation = store.latestLocation;
          });
        });

        // Load the matches
        try {
          await router.loadMatches(matches);
        } catch (err) {
          console.log(err);
          invariant(false, 'Matches failed to load due to error above ☝️. Navigation cancelled!');
        }
        if (startedLoadingAt !== startedAt) {
          // Ignore side-effects of outdated side-effects
          return navigationPromise;
        }
        const previousMatches = store.currentMatches;
        const exiting = [],
          staying = [];
        previousMatches.forEach(d => {
          if (matches.find(dd => dd.matchId === d.matchId)) {
            staying.push(d);
          } else {
            exiting.push(d);
          }
        });
        const entering = matches.filter(d => {
          return !previousMatches.find(dd => dd.matchId === d.matchId);
        });
        now = Date.now();
        exiting.forEach(d => {
          d.__.onExit == null ? void 0 : d.__.onExit({
            params: d.params,
            search: d.store.routeSearch
          });

          // Clear idle error states when match leaves
          if (d.store.status === 'error' && !d.store.isFetching) {
            d.store.status = 'idle';
            d.store.error = undefined;
          }
          const gc = Math.max(d.options.loaderGcMaxAge ?? router.options.defaultLoaderGcMaxAge ?? 0, d.options.loaderMaxAge ?? router.options.defaultLoaderMaxAge ?? 0);
          if (gc > 0) {
            store.matchCache[d.matchId] = {
              gc: gc == Infinity ? Number.MAX_SAFE_INTEGER : now + gc,
              match: d
            };
          }
        });
        staying.forEach(d => {
          d.options.onTransition == null ? void 0 : d.options.onTransition({
            params: d.params,
            search: d.store.routeSearch
          });
        });
        entering.forEach(d => {
          d.__.onExit = d.options.onLoaded == null ? void 0 : d.options.onLoaded({
            params: d.params,
            search: d.store.search
          });
          delete store.matchCache[d.matchId];
        });
        if (startedLoadingAt !== startedAt) {
          // Ignore side-effects of match loading
          return;
        }
        matches.forEach(match => {
          // Clear actions
          if (match.action) {
            // TODO: Check reactivity here
            match.action.current = undefined;
            match.action.submissions = [];
          }
        });
        setStore(s => {
          console.log('set', matches);
          Object.assign(s, {
            status: 'idle',
            currentLocation: store.latestLocation,
            currentMatches: matches,
            pendingLocation: undefined,
            pendingMatches: undefined
          });
        });
        resolveNavigation();
      },
      cleanMatchCache: () => {
        const now = Date.now();
        setStore(s => {
          Object.keys(s.matchCache).forEach(matchId => {
            const entry = s.matchCache[matchId];

            // Don't remove loading matches
            if (entry.match.store.status === 'loading') {
              return;
            }

            // Do not remove successful matches that are still valid
            if (entry.gc > 0 && entry.gc > now) {
              return;
            }

            // Everything else gets removed
            delete s.matchCache[matchId];
          });
        });
      },
      loadRoute: async function (navigateOpts) {
        if (navigateOpts === void 0) {
          navigateOpts = store.latestLocation;
        }
        const next = router.buildNext(navigateOpts);
        const matches = router.matchRoutes(next.pathname, {
          strictParseParams: true
        });
        await router.loadMatches(matches);
        return matches;
      },
      preloadRoute: async function (navigateOpts, loaderOpts) {
        if (navigateOpts === void 0) {
          navigateOpts = store.latestLocation;
        }
        const next = router.buildNext(navigateOpts);
        const matches = router.matchRoutes(next.pathname, {
          strictParseParams: true
        });
        await router.loadMatches(matches, {
          preload: true,
          maxAge: loaderOpts.maxAge ?? router.options.defaultPreloadMaxAge ?? router.options.defaultLoaderMaxAge ?? 0,
          gcMaxAge: loaderOpts.gcMaxAge ?? router.options.defaultPreloadGcMaxAge ?? router.options.defaultLoaderGcMaxAge ?? 0
        });
        return matches;
      },
      matchRoutes: (pathname, opts) => {
        router.cleanMatchCache();
        const matches = [];
        if (!router.routeTree) {
          return matches;
        }
        const existingMatches = [...store.currentMatches, ...(store.pendingMatches ?? [])];
        const recurse = async routes => {
          var _foundRoute$childRout;
          const parentMatch = last(matches);
          let params = (parentMatch == null ? void 0 : parentMatch.params) ?? {};
          const filteredRoutes = (router.options.filterRoutes == null ? void 0 : router.options.filterRoutes(routes)) ?? routes;
          let foundRoutes = [];
          const findMatchInRoutes = (parentRoutes, routes) => {
            routes.some(route => {
              var _route$childRoutes, _route$childRoutes2;
              if (!route.routePath && (_route$childRoutes = route.childRoutes) != null && _route$childRoutes.length) {
                return findMatchInRoutes([...foundRoutes, route], route.childRoutes);
              }
              const fuzzy = !!(route.routePath !== '/' || (_route$childRoutes2 = route.childRoutes) != null && _route$childRoutes2.length);
              const matchParams = matchPathname(router.basepath, pathname, {
                to: route.fullPath,
                fuzzy,
                caseSensitive: route.options.caseSensitive ?? router.options.caseSensitive
              });
              if (matchParams) {
                let parsedParams;
                try {
                  parsedParams = (route.options.parseParams == null ? void 0 : route.options.parseParams(matchParams)) ?? matchParams;
                } catch (err) {
                  if (opts != null && opts.strictParseParams) {
                    throw err;
                  }
                }
                params = {
                  ...params,
                  ...parsedParams
                };
              }
              if (!!matchParams) {
                foundRoutes = [...parentRoutes, route];
              }
              return !!foundRoutes.length;
            });
            return !!foundRoutes.length;
          };
          findMatchInRoutes([], filteredRoutes);
          if (!foundRoutes.length) {
            return;
          }
          foundRoutes.forEach(foundRoute => {
            var _store$matchCache$mat;
            const interpolatedPath = interpolatePath(foundRoute.routePath, params);
            const matchId = interpolatePath(foundRoute.routeId, params, true);
            const match = existingMatches.find(d => d.matchId === matchId) || ((_store$matchCache$mat = store.matchCache[matchId]) == null ? void 0 : _store$matchCache$mat.match) || createRouteMatch(router, foundRoute, {
              parentMatch,
              matchId,
              params,
              pathname: joinPaths([router.basepath, interpolatedPath])
            });
            matches.push(match);
          });
          const foundRoute = last(foundRoutes);
          if ((_foundRoute$childRout = foundRoute.childRoutes) != null && _foundRoute$childRout.length) {
            recurse(foundRoute.childRoutes);
          }
        };
        recurse([router.routeTree]);
        linkMatches(matches);
        return matches;
      },
      loadMatches: async (resolvedMatches, loaderOpts) => {
        resolvedMatches.forEach(async match => {
          // Validate the match (loads search params etc)
          match.__.validate();
        });

        // Check each match middleware to see if the route can be accessed
        await Promise.all(resolvedMatches.map(async match => {
          try {
            await (match.options.beforeLoad == null ? void 0 : match.options.beforeLoad({
              router: router,
              match
            }));
          } catch (err) {
            if (!(loaderOpts != null && loaderOpts.preload)) {
              match.options.onLoadError == null ? void 0 : match.options.onLoadError(err);
            }
            throw err;
          }
        }));
        const matchPromises = resolvedMatches.map(async match => {
          var _search$__data;
          const search = match.store.search;
          if ((_search$__data = search.__data) != null && _search$__data.matchId && search.__data.matchId !== match.matchId) {
            return;
          }
          match.load(loaderOpts);
          if (match.store.status !== 'success' && match.__.loadPromise) {
            // Wait for the first sign of activity from the match
            await match.__.loadPromise;
          }
        });
        await Promise.all(matchPromises);
      },
      loadMatchData: async routeMatch => {
        if (isServer || !router.options.useServerData) {
          return (await (routeMatch.options.loader == null ? void 0 : routeMatch.options.loader({
            // parentLoaderPromise: routeMatch.parentMatch?.__.dataPromise,
            params: routeMatch.params,
            search: routeMatch.store.routeSearch,
            signal: routeMatch.__.abortController.signal
          }))) || {};
        } else {
          const next = router.buildNext({
            to: '.',
            search: d => ({
              ...(d ?? {}),
              __data: {
                matchId: routeMatch.matchId
              }
            })
          });

          // Refresh:
          // '/dashboard'
          // '/dashboard/invoices/'
          // '/dashboard/invoices/123'

          // New:
          // '/dashboard/invoices/456'

          // TODO: batch requests when possible

          const res = await fetch(next.href, {
            method: 'GET'
            // signal: routeMatch.__.abortController.signal,
          });

          if (res.ok) {
            return res.json();
          }
          throw new Error('Failed to fetch match data');
        }
      },
      invalidateRoute: opts => {
        const next = router.buildNext(opts);
        const unloadedMatchIds = router.matchRoutes(next.pathname).map(d => d.matchId);
        [...store.currentMatches, ...(store.pendingMatches ?? [])].forEach(match => {
          if (unloadedMatchIds.includes(match.matchId)) {
            match.invalidate();
          }
        });
      },
      reload: () => navigate({
        fromCurrent: true,
        replace: true,
        search: true
      }),
      resolvePath: (from, path) => {
        return resolvePath(router.basepath, from, cleanPath(path));
      },
      matchRoute: (location, opts) => {
        // const location = router.buildNext(opts)

        location = {
          ...location,
          to: location.to ? router.resolvePath(location.from ?? '', location.to) : undefined
        };
        const next = router.buildNext(location);
        if (opts != null && opts.pending) {
          if (!store.pendingLocation) {
            return false;
          }
          return !!matchPathname(router.basepath, store.pendingLocation.pathname, {
            ...opts,
            to: next.pathname
          });
        }
        return matchPathname(router.basepath, store.currentLocation.pathname, {
          ...opts,
          to: next.pathname
        });
      },
      navigate: async _ref => {
        let {
          from,
          to = '.',
          search,
          hash,
          replace,
          params
        } = _ref;
        // If this link simply reloads the current route,
        // make sure it has a new key so it will trigger a data refresh

        // If this `to` is a valid external URL, return
        // null for LinkUtils
        const toString = String(to);
        const fromString = String(from);
        let isExternal;
        try {
          new URL(`${toString}`);
          isExternal = true;
        } catch (e) {}
        invariant(!isExternal, 'Attempting to navigate to external url with router.navigate!');
        return navigate({
          from: fromString,
          to: toString,
          search,
          hash,
          replace,
          params
        });
      },
      buildLink: _ref2 => {
        let {
          from,
          to = '.',
          search,
          params,
          hash,
          target,
          replace,
          activeOptions,
          preload,
          preloadMaxAge: userPreloadMaxAge,
          preloadGcMaxAge: userPreloadGcMaxAge,
          preloadDelay: userPreloadDelay,
          disabled
        } = _ref2;
        // If this link simply reloads the current route,
        // make sure it has a new key so it will trigger a data refresh

        // If this `to` is a valid external URL, return
        // null for LinkUtils

        try {
          new URL(`${to}`);
          return {
            type: 'external',
            href: to
          };
        } catch (e) {}
        const nextOpts = {
          from,
          to,
          search,
          params,
          hash,
          replace
        };
        const next = router.buildNext(nextOpts);
        preload = preload ?? router.options.defaultPreload;
        const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;

        // Compare path/hash for matches
        const pathIsEqual = store.currentLocation.pathname === next.pathname;
        const currentPathSplit = store.currentLocation.pathname.split('/');
        const nextPathSplit = next.pathname.split('/');
        const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);
        const hashIsEqual = store.currentLocation.hash === next.hash;
        // Combine the matches based on user options
        const pathTest = activeOptions != null && activeOptions.exact ? pathIsEqual : pathIsFuzzyEqual;
        const hashTest = activeOptions != null && activeOptions.includeHash ? hashIsEqual : true;

        // The final "active" test
        const isActive = pathTest && hashTest;

        // The click handler
        const handleClick = e => {
          if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {
            e.preventDefault();
            if (pathIsEqual && !search && !hash) {
              router.invalidateRoute(nextOpts);
            }

            // All is well? Navigate!
            navigate(nextOpts);
          }
        };

        // The click handler
        const handleFocus = e => {
          if (preload) {
            router.preloadRoute(nextOpts, {
              maxAge: userPreloadMaxAge,
              gcMaxAge: userPreloadGcMaxAge
            }).catch(err => {
              console.log(err);
              console.warn('Error preloading route! ☝️');
            });
          }
        };
        const handleEnter = e => {
          const target = e.target || {};
          if (preload) {
            if (target.preloadTimeout) {
              return;
            }
            target.preloadTimeout = setTimeout(() => {
              target.preloadTimeout = null;
              router.preloadRoute(nextOpts, {
                maxAge: userPreloadMaxAge,
                gcMaxAge: userPreloadGcMaxAge
              }).catch(err => {
                console.log(err);
                console.warn('Error preloading route! ☝️');
              });
            }, preloadDelay);
          }
        };
        const handleLeave = e => {
          const target = e.target || {};
          if (target.preloadTimeout) {
            clearTimeout(target.preloadTimeout);
            target.preloadTimeout = null;
          }
        };
        return {
          type: 'internal',
          next,
          handleFocus,
          handleClick,
          handleEnter,
          handleLeave,
          isActive,
          disabled
        };
      },
      buildNext: opts => {
        const next = buildLocation(opts);
        const matches = router.matchRoutes(next.pathname);
        const __preSearchFilters = matches.map(match => match.options.preSearchFilters ?? []).flat().filter(Boolean);
        const __postSearchFilters = matches.map(match => match.options.postSearchFilters ?? []).flat().filter(Boolean);
        return buildLocation({
          ...opts,
          __preSearchFilters,
          __postSearchFilters
        });
      }
    };
    router.update(userOptions);

    // Allow frameworks to hook into the router creation
    router.options.createRouter == null ? void 0 : router.options.createRouter(router);
    return router;
  }
  function isCtrlEvent(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
  }
  function linkMatches(matches) {
    matches.forEach((match, index) => {
      const parent = matches[index - 1];
      if (parent) {
        match.__.setParentMatch(parent);
      } else {
        match.__.setParentMatch(undefined);
      }
    });
  }

  exports.cleanPath = cleanPath;
  exports.createBrowserHistory = createBrowserHistory;
  exports.createHashHistory = createHashHistory;
  exports.createMemoryHistory = createMemoryHistory;
  exports.createRoute = createRoute;
  exports.createRouteConfig = createRouteConfig;
  exports.createRouteMatch = createRouteMatch;
  exports.createRouter = createRouter;
  exports.decode = decode;
  exports.defaultParseSearch = defaultParseSearch;
  exports.defaultStringifySearch = defaultStringifySearch;
  exports.encode = encode;
  exports.functionalUpdate = functionalUpdate;
  exports.interpolatePath = interpolatePath;
  exports.invariant = invariant;
  exports.joinPaths = joinPaths;
  exports.last = last;
  exports.matchByPath = matchByPath;
  exports.matchPathname = matchPathname;
  exports.parsePathname = parsePathname;
  exports.parseSearchWith = parseSearchWith;
  exports.pick = pick;
  exports.resolvePath = resolvePath;
  exports.rootRouteId = rootRouteId;
  exports.sharedClone = sharedClone;
  exports.stringifySearchWith = stringifySearchWith;
  exports.trimPath = trimPath;
  exports.trimPathLeft = trimPathLeft;
  exports.trimPathRight = trimPathRight;
  exports.warning = warning;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.development.js.map

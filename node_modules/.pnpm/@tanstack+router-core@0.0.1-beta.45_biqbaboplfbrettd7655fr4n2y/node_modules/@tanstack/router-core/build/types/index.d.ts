/**
 * router-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import { BrowserHistory, MemoryHistory, HashHistory } from 'history';
export { createBrowserHistory, createHashHistory, createMemoryHistory } from 'history';
export { default as invariant } from 'tiny-invariant';
import { SetStoreFunction } from '@solidjs/reactivity';

interface FrameworkGenerics {
}
type GetFrameworkGeneric<U> = U extends keyof FrameworkGenerics ? FrameworkGenerics[U] : any;

type NoInfer<T> = [T][T extends any ? 0 : never];
type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N;
type IsAnyBoolean<T> = 1 extends 0 & T ? true : false;
type IsKnown<T, Y, N> = unknown extends T ? N : Y;
type PickAsRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
type PickAsPartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never;
type PickExtra<T, K> = Expand<{
    [TKey in keyof K as string extends TKey ? never : TKey extends keyof T ? never : TKey]: K[TKey];
}>;
type PickRequired<T> = {
    [K in keyof T as undefined extends T[K] ? never : K]: T[K];
};
type Expand<T> = T extends object ? T extends infer O ? {
    [K in keyof O]: O[K];
} : never : T;
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => any ? I : never;
type Values<O> = O[ValueKeys<O>];
type ValueKeys<O> = Extract<keyof O, PropertyKey>;
type DeepAwaited<T> = T extends Promise<infer A> ? DeepAwaited<A> : T extends Record<infer A, Promise<infer B>> ? {
    [K in A]: DeepAwaited<B>;
} : T;
type PathParamMask<TRoutePath extends string> = TRoutePath extends `${infer L}/$${infer C}/${infer R}` ? PathParamMask<`${L}/${string}/${R}`> : TRoutePath extends `${infer L}/$${infer C}` ? PathParamMask<`${L}/${string}`> : TRoutePath;
type Timeout = ReturnType<typeof setTimeout>;
type Updater<TPrevious, TResult = TPrevious> = TResult | ((prev?: TPrevious) => TResult);
type PickExtract<T, U> = {
    [K in keyof T as T[K] extends U ? K : never]: T[K];
};
type PickExclude<T, U> = {
    [K in keyof T as T[K] extends U ? never : K]: T[K];
};
declare function last<T>(arr: T[]): T | undefined;
declare function warning(cond: any, message: string): cond is true;
declare function functionalUpdate<TResult>(updater: Updater<TResult>, previous: TResult): TResult;
declare function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K>;

interface RegisterRouter {
}
type RegisteredRouter = RegisterRouter extends {
    router: Router<infer TRouteConfig, infer TAllRouteInfo, infer TRouterContext>;
} ? Router<TRouteConfig, TAllRouteInfo, TRouterContext> : Router;
type RegisteredAllRouteInfo = RegisterRouter extends {
    router: Router<infer TRouteConfig, infer TAllRouteInfo, infer TRouterContext>;
} ? TAllRouteInfo : AnyAllRouteInfo;
interface LocationState {
}
interface Location<TSearchObj extends AnySearchSchema = {}, TState extends LocationState = LocationState> {
    href: string;
    pathname: string;
    search: TSearchObj;
    searchStr: string;
    state: TState;
    hash: string;
    key?: string;
}
interface FromLocation {
    pathname: string;
    search?: unknown;
    key?: string;
    hash?: string;
}
type SearchSerializer = (searchObj: Record<string, any>) => string;
type SearchParser = (searchStr: string) => Record<string, any>;
type FilterRoutesFn = <TRoute extends Route<any, RouteInfo>>(routeConfigs: TRoute[]) => TRoute[];
interface RouterOptions<TRouteConfig extends AnyRouteConfig, TRouterContext> {
    history?: BrowserHistory | MemoryHistory | HashHistory;
    stringifySearch?: SearchSerializer;
    parseSearch?: SearchParser;
    filterRoutes?: FilterRoutesFn;
    defaultPreload?: false | 'intent';
    defaultPreloadMaxAge?: number;
    defaultPreloadGcMaxAge?: number;
    defaultPreloadDelay?: number;
    defaultComponent?: GetFrameworkGeneric<'Component'>;
    defaultErrorComponent?: GetFrameworkGeneric<'ErrorComponent'>;
    defaultPendingComponent?: GetFrameworkGeneric<'Component'>;
    defaultLoaderMaxAge?: number;
    defaultLoaderGcMaxAge?: number;
    caseSensitive?: boolean;
    routeConfig?: TRouteConfig;
    basepath?: string;
    useServerData?: boolean;
    createRouter?: (router: Router<any, any, any>) => void;
    createRoute?: (opts: {
        route: AnyRoute;
        router: Router<any, any, any>;
    }) => void;
    context?: TRouterContext;
    loadComponent?: (component: GetFrameworkGeneric<'Component'>) => Promise<GetFrameworkGeneric<'Component'>>;
}
interface Action<TPayload = unknown, TResponse = unknown> {
    submit: (submission?: TPayload, actionOpts?: {
        invalidate?: boolean;
        multi?: boolean;
    }) => Promise<TResponse>;
    current?: ActionState<TPayload, TResponse>;
    latest?: ActionState<TPayload, TResponse>;
    submissions: ActionState<TPayload, TResponse>[];
}
interface ActionState<TPayload = unknown, TResponse = unknown> {
    submittedAt: number;
    status: 'idle' | 'pending' | 'success' | 'error';
    submission: TPayload;
    isMulti: boolean;
    data?: TResponse;
    error?: unknown;
}
interface Loader<TFullSearchSchema extends AnySearchSchema = {}, TAllParams extends AnyPathParams = {}, TRouteLoaderData = AnyLoaderData> {
    fetch: keyof PickRequired<TFullSearchSchema> extends never ? keyof TAllParams extends never ? (loaderContext: {
        signal?: AbortSignal;
    }) => Promise<TRouteLoaderData> : (loaderContext: {
        params: TAllParams;
        search?: TFullSearchSchema;
        signal?: AbortSignal;
    }) => Promise<TRouteLoaderData> : keyof TAllParams extends never ? (loaderContext: {
        search: TFullSearchSchema;
        params: TAllParams;
        signal?: AbortSignal;
    }) => Promise<TRouteLoaderData> : (loaderContext: {
        search: TFullSearchSchema;
        signal?: AbortSignal;
    }) => Promise<TRouteLoaderData>;
    current?: LoaderState<TFullSearchSchema, TAllParams>;
    latest?: LoaderState<TFullSearchSchema, TAllParams>;
    pending: LoaderState<TFullSearchSchema, TAllParams>[];
}
interface LoaderState<TFullSearchSchema extends AnySearchSchema = {}, TAllParams extends AnyPathParams = {}> {
    loadedAt: number;
    loaderContext: LoaderContext<TFullSearchSchema, TAllParams>;
}
interface RouterStore<TSearchObj extends AnySearchSchema = {}, TState extends LocationState = LocationState> {
    status: 'idle' | 'loading';
    latestLocation: Location<TSearchObj, TState>;
    currentMatches: RouteMatch[];
    currentLocation: Location<TSearchObj, TState>;
    pendingMatches?: RouteMatch[];
    pendingLocation?: Location<TSearchObj, TState>;
    lastUpdated: number;
    actions: Record<string, Action>;
    loaders: Record<string, Loader>;
    isFetching: boolean;
    isPreloading: boolean;
    matchCache: Record<string, MatchCacheEntry>;
}
type ListenerFn = () => void;
interface BuildNextOptions {
    to?: string | number | null;
    params?: true | Updater<unknown>;
    search?: true | Updater<unknown>;
    hash?: true | Updater<string>;
    state?: LocationState;
    key?: string;
    from?: string;
    fromCurrent?: boolean;
    __preSearchFilters?: SearchFilter<any>[];
    __postSearchFilters?: SearchFilter<any>[];
}
type MatchCacheEntry = {
    gc: number;
    match: RouteMatch;
};
interface MatchLocation {
    to?: string | number | null;
    fuzzy?: boolean;
    caseSensitive?: boolean;
    from?: string;
    fromCurrent?: boolean;
}
interface MatchRouteOptions {
    pending?: boolean;
    caseSensitive?: boolean;
    fuzzy?: boolean;
}
interface DehydratedRouterState extends Pick<RouterStore, 'status' | 'latestLocation' | 'currentLocation' | 'lastUpdated'> {
    currentMatches: DehydratedRouteMatch[];
}
interface DehydratedRouter<TRouterContext = unknown> {
    store: DehydratedRouterState;
    context: TRouterContext;
}
type MatchCache = Record<string, MatchCacheEntry>;
interface DehydratedRouteMatch {
    matchId: string;
    store: Pick<RouteMatchStore<any, any>, 'status' | 'routeLoaderData' | 'isInvalid' | 'invalidAt'>;
}
interface RouterContext {
}
interface Router<TRouteConfig extends AnyRouteConfig = RouteConfig, TAllRouteInfo extends AnyAllRouteInfo = AllRouteInfo<TRouteConfig>, TRouterContext = unknown> {
    types: {
        RouteConfig: TRouteConfig;
        AllRouteInfo: TAllRouteInfo;
    };
    history: BrowserHistory | MemoryHistory | HashHistory;
    options: PickAsRequired<RouterOptions<TRouteConfig, TRouterContext>, 'stringifySearch' | 'parseSearch' | 'context'>;
    store: RouterStore<TAllRouteInfo['fullSearchSchema']>;
    setStore: SetStoreFunction<RouterStore<TAllRouteInfo['fullSearchSchema']>>;
    basepath: string;
    routeTree: Route<TAllRouteInfo, RouteInfo>;
    routesById: RoutesById<TAllRouteInfo>;
    reset: () => void;
    mount: () => () => void;
    update: <TRouteConfig extends RouteConfig = RouteConfig, TAllRouteInfo extends AnyAllRouteInfo = AllRouteInfo<TRouteConfig>, TRouterContext = unknown>(opts?: RouterOptions<TRouteConfig, TRouterContext>) => Router<TRouteConfig, TAllRouteInfo, TRouterContext>;
    buildNext: (opts: BuildNextOptions) => Location;
    cancelMatches: () => void;
    load: (next?: Location) => Promise<void>;
    cleanMatchCache: () => void;
    getRoute: <TId extends keyof TAllRouteInfo['routeInfoById']>(id: TId) => Route<TAllRouteInfo, TAllRouteInfo['routeInfoById'][TId]>;
    loadRoute: (navigateOpts: BuildNextOptions) => Promise<RouteMatch[]>;
    preloadRoute: (navigateOpts: BuildNextOptions, loaderOpts: {
        maxAge?: number;
        gcMaxAge?: number;
    }) => Promise<RouteMatch[]>;
    matchRoutes: (pathname: string, opts?: {
        strictParseParams?: boolean;
    }) => RouteMatch[];
    loadMatches: (resolvedMatches: RouteMatch[], loaderOpts?: {
        preload: true;
        maxAge: number;
        gcMaxAge: number;
    } | {
        preload?: false;
        maxAge?: never;
        gcMaxAge?: never;
    }) => Promise<void>;
    loadMatchData: (routeMatch: RouteMatch<any, any>) => Promise<Record<string, unknown>>;
    invalidateRoute: (opts: MatchLocation) => void;
    reload: () => Promise<void>;
    resolvePath: (from: string, path: string) => string;
    navigate: <TFrom extends ValidFromPath<TAllRouteInfo> = '/', TTo extends string = '.'>(opts: NavigateOptions<TAllRouteInfo, TFrom, TTo>) => Promise<void>;
    matchRoute: <TFrom extends ValidFromPath<TAllRouteInfo> = '/', TTo extends string = '.'>(matchLocation: ToOptions<TAllRouteInfo, TFrom, TTo>, opts?: MatchRouteOptions) => false | TAllRouteInfo['routeInfoById'][ResolveRelativePath<TFrom, NoInfer<TTo>>]['allParams'];
    buildLink: <TFrom extends ValidFromPath<TAllRouteInfo> = '/', TTo extends string = '.'>(opts: LinkOptions<TAllRouteInfo, TFrom, TTo>) => LinkInfo;
    dehydrate: () => DehydratedRouter<TRouterContext>;
    hydrate: (dehydratedRouter: DehydratedRouter<TRouterContext>) => void;
}
declare function createRouter<TRouteConfig extends AnyRouteConfig = RouteConfig, TAllRouteInfo extends AnyAllRouteInfo = AllRouteInfo<TRouteConfig>, TRouterContext = unknown>(userOptions?: RouterOptions<TRouteConfig, TRouterContext>): Router<TRouteConfig, TAllRouteInfo, TRouterContext>;

interface RouteMatchStore<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TRouteInfo extends AnyRouteInfo = RouteInfo> {
    parentMatch?: RouteMatch;
    routeSearch: TRouteInfo['searchSchema'];
    search: Expand<TAllRouteInfo['fullSearchSchema'] & TRouteInfo['fullSearchSchema']>;
    status: 'idle' | 'loading' | 'success' | 'error';
    updatedAt?: number;
    error?: unknown;
    invalid: boolean;
    isInvalid: boolean;
    loaderData: TRouteInfo['loaderData'];
    routeLoaderData: TRouteInfo['routeLoaderData'];
    isFetching: boolean;
    invalidAt: number;
}
interface RouteMatch<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TRouteInfo extends AnyRouteInfo = RouteInfo> extends Route<TAllRouteInfo, TRouteInfo> {
    store: RouteMatchStore<TAllRouteInfo, TRouteInfo>;
    matchId: string;
    pathname: string;
    params: TRouteInfo['allParams'];
    childMatches: RouteMatch[];
    cancel: () => void;
    load: (loaderOpts?: {
        preload: true;
        maxAge: number;
        gcMaxAge: number;
    } | {
        preload?: false;
        maxAge?: never;
        gcMaxAge?: never;
    }) => Promise<TRouteInfo['routeLoaderData']>;
    fetch: (opts?: {
        maxAge?: number;
    }) => Promise<TRouteInfo['routeLoaderData']>;
    invalidate: () => void;
    hasLoaders: () => boolean;
    __: {
        setParentMatch: (parentMatch?: RouteMatch) => void;
        component?: GetFrameworkGeneric<'Component'>;
        errorComponent?: GetFrameworkGeneric<'ErrorComponent'>;
        pendingComponent?: GetFrameworkGeneric<'Component'>;
        loadPromise?: Promise<void>;
        onExit?: void | ((matchContext: {
            params: TRouteInfo['allParams'];
            search: TRouteInfo['fullSearchSchema'];
        }) => void);
        abortController: AbortController;
        validate: () => void;
    };
}
declare function createRouteMatch<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TRouteInfo extends AnyRouteInfo = RouteInfo>(router: Router<any, any, any>, route: Route<TAllRouteInfo, TRouteInfo>, opts: {
    parentMatch?: RouteMatch<any, any>;
    matchId: string;
    params: TRouteInfo['allParams'];
    pathname: string;
}): RouteMatch<TAllRouteInfo, TRouteInfo>;

declare const rootRouteId: "__root__";
type RootRouteId = typeof rootRouteId;
type AnyLoaderData = {};
type AnyPathParams = {};
type AnySearchSchema = {};
interface RouteMeta {
}
type SearchSchemaValidator<TReturn, TParentSchema> = SearchSchemaValidatorObj<TReturn, TParentSchema> | SearchSchemaValidatorFn<TReturn, TParentSchema>;
type SearchSchemaValidatorObj<TReturn, TParentSchema> = {
    parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>;
};
type SearchSchemaValidatorFn<TReturn, TParentSchema> = (searchObj: Record<string, unknown>) => {} extends TParentSchema ? TReturn : keyof TReturn extends keyof TParentSchema ? {
    error: 'Top level search params cannot be redefined by child routes!';
    keys: keyof TReturn & keyof TParentSchema;
} : TReturn;
type DefinedPathParamWarning = 'Path params cannot be redefined by child routes!';
type ParentParams<TParentParams> = AnyPathParams extends TParentParams ? {} : {
    [Key in keyof TParentParams]?: DefinedPathParamWarning;
};
type LoaderFn<TRouteLoaderData extends AnyLoaderData = {}, TFullSearchSchema extends AnySearchSchema = {}, TAllParams extends AnyPathParams = {}> = (loaderContext: LoaderContext<TFullSearchSchema, TAllParams>) => TRouteLoaderData | Promise<TRouteLoaderData>;
interface LoaderContext<TFullSearchSchema extends AnySearchSchema = {}, TAllParams extends AnyPathParams = {}> {
    params: TAllParams;
    search: TFullSearchSchema;
    signal?: AbortSignal;
}
type ActionFn<TActionPayload = unknown, TActionResponse = unknown> = (submission: TActionPayload) => TActionResponse | Promise<TActionResponse>;
type UnloaderFn<TPath extends string> = (routeMatch: RouteMatch<any, RouteInfo<string, TPath>>) => void;
type RouteOptions<TRouteId extends string = string, TPath extends string = string, TParentRouteLoaderData extends AnyLoaderData = {}, TRouteLoaderData extends AnyLoaderData = {}, TParentLoaderData extends AnyLoaderData = {}, TLoaderData extends AnyLoaderData = {}, TActionPayload = unknown, TActionResponse = unknown, TParentSearchSchema extends {} = {}, TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = TSearchSchema, TParentParams extends AnyPathParams = {}, TParams extends Record<ParsePathParams<TPath>, unknown> = Record<ParsePathParams<TPath>, string>, TAllParams extends AnyPathParams = {}> = ({
    path: TPath;
} | {
    id: TRouteId;
}) & {
    caseSensitive?: boolean;
    validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>;
    preSearchFilters?: SearchFilter<TFullSearchSchema>[];
    postSearchFilters?: SearchFilter<TFullSearchSchema>[];
    component?: GetFrameworkGeneric<'Component'>;
    errorComponent?: GetFrameworkGeneric<'ErrorComponent'>;
    pendingComponent?: GetFrameworkGeneric<'Component'>;
    loader?: LoaderFn<TRouteLoaderData, TFullSearchSchema, TAllParams>;
    loaderMaxAge?: number;
    loaderGcMaxAge?: number;
    action?: ActionFn<TActionPayload, TActionResponse>;
    beforeLoad?: (opts: {
        router: Router<any, any, unknown>;
        match: RouteMatch;
    }) => Promise<void> | void;
    onLoadError?: (err: any) => void;
    onLoaded?: (matchContext: {
        params: TAllParams;
        search: TFullSearchSchema;
    }) => void | undefined | ((match: {
        params: TAllParams;
        search: TFullSearchSchema;
    }) => void);
    onTransition?: (match: {
        params: TAllParams;
        search: TFullSearchSchema;
    }) => void;
    meta?: RouteMeta;
} & ({
    parseParams?: never;
    stringifyParams?: never;
} | {
    parseParams: (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams;
    stringifyParams: (params: TParams) => Record<ParsePathParams<TPath>, string>;
}) & (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never ? {} : 'Cannot redefined path params in child routes!');
type SearchFilter<T, U = T> = (prev: T) => U;
interface RouteConfig<TId extends string = string, TRouteId extends string = string, TPath extends string = string, TFullPath extends string = string, TParentRouteLoaderData extends AnyLoaderData = AnyLoaderData, TRouteLoaderData extends AnyLoaderData = AnyLoaderData, TParentLoaderData extends AnyLoaderData = {}, TLoaderData extends AnyLoaderData = AnyLoaderData, TActionPayload = unknown, TActionResponse = unknown, TParentSearchSchema extends {} = {}, TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = {}, TParentParams extends AnyPathParams = {}, TParams extends AnyPathParams = {}, TAllParams extends AnyPathParams = {}, TKnownChildren = unknown> {
    id: TId;
    routeId: TRouteId;
    path: NoInfer<TPath>;
    fullPath: TFullPath;
    options: RouteOptions<TRouteId, TPath, TParentRouteLoaderData, TRouteLoaderData, TParentLoaderData, TLoaderData, TActionPayload, TActionResponse, TParentSearchSchema, TSearchSchema, TFullSearchSchema, TParentParams, TParams, TAllParams>;
    children?: TKnownChildren;
    addChildren: IsAny<TId, any, <TNewChildren extends any>(children: TNewChildren extends AnyRouteConfig[] ? TNewChildren : {
        error: 'Invalid route detected';
        route: TNewChildren;
    }) => RouteConfig<TId, TRouteId, TPath, TFullPath, TParentRouteLoaderData, TRouteLoaderData, TParentLoaderData, TLoaderData, TActionPayload, TActionResponse, TParentSearchSchema, TSearchSchema, TFullSearchSchema, TParentParams, TParams, TAllParams, TNewChildren>>;
    createRoute: CreateRouteConfigFn<false, TId, TFullPath, TRouteLoaderData, TLoaderData, TFullSearchSchema, TAllParams>;
    generate: GenerateFn<TRouteId, TPath, TParentRouteLoaderData, TParentLoaderData, TParentSearchSchema, TParentParams>;
}
type GenerateFn<TRouteId extends string = string, TPath extends string = string, TParentRouteLoaderData extends AnyLoaderData = AnyLoaderData, TParentLoaderData extends AnyLoaderData = {}, TParentSearchSchema extends {} = {}, TParentParams extends AnyPathParams = {}> = <TRouteLoaderData extends AnyLoaderData = AnyLoaderData, TActionPayload = unknown, TActionResponse = unknown, TSearchSchema extends AnySearchSchema = {}, TParams extends Record<ParsePathParams<TPath>, unknown> = Record<ParsePathParams<TPath>, string>, TAllParams extends AnyPathParams extends TParams ? Record<ParsePathParams<TPath>, string> : NoInfer<TParams> = AnyPathParams extends TParams ? Record<ParsePathParams<TPath>, string> : NoInfer<TParams>>(options: Omit<RouteOptions<TRouteId, TPath, TParentRouteLoaderData, TRouteLoaderData, TParentLoaderData, Expand<TParentLoaderData & NoInfer<TRouteLoaderData>>, TActionPayload, TActionResponse, TParentSearchSchema, TSearchSchema, Expand<TParentSearchSchema & TSearchSchema>, TParentParams, TParams, Expand<TParentParams & TAllParams>>, 'path'>) => void;
type CreateRouteConfigFn<TIsRoot extends boolean = false, TParentId extends string = string, TParentPath extends string = string, TParentRouteLoaderData extends AnyLoaderData = {}, TParentLoaderData extends AnyLoaderData = {}, TParentSearchSchema extends AnySearchSchema = {}, TParentParams extends AnyPathParams = {}> = <TRouteId extends string, TPath extends string, TRouteLoaderData extends AnyLoaderData, TActionPayload, TActionResponse, TSearchSchema extends AnySearchSchema = AnySearchSchema, TParams extends Record<ParsePathParams<TPath>, unknown> = Record<ParsePathParams<TPath>, string>, TAllParams extends AnyPathParams extends TParams ? Record<ParsePathParams<TPath>, string> : NoInfer<TParams> = AnyPathParams extends TParams ? Record<ParsePathParams<TPath>, string> : NoInfer<TParams>, TKnownChildren extends RouteConfig[] = RouteConfig[], TResolvedId extends string = string extends TRouteId ? string extends TPath ? string : TPath : TRouteId>(options?: TIsRoot extends true ? Omit<RouteOptions<TRouteId, TPath, TParentRouteLoaderData, TRouteLoaderData, TParentLoaderData, Expand<TParentLoaderData & NoInfer<TRouteLoaderData>>, TActionPayload, TActionResponse, TParentSearchSchema, TSearchSchema, Expand<TParentSearchSchema & TSearchSchema>, TParentParams, TParams, Expand<TParentParams & TAllParams>>, 'path'> & {
    path?: never;
} : RouteOptions<TRouteId, TPath, TParentRouteLoaderData, TRouteLoaderData, TParentLoaderData, Expand<TParentLoaderData & NoInfer<TRouteLoaderData>>, TActionPayload, TActionResponse, TParentSearchSchema, TSearchSchema, Expand<TParentSearchSchema & TSearchSchema>, TParentParams, TParams, Expand<TParentParams & TAllParams>>, children?: TKnownChildren, isRoot?: boolean, parentId?: string, parentPath?: string) => RouteConfig<RoutePrefix<TParentId, TResolvedId>, TResolvedId, TPath, string extends TPath ? '' : RoutePath<RoutePrefix<TParentPath, TPath>>, TParentRouteLoaderData, TRouteLoaderData, TParentLoaderData, Expand<TParentLoaderData & NoInfer<TRouteLoaderData>>, TActionPayload, TActionResponse, TParentSearchSchema, TSearchSchema, Expand<TParentSearchSchema & TSearchSchema>, TParentParams, TParams, Expand<TParentParams & TAllParams>, TKnownChildren>;
type RoutePath<T extends string> = T extends RootRouteId ? '/' : TrimPathRight<`${T}`>;
type RoutePrefix<TPrefix extends string, TId extends string> = string extends TId ? RootRouteId : TId extends string ? `${TPrefix}/${TId}` extends '/' ? '/' : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TId>}`>}` : never;
interface AnyRouteConfig extends RouteConfig<any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any> {
}
interface AnyRouteConfigWithChildren<TChildren> extends RouteConfig<any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, TChildren> {
}
type TrimPath<T extends string> = '' extends T ? '' : TrimPathRight<TrimPathLeft<T>>;
type TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}` ? TrimPathLeft<U> : T extends `/${infer U}` ? TrimPathLeft<U> : T;
type TrimPathRight<T extends string> = T extends '/' ? '/' : T extends `${infer U}/` ? TrimPathRight<U> : T;
declare const createRouteConfig: CreateRouteConfigFn<true>;

interface AnyRoute extends Route<any, any, any> {
}
interface Route<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TRouteInfo extends AnyRouteInfo = RouteInfo, TRouterContext = unknown> {
    routeInfo: TRouteInfo;
    routeId: TRouteInfo['id'];
    routeRouteId: TRouteInfo['routeId'];
    routePath: TRouteInfo['path'];
    fullPath: TRouteInfo['fullPath'];
    parentRoute?: AnyRoute;
    childRoutes?: AnyRoute[];
    options: RouteOptions;
    originalIndex: number;
    router: Router<TAllRouteInfo['routeConfig'], TAllRouteInfo, TRouterContext>;
    action: unknown extends TRouteInfo['actionResponse'] ? Action<TRouteInfo['actionPayload'], TRouteInfo['actionResponse']> | undefined : Action<TRouteInfo['actionPayload'], TRouteInfo['actionResponse']>;
    loader: unknown extends TRouteInfo['routeLoaderData'] ? Action<LoaderContext<TRouteInfo['fullSearchSchema'], TRouteInfo['allParams']>, TRouteInfo['routeLoaderData']> | undefined : Loader<TRouteInfo['fullSearchSchema'], TRouteInfo['allParams'], TRouteInfo['routeLoaderData']>;
}
declare function createRoute<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TRouteInfo extends AnyRouteInfo = RouteInfo, TRouterContext = unknown>(routeConfig: RouteConfig, options: TRouteInfo['options'], originalIndex: number, parent: undefined | Route<TAllRouteInfo, any>, router: Router<TAllRouteInfo['routeConfig'], TAllRouteInfo, TRouterContext>): Route<TAllRouteInfo, TRouteInfo, TRouterContext>;

interface AnyAllRouteInfo {
    routeConfig: AnyRouteConfig;
    routeInfo: AnyRouteInfo;
    routeInfoById: Record<string, AnyRouteInfo>;
    routeInfoByFullPath: Record<string, AnyRouteInfo>;
    routeIds: any;
    routePaths: any;
    fullSearchSchema: Record<string, any>;
    allParams: Record<string, any>;
}
interface DefaultAllRouteInfo {
    routeConfig: RouteConfig;
    routeInfo: RouteInfo;
    routeInfoById: Record<string, RouteInfo>;
    routeInfoByFullPath: Record<string, RouteInfo>;
    routeIds: string;
    routePaths: string;
    fullSearchSchema: AnySearchSchema;
    allParams: AnyPathParams;
}
interface AllRouteInfo<TRouteConfig extends AnyRouteConfig = RouteConfig> extends RoutesInfoInner<TRouteConfig, ParseRouteConfig<TRouteConfig>> {
}
type ParseRouteConfig<TRouteConfig = AnyRouteConfig> = TRouteConfig extends AnyRouteConfig ? RouteConfigRoute<TRouteConfig> | ParseRouteChildren<TRouteConfig> : never;
type ParseRouteChildren<TRouteConfig> = TRouteConfig extends AnyRouteConfigWithChildren<infer TChildren> ? unknown extends TChildren ? never : TChildren extends AnyRouteConfig[] ? Values<{
    [TId in TChildren[number]['id']]: ParseRouteChild<TChildren[number], TId>;
}> : never : never;
type ParseRouteChild<TRouteConfig, TId> = TRouteConfig & {
    id: TId;
} extends AnyRouteConfig ? ParseRouteConfig<TRouteConfig> : never;
type RouteConfigRoute<TRouteConfig> = TRouteConfig extends RouteConfig<infer TId, infer TRouteId, infer TPath, infer TFullPath, infer TParentRouteLoaderData, infer TRouteLoaderData, infer TParentLoaderData, infer TLoaderData, infer TActionPayload, infer TActionResponse, infer TParentSearchSchema, infer TSearchSchema, infer TFullSearchSchema, infer TParentParams, infer TParams, infer TAllParams, any> ? string extends TRouteId ? never : RouteInfo<TId, TRouteId, TPath, TFullPath, TParentRouteLoaderData, TRouteLoaderData, TParentLoaderData, TLoaderData, TActionPayload, TActionResponse, TParentSearchSchema, TSearchSchema, TFullSearchSchema, TParentParams, TParams, TAllParams> : never;
interface RoutesInfoInner<TRouteConfig extends AnyRouteConfig, TRouteInfo extends RouteInfo<string, string, any, any, any, any, any, any, any, any, any, any, any, any, any, any> = RouteInfo, TRouteInfoById = {
    '/': TRouteInfo;
} & {
    [TInfo in TRouteInfo as TInfo['id']]: TInfo;
}, TRouteInfoByFullPath = {
    '/': TRouteInfo;
} & {
    [TInfo in TRouteInfo as TInfo['fullPath'] extends RootRouteId ? never : string extends TInfo['fullPath'] ? never : TInfo['fullPath']]: TInfo;
}> {
    routeConfig: TRouteConfig;
    routeInfo: TRouteInfo;
    routeInfoById: TRouteInfoById;
    routeInfoByFullPath: TRouteInfoByFullPath;
    routeIds: keyof TRouteInfoById;
    routePaths: keyof TRouteInfoByFullPath;
    fullSearchSchema: Partial<UnionToIntersection<TRouteInfo['fullSearchSchema']>>;
    allParams: Partial<UnionToIntersection<TRouteInfo['allParams']>>;
}
interface AnyRouteInfo extends RouteInfo<any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any> {
}
interface RouteInfo<TId extends string = string, TRouteId extends string = string, TPath extends string = string, TFullPath extends string = '/', TParentRouteLoaderData extends AnyLoaderData = {}, TRouteLoaderData extends AnyLoaderData = {}, TParentLoaderData extends AnyLoaderData = {}, TLoaderData extends AnyLoaderData = {}, TActionPayload = unknown, TActionResponse = unknown, TParentSearchSchema extends {} = {}, TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = {}, TParentParams extends AnyPathParams = {}, TParams extends AnyPathParams = {}, TAllParams extends AnyPathParams = {}> {
    id: TId;
    routeId: TRouteId;
    path: TPath;
    fullPath: TFullPath;
    parentRouteLoaderData: TParentRouteLoaderData;
    routeLoaderData: TRouteLoaderData;
    parentLoaderData: TParentLoaderData;
    loaderData: TLoaderData;
    actionPayload: TActionPayload;
    actionResponse: TActionResponse;
    searchSchema: TSearchSchema;
    fullSearchSchema: TFullSearchSchema;
    parentParams: TParentParams;
    params: TParams;
    allParams: TAllParams;
    options: RouteOptions<TRouteId, TPath, TParentRouteLoaderData, TRouteLoaderData, TParentLoaderData, TLoaderData, TActionPayload, TActionResponse, TParentSearchSchema, TSearchSchema, TFullSearchSchema, TParentParams, TParams, TAllParams>;
}
type RoutesById<TAllRouteInfo extends AnyAllRouteInfo> = {
    [K in keyof TAllRouteInfo['routeInfoById']]: Route<TAllRouteInfo, TAllRouteInfo['routeInfoById'][K]>;
};
type RouteInfoById<TAllRouteInfo extends AnyAllRouteInfo, TId> = TId extends keyof TAllRouteInfo['routeInfoById'] ? IsAny<TAllRouteInfo['routeInfoById'][TId]['id'], RouteInfo, TAllRouteInfo['routeInfoById'][TId]> : never;
type RouteInfoByPath<TAllRouteInfo extends AnyAllRouteInfo, TPath> = TPath extends keyof TAllRouteInfo['routeInfoByFullPath'] ? IsAny<TAllRouteInfo['routeInfoByFullPath'][TPath]['id'], RouteInfo, TAllRouteInfo['routeInfoByFullPath'][TPath]> : never;

type LinkInfo = {
    type: 'external';
    href: string;
} | {
    type: 'internal';
    next: Location;
    handleFocus: (e: any) => void;
    handleClick: (e: any) => void;
    handleEnter: (e: any) => void;
    handleLeave: (e: any) => void;
    isActive: boolean;
    disabled?: boolean;
};
type CleanPath<T extends string> = T extends `${infer L}//${infer R}` ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`> : T extends `${infer L}//` ? `${CleanPath<L>}/` : T extends `//${infer L}` ? `/${CleanPath<L>}` : T;
type Split<S, TIncludeTrailingSlash = true> = S extends unknown ? string extends S ? string[] : S extends string ? CleanPath<S> extends '' ? [] : TIncludeTrailingSlash extends true ? CleanPath<S> extends `${infer T}/` ? [...Split<T>, '/'] : CleanPath<S> extends `/${infer U}` ? Split<U> : CleanPath<S> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : [S] : CleanPath<S> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : S extends string ? [S] : never : never : never;
type ParsePathParams<T extends string> = Split<T>[number] extends infer U ? U extends `$${infer V}` ? V : never : never;
type Join<T> = T extends [] ? '' : T extends [infer L extends string] ? L : T extends [infer L extends string, ...infer Tail extends [...string[]]] ? CleanPath<`${L}/${Join<Tail>}`> : never;
type RelativeToPathAutoComplete<AllPaths extends string, TFrom extends string, TTo extends string, SplitPaths extends string[] = Split<AllPaths, false>> = TTo extends `..${infer _}` ? SplitPaths extends [
    ...Split<ResolveRelativePath<TFrom, TTo>, false>,
    ...infer TToRest
] ? `${CleanPath<Join<[
    ...Split<TTo, false>,
    ...(TToRest | (Split<ResolveRelativePath<TFrom, TTo>, false>['length'] extends 1 ? never : ['../']))
]>>}` : never : TTo extends `./${infer RestTTo}` ? SplitPaths extends [
    ...Split<TFrom, false>,
    ...Split<RestTTo, false>,
    ...infer RestPath
] ? `${TTo}${Join<RestPath>}` : never : (TFrom extends `/` ? never : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath] ? Join<RestPath> extends {
    length: 0;
} ? never : './' : never) | (TFrom extends `/` ? never : '../') | AllPaths;
type NavigateOptions<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TFrom extends TAllRouteInfo['routePaths'] = '/', TTo extends string = '.'> = ToOptions<TAllRouteInfo, TFrom, TTo> & {
    replace?: boolean;
};
type ToOptions<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TFrom extends TAllRouteInfo['routePaths'] = '/', TTo extends string = '.', TResolvedTo = ResolveRelativePath<TFrom, NoInfer<TTo>>> = {
    to?: ToPathOption<TAllRouteInfo, TFrom, TTo>;
    hash?: Updater<string>;
    state?: LocationState;
    from?: TFrom;
} & CheckPath<TAllRouteInfo, NoInfer<TResolvedTo>, {}> & SearchParamOptions<TAllRouteInfo, TFrom, TResolvedTo> & PathParamOptions<TAllRouteInfo, TFrom, TResolvedTo>;
type SearchParamOptions<TAllRouteInfo extends AnyAllRouteInfo, TFrom, TTo, TFromSchema = Expand<UnionToIntersection<TAllRouteInfo['fullSearchSchema'] & RouteInfoByPath<TAllRouteInfo, TFrom> extends never ? {} : RouteInfoByPath<TAllRouteInfo, TFrom>['fullSearchSchema']>>, TToSchema = Partial<RouteInfoByPath<TAllRouteInfo, TFrom>['fullSearchSchema']> & Omit<RouteInfoByPath<TAllRouteInfo, TTo>['fullSearchSchema'], keyof PickRequired<RouteInfoByPath<TAllRouteInfo, TFrom>['fullSearchSchema']>>, TFromFullSchema = Expand<UnionToIntersection<TAllRouteInfo['fullSearchSchema'] & TFromSchema>>, TToFullSchema = Expand<UnionToIntersection<TAllRouteInfo['fullSearchSchema'] & TToSchema>>> = keyof PickRequired<TToSchema> extends never ? {
    search?: true | SearchReducer<TFromFullSchema, TToFullSchema>;
} : {
    search: SearchReducer<TFromFullSchema, TToFullSchema>;
};
type SearchReducer<TFrom, TTo> = {
    [TKey in keyof TTo]: TTo[TKey];
} | ((current: TFrom) => TTo);
type PathParamOptions<TAllRouteInfo extends AnyAllRouteInfo, TFrom, TTo, TFromSchema = Expand<UnionToIntersection<RouteInfoByPath<TAllRouteInfo, TFrom> extends never ? {} : RouteInfoByPath<TAllRouteInfo, TFrom>['allParams']>>, TToSchema = Partial<RouteInfoByPath<TAllRouteInfo, TFrom>['allParams']> & Omit<RouteInfoByPath<TAllRouteInfo, TTo>['allParams'], keyof PickRequired<RouteInfoByPath<TAllRouteInfo, TFrom>['allParams']>>, TFromFullParams = Expand<UnionToIntersection<TAllRouteInfo['allParams'] & TFromSchema>>, TToFullParams = Expand<UnionToIntersection<TAllRouteInfo['allParams'] & TToSchema>>> = keyof PickRequired<TToSchema> extends never ? {
    params?: ParamsReducer<TFromFullParams, TToFullParams>;
} : {
    params: ParamsReducer<TFromFullParams, TToFullParams>;
};
type ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo);
type ToPathOption<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TFrom extends TAllRouteInfo['routePaths'] = '/', TTo extends string = '.'> = TTo | RelativeToPathAutoComplete<TAllRouteInfo['routePaths'], NoInfer<TFrom> extends string ? NoInfer<TFrom> : '', NoInfer<TTo> & string>;
type ToIdOption<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TFrom extends TAllRouteInfo['routePaths'] = '/', TTo extends string = '.'> = TTo | RelativeToPathAutoComplete<TAllRouteInfo['routeIds'], NoInfer<TFrom> extends string ? NoInfer<TFrom> : '', NoInfer<TTo> & string>;
interface ActiveOptions {
    exact?: boolean;
    includeHash?: boolean;
}
type LinkOptions<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo, TFrom extends TAllRouteInfo['routePaths'] = '/', TTo extends string = '.'> = NavigateOptions<TAllRouteInfo, TFrom, TTo> & {
    target?: HTMLAnchorElement['target'];
    activeOptions?: ActiveOptions;
    preload?: false | 'intent';
    preloadMaxAge?: number;
    preloadGcMaxAge?: number;
    preloadDelay?: number;
    disabled?: boolean;
};
type CheckRelativePath<TAllRouteInfo extends AnyAllRouteInfo, TFrom, TTo> = TTo extends string ? TFrom extends string ? ResolveRelativePath<TFrom, TTo> extends TAllRouteInfo['routePaths'] ? {} : {
    Error: `${TFrom} + ${TTo} resolves to ${ResolveRelativePath<TFrom, TTo>}, which is not a valid route path.`;
    'Valid Route Paths': TAllRouteInfo['routePaths'];
} : {} : {};
type CheckPath<TAllRouteInfo extends AnyAllRouteInfo, TPath, TPass> = Exclude<TPath, TAllRouteInfo['routePaths']> extends never ? TPass : CheckPathError<TAllRouteInfo, Exclude<TPath, TAllRouteInfo['routePaths']>>;
type CheckPathError<TAllRouteInfo extends AnyAllRouteInfo, TInvalids> = Expand<{
    Error: `${TInvalids extends string ? TInvalids : never} is not a valid route path.`;
    'Valid Route Paths': TAllRouteInfo['routePaths'];
}>;
type CheckId<TAllRouteInfo extends AnyAllRouteInfo, TPath, TPass> = Exclude<TPath, TAllRouteInfo['routeIds']> extends never ? TPass : CheckIdError<TAllRouteInfo, Exclude<TPath, TAllRouteInfo['routeIds']>>;
type CheckIdError<TAllRouteInfo extends AnyAllRouteInfo, TInvalids> = Expand<{
    Error: `${TInvalids extends string ? TInvalids : never} is not a valid route ID.`;
    'Valid Route IDs': TAllRouteInfo['routeIds'];
}>;
type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string ? TTo extends string ? TTo extends '.' ? TFrom : TTo extends `./` ? Join<[TFrom, '/']> : TTo extends `./${infer TRest}` ? ResolveRelativePath<TFrom, TRest> : TTo extends `/${infer TRest}` ? TTo : Split<TTo> extends ['..', ...infer ToRest] ? Split<TFrom> extends [...infer FromRest, infer FromTail] ? ToRest extends ['/'] ? Join<[...FromRest, '/']> : ResolveRelativePath<Join<FromRest>, Join<ToRest>> : never : Split<TTo> extends ['.', ...infer ToRest] ? ToRest extends ['/'] ? Join<[TFrom, '/']> : ResolveRelativePath<TFrom, Join<ToRest>> : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>> : never : never;
type ValidFromPath<TAllRouteInfo extends AnyAllRouteInfo = DefaultAllRouteInfo> = undefined | (string extends TAllRouteInfo['routePaths'] ? string : TAllRouteInfo['routePaths']);

interface Segment {
    type: 'pathname' | 'param' | 'wildcard';
    value: string;
}
declare function joinPaths(paths: (string | undefined)[]): string;
declare function cleanPath(path: string): string;
declare function trimPathLeft(path: string): string;
declare function trimPathRight(path: string): string;
declare function trimPath(path: string): string;
declare function resolvePath(basepath: string, base: string, to: string): string;
declare function parsePathname(pathname?: string): Segment[];
declare function interpolatePath(path: string | undefined, params: any, leaveWildcard?: boolean): string;
declare function matchPathname(basepath: string, currentPathname: string, matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>): AnyPathParams | undefined;
declare function matchByPath(basepath: string, from: string, matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>): Record<string, string> | undefined;

declare function encode(obj: any, pfx?: string): string;
declare function decode(str: any): {};

declare const defaultParseSearch: (searchStr: string) => AnySearchSchema;
declare const defaultStringifySearch: (search: Record<string, any>) => string;
declare function parseSearchWith(parser: (str: string) => any): (searchStr: string) => AnySearchSchema;
declare function stringifySearchWith(stringify: (search: any) => string): (search: Record<string, any>) => string;

/**
 * This function returns `a` if `b` is deeply equal.
 * If not, it will replace any deeply equal children of `b` with those of `a`.
 * This can be used for structural sharing between JSON values for example.
 */
declare function sharedClone<T>(prev: any, next: T, touchAll?: boolean): T;

export { Action, ActionFn, ActionState, ActiveOptions, AllRouteInfo, AnyAllRouteInfo, AnyLoaderData, AnyPathParams, AnyRoute, AnyRouteConfig, AnyRouteConfigWithChildren, AnyRouteInfo, AnySearchSchema, BuildNextOptions, CheckId, CheckIdError, CheckPath, CheckPathError, CheckRelativePath, DeepAwaited, DefaultAllRouteInfo, DefinedPathParamWarning, DehydratedRouter, DehydratedRouterState, Expand, FilterRoutesFn, FrameworkGenerics, FromLocation, GetFrameworkGeneric, IsAny, IsAnyBoolean, IsKnown, LinkInfo, LinkOptions, ListenerFn, Loader, LoaderContext, LoaderFn, LoaderState, Location, LocationState, MatchCache, MatchCacheEntry, MatchLocation, MatchRouteOptions, NavigateOptions, NoInfer, ParentParams, ParsePathParams, ParseRouteConfig, PathParamMask, PathParamOptions, PickAsPartial, PickAsRequired, PickExclude, PickExtra, PickExtract, PickRequired, PickUnsafe, RegisterRouter, RegisteredAllRouteInfo, RegisteredRouter, RelativeToPathAutoComplete, ResolveRelativePath, RootRouteId, Route, RouteConfig, RouteConfigRoute, RouteInfo, RouteInfoById, RouteInfoByPath, RouteMatch, RouteMatchStore, RouteMeta, RouteOptions, Router, RouterContext, RouterOptions, RouterStore, RoutesById, RoutesInfoInner, SearchFilter, SearchParamOptions, SearchParser, SearchSchemaValidator, SearchSchemaValidatorFn, SearchSchemaValidatorObj, SearchSerializer, Segment, Split, Timeout, ToIdOption, ToOptions, ToPathOption, UnionToIntersection, UnloaderFn, Updater, ValidFromPath, ValueKeys, Values, cleanPath, createRoute, createRouteConfig, createRouteMatch, createRouter, decode, defaultParseSearch, defaultStringifySearch, encode, functionalUpdate, interpolatePath, joinPaths, last, matchByPath, matchPathname, parsePathname, parseSearchWith, pick, resolvePath, rootRouteId, sharedClone, stringifySearchWith, trimPath, trimPathLeft, trimPathRight, warning };

/**
 * router-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var history = require('history');
var invariant = require('tiny-invariant');
var path = require('./path.js');
var route = require('./route.js');
var routeMatch = require('./routeMatch.js');
var searchParams = require('./searchParams.js');
var reactivity = require('@solidjs/reactivity');
var utils = require('./utils.js');
var sharedClone = require('./sharedClone.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);

var _window$document;
// Detect if we're in the DOM
const isServer = typeof window === 'undefined' || !((_window$document = window.document) != null && _window$document.createElement);

// This is the default history object if none is defined
const createDefaultHistory = () => isServer ? history.createMemoryHistory() : history.createBrowserHistory();
function getInitialRouterState() {
  return {
    status: 'idle',
    latestLocation: null,
    currentLocation: null,
    currentMatches: [],
    actions: {},
    loaders: {},
    lastUpdated: Date.now(),
    matchCache: {},
    get isFetching() {
      return this.status === 'loading' || this.currentMatches.some(d => d.store.isFetching);
    },
    get isPreloading() {
      return Object.values(this.matchCache).some(d => d.match.store.isFetching && !this.currentMatches.find(dd => dd.matchId === d.match.matchId));
    }
  };
}
function createRouter(userOptions) {
  const originalOptions = {
    defaultLoaderGcMaxAge: 5 * 60 * 1000,
    defaultLoaderMaxAge: 0,
    defaultPreloadMaxAge: 2000,
    defaultPreloadDelay: 50,
    context: undefined,
    ...userOptions,
    stringifySearch: (userOptions == null ? void 0 : userOptions.stringifySearch) ?? searchParams.defaultStringifySearch,
    parseSearch: (userOptions == null ? void 0 : userOptions.parseSearch) ?? searchParams.defaultParseSearch
  };
  const [store, setStore] = reactivity.createStore(getInitialRouterState());
  let navigationPromise;
  let startedLoadingAt = Date.now();
  let resolveNavigation = () => {};
  function onFocus() {
    router.load();
  }
  function buildRouteTree(rootRouteConfig) {
    const recurseRoutes = (routeConfigs, parent) => {
      return routeConfigs.map((routeConfig, i) => {
        const routeOptions = routeConfig.options;
        const route$1 = route.createRoute(routeConfig, routeOptions, i, parent, router);
        const existingRoute = router.routesById[route$1.routeId];
        if (existingRoute) {
          if (process.env.NODE_ENV !== 'production') {
            console.warn(`Duplicate routes found with id: ${String(route$1.routeId)}`, router.routesById, route$1);
          }
          throw new Error();
        }
        router.routesById[route$1.routeId] = route$1;
        const children = routeConfig.children;
        route$1.childRoutes = children != null && children.length ? recurseRoutes(children, route$1) : undefined;
        return route$1;
      });
    };
    const routes = recurseRoutes([rootRouteConfig]);
    return routes[0];
  }
  function parseLocation(location, previousLocation) {
    const parsedSearch = router.options.parseSearch(location.search);
    return {
      pathname: location.pathname,
      searchStr: location.search,
      search: sharedClone.sharedClone(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
      hash: location.hash.split('#').reverse()[0] ?? '',
      href: `${location.pathname}${location.search}${location.hash}`,
      state: location.state,
      key: location.key
    };
  }
  function navigate(location) {
    const next = router.buildNext(location);
    return commitLocation(next, location.replace);
  }
  function buildLocation(dest) {
    var _last, _dest$__preSearchFilt, _dest$__preSearchFilt2, _dest$__postSearchFil;
    if (dest === void 0) {
      dest = {};
    }
    const fromPathname = dest.fromCurrent ? store.latestLocation.pathname : dest.from ?? store.latestLocation.pathname;
    let pathname = path.resolvePath(router.basepath ?? '/', fromPathname, `${dest.to ?? '.'}`);
    const fromMatches = router.matchRoutes(store.latestLocation.pathname, {
      strictParseParams: true
    });
    const toMatches = router.matchRoutes(pathname);
    const prevParams = {
      ...((_last = utils.last(fromMatches)) == null ? void 0 : _last.params)
    };
    let nextParams = (dest.params ?? true) === true ? prevParams : utils.functionalUpdate(dest.params, prevParams);
    if (nextParams) {
      toMatches.map(d => d.options.stringifyParams).filter(Boolean).forEach(fn => {
        Object.assign({}, nextParams, fn(nextParams));
      });
    }
    pathname = path.interpolatePath(pathname, nextParams ?? {});

    // Pre filters first
    const preFilteredSearch = (_dest$__preSearchFilt = dest.__preSearchFilters) != null && _dest$__preSearchFilt.length ? dest.__preSearchFilters.reduce((prev, next) => next(prev), store.latestLocation.search) : store.latestLocation.search;

    // Then the link/navigate function
    const destSearch = dest.search === true ? preFilteredSearch // Preserve resolvedFrom true
    : dest.search ? utils.functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater
    : (_dest$__preSearchFilt2 = dest.__preSearchFilters) != null && _dest$__preSearchFilt2.length ? preFilteredSearch // Preserve resolvedFrom filters
    : {};

    // Then post filters
    const postFilteredSearch = (_dest$__postSearchFil = dest.__postSearchFilters) != null && _dest$__postSearchFil.length ? dest.__postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
    const search = sharedClone.sharedClone(store.latestLocation.search, postFilteredSearch);
    const searchStr = router.options.stringifySearch(search);
    let hash = dest.hash === true ? store.latestLocation.hash : utils.functionalUpdate(dest.hash, store.latestLocation.hash);
    hash = hash ? `#${hash}` : '';
    return {
      pathname,
      search,
      searchStr,
      state: store.latestLocation.state,
      hash,
      href: `${pathname}${searchStr}${hash}`,
      key: dest.key
    };
  }
  function commitLocation(next, replace) {
    const id = '' + Date.now() + Math.random();
    let nextAction = 'replace';
    if (!replace) {
      nextAction = 'push';
    }
    const isSameUrl = parseLocation(router.history.location).href === next.href;
    if (isSameUrl && !next.key) {
      nextAction = 'replace';
    }
    router.history[nextAction]({
      pathname: next.pathname,
      hash: next.hash,
      search: next.searchStr
    }, {
      id,
      ...next.state
    });
    return navigationPromise = new Promise(resolve => {
      const previousNavigationResolve = resolveNavigation;
      resolveNavigation = () => {
        previousNavigationResolve();
        resolve();
      };
    });
  }
  const router = {
    types: undefined,
    // public api
    history: (userOptions == null ? void 0 : userOptions.history) || createDefaultHistory(),
    store,
    setStore,
    options: originalOptions,
    basepath: '',
    routeTree: undefined,
    routesById: {},
    reset: () => {
      setStore(s => Object.assign(s, getInitialRouterState()));
    },
    getRoute: id => {
      return router.routesById[id];
    },
    dehydrate: () => {
      return {
        store: {
          ...utils.pick(store, ['latestLocation', 'currentLocation', 'status', 'lastUpdated']),
          currentMatches: store.currentMatches.map(match => ({
            matchId: match.matchId,
            store: utils.pick(match.store, ['status', 'routeLoaderData', 'isInvalid', 'invalidAt'])
          }))
        },
        context: router.options.context
      };
    },
    hydrate: dehydratedRouter => {
      setStore(s => {
        // Update the context TODO: make this part of state?
        router.options.context = dehydratedRouter.context;

        // Match the routes
        const currentMatches = router.matchRoutes(dehydratedRouter.store.latestLocation.pathname, {
          strictParseParams: true
        });
        currentMatches.forEach((match, index) => {
          const dehydratedMatch = dehydratedRouter.store.currentMatches[index];
          invariant__default["default"](dehydratedMatch && dehydratedMatch.matchId === match.matchId, 'Oh no! There was a hydration mismatch when attempting to restore the state of the router! ðŸ˜¬');
          Object.assign(match, dehydratedMatch);
        });
        currentMatches.forEach(match => match.__.validate());
        Object.assign(s, {
          ...dehydratedRouter.store,
          currentMatches
        });
      });
    },
    mount: () => {
      // Mount only does anything on the client
      if (!isServer) {
        // If the router matches are empty, load the matches
        if (!store.currentMatches.length) {
          router.load();
        }
        const unsub = router.history.listen(event => {
          router.load(parseLocation(event.location, store.latestLocation));
        });

        // addEventListener does not exist in React Native, but window does
        // In the future, we might need to invert control here for more adapters
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (window.addEventListener) {
          // Listen to visibilitychange and focus
          window.addEventListener('visibilitychange', onFocus, false);
          window.addEventListener('focus', onFocus, false);
        }
        return () => {
          unsub();
          if (window.removeEventListener) {
            // Be sure to unsubscribe if a new handler is set
            window.removeEventListener('visibilitychange', onFocus);
            window.removeEventListener('focus', onFocus);
          }
        };
      }
      return () => {};
    },
    update: opts => {
      const newHistory = (opts == null ? void 0 : opts.history) !== router.history;
      if (!store.latestLocation || newHistory) {
        if (opts != null && opts.history) {
          router.history = opts.history;
        }
        setStore(s => {
          s.latestLocation = parseLocation(router.history.location);
          s.currentLocation = s.latestLocation;
        });
      }
      Object.assign(router.options, opts);
      const {
        basepath,
        routeConfig
      } = router.options;
      router.basepath = `/${path.trimPath(basepath ?? '') ?? ''}`;
      if (routeConfig) {
        router.routesById = {};
        router.routeTree = buildRouteTree(routeConfig);
      }
      return router;
    },
    cancelMatches: () => {
      [...store.currentMatches, ...(store.pendingMatches || [])].forEach(match => {
        match.cancel();
      });
    },
    load: async next => {
      let now = Date.now();
      const startedAt = now;
      startedLoadingAt = startedAt;

      // Cancel any pending matches
      router.cancelMatches();
      let matches;
      reactivity.batch(() => {
        if (next) {
          // Ingest the new location
          setStore(s => {
            s.latestLocation = next;
          });
        }

        // Match the routes
        matches = router.matchRoutes(store.latestLocation.pathname, {
          strictParseParams: true
        });
        console.log('set loading', matches);
        setStore(s => {
          s.status = 'loading';
          s.pendingMatches = matches;
          s.pendingLocation = store.latestLocation;
        });
      });

      // Load the matches
      try {
        await router.loadMatches(matches);
      } catch (err) {
        console.log(err);
        invariant__default["default"](false, 'Matches failed to load due to error above â˜ï¸. Navigation cancelled!');
      }
      if (startedLoadingAt !== startedAt) {
        // Ignore side-effects of outdated side-effects
        return navigationPromise;
      }
      const previousMatches = store.currentMatches;
      const exiting = [],
        staying = [];
      previousMatches.forEach(d => {
        if (matches.find(dd => dd.matchId === d.matchId)) {
          staying.push(d);
        } else {
          exiting.push(d);
        }
      });
      const entering = matches.filter(d => {
        return !previousMatches.find(dd => dd.matchId === d.matchId);
      });
      now = Date.now();
      exiting.forEach(d => {
        d.__.onExit == null ? void 0 : d.__.onExit({
          params: d.params,
          search: d.store.routeSearch
        });

        // Clear idle error states when match leaves
        if (d.store.status === 'error' && !d.store.isFetching) {
          d.store.status = 'idle';
          d.store.error = undefined;
        }
        const gc = Math.max(d.options.loaderGcMaxAge ?? router.options.defaultLoaderGcMaxAge ?? 0, d.options.loaderMaxAge ?? router.options.defaultLoaderMaxAge ?? 0);
        if (gc > 0) {
          store.matchCache[d.matchId] = {
            gc: gc == Infinity ? Number.MAX_SAFE_INTEGER : now + gc,
            match: d
          };
        }
      });
      staying.forEach(d => {
        d.options.onTransition == null ? void 0 : d.options.onTransition({
          params: d.params,
          search: d.store.routeSearch
        });
      });
      entering.forEach(d => {
        d.__.onExit = d.options.onLoaded == null ? void 0 : d.options.onLoaded({
          params: d.params,
          search: d.store.search
        });
        delete store.matchCache[d.matchId];
      });
      if (startedLoadingAt !== startedAt) {
        // Ignore side-effects of match loading
        return;
      }
      matches.forEach(match => {
        // Clear actions
        if (match.action) {
          // TODO: Check reactivity here
          match.action.current = undefined;
          match.action.submissions = [];
        }
      });
      setStore(s => {
        console.log('set', matches);
        Object.assign(s, {
          status: 'idle',
          currentLocation: store.latestLocation,
          currentMatches: matches,
          pendingLocation: undefined,
          pendingMatches: undefined
        });
      });
      resolveNavigation();
    },
    cleanMatchCache: () => {
      const now = Date.now();
      setStore(s => {
        Object.keys(s.matchCache).forEach(matchId => {
          const entry = s.matchCache[matchId];

          // Don't remove loading matches
          if (entry.match.store.status === 'loading') {
            return;
          }

          // Do not remove successful matches that are still valid
          if (entry.gc > 0 && entry.gc > now) {
            return;
          }

          // Everything else gets removed
          delete s.matchCache[matchId];
        });
      });
    },
    loadRoute: async function (navigateOpts) {
      if (navigateOpts === void 0) {
        navigateOpts = store.latestLocation;
      }
      const next = router.buildNext(navigateOpts);
      const matches = router.matchRoutes(next.pathname, {
        strictParseParams: true
      });
      await router.loadMatches(matches);
      return matches;
    },
    preloadRoute: async function (navigateOpts, loaderOpts) {
      if (navigateOpts === void 0) {
        navigateOpts = store.latestLocation;
      }
      const next = router.buildNext(navigateOpts);
      const matches = router.matchRoutes(next.pathname, {
        strictParseParams: true
      });
      await router.loadMatches(matches, {
        preload: true,
        maxAge: loaderOpts.maxAge ?? router.options.defaultPreloadMaxAge ?? router.options.defaultLoaderMaxAge ?? 0,
        gcMaxAge: loaderOpts.gcMaxAge ?? router.options.defaultPreloadGcMaxAge ?? router.options.defaultLoaderGcMaxAge ?? 0
      });
      return matches;
    },
    matchRoutes: (pathname, opts) => {
      router.cleanMatchCache();
      const matches = [];
      if (!router.routeTree) {
        return matches;
      }
      const existingMatches = [...store.currentMatches, ...(store.pendingMatches ?? [])];
      const recurse = async routes => {
        var _foundRoute$childRout;
        const parentMatch = utils.last(matches);
        let params = (parentMatch == null ? void 0 : parentMatch.params) ?? {};
        const filteredRoutes = (router.options.filterRoutes == null ? void 0 : router.options.filterRoutes(routes)) ?? routes;
        let foundRoutes = [];
        const findMatchInRoutes = (parentRoutes, routes) => {
          routes.some(route => {
            var _route$childRoutes, _route$childRoutes2;
            if (!route.routePath && (_route$childRoutes = route.childRoutes) != null && _route$childRoutes.length) {
              return findMatchInRoutes([...foundRoutes, route], route.childRoutes);
            }
            const fuzzy = !!(route.routePath !== '/' || (_route$childRoutes2 = route.childRoutes) != null && _route$childRoutes2.length);
            const matchParams = path.matchPathname(router.basepath, pathname, {
              to: route.fullPath,
              fuzzy,
              caseSensitive: route.options.caseSensitive ?? router.options.caseSensitive
            });
            if (matchParams) {
              let parsedParams;
              try {
                parsedParams = (route.options.parseParams == null ? void 0 : route.options.parseParams(matchParams)) ?? matchParams;
              } catch (err) {
                if (opts != null && opts.strictParseParams) {
                  throw err;
                }
              }
              params = {
                ...params,
                ...parsedParams
              };
            }
            if (!!matchParams) {
              foundRoutes = [...parentRoutes, route];
            }
            return !!foundRoutes.length;
          });
          return !!foundRoutes.length;
        };
        findMatchInRoutes([], filteredRoutes);
        if (!foundRoutes.length) {
          return;
        }
        foundRoutes.forEach(foundRoute => {
          var _store$matchCache$mat;
          const interpolatedPath = path.interpolatePath(foundRoute.routePath, params);
          const matchId = path.interpolatePath(foundRoute.routeId, params, true);
          const match = existingMatches.find(d => d.matchId === matchId) || ((_store$matchCache$mat = store.matchCache[matchId]) == null ? void 0 : _store$matchCache$mat.match) || routeMatch.createRouteMatch(router, foundRoute, {
            parentMatch,
            matchId,
            params,
            pathname: path.joinPaths([router.basepath, interpolatedPath])
          });
          matches.push(match);
        });
        const foundRoute = utils.last(foundRoutes);
        if ((_foundRoute$childRout = foundRoute.childRoutes) != null && _foundRoute$childRout.length) {
          recurse(foundRoute.childRoutes);
        }
      };
      recurse([router.routeTree]);
      linkMatches(matches);
      return matches;
    },
    loadMatches: async (resolvedMatches, loaderOpts) => {
      resolvedMatches.forEach(async match => {
        // Validate the match (loads search params etc)
        match.__.validate();
      });

      // Check each match middleware to see if the route can be accessed
      await Promise.all(resolvedMatches.map(async match => {
        try {
          await (match.options.beforeLoad == null ? void 0 : match.options.beforeLoad({
            router: router,
            match
          }));
        } catch (err) {
          if (!(loaderOpts != null && loaderOpts.preload)) {
            match.options.onLoadError == null ? void 0 : match.options.onLoadError(err);
          }
          throw err;
        }
      }));
      const matchPromises = resolvedMatches.map(async match => {
        var _search$__data;
        const search = match.store.search;
        if ((_search$__data = search.__data) != null && _search$__data.matchId && search.__data.matchId !== match.matchId) {
          return;
        }
        match.load(loaderOpts);
        if (match.store.status !== 'success' && match.__.loadPromise) {
          // Wait for the first sign of activity from the match
          await match.__.loadPromise;
        }
      });
      await Promise.all(matchPromises);
    },
    loadMatchData: async routeMatch => {
      if (isServer || !router.options.useServerData) {
        return (await (routeMatch.options.loader == null ? void 0 : routeMatch.options.loader({
          // parentLoaderPromise: routeMatch.parentMatch?.__.dataPromise,
          params: routeMatch.params,
          search: routeMatch.store.routeSearch,
          signal: routeMatch.__.abortController.signal
        }))) || {};
      } else {
        const next = router.buildNext({
          to: '.',
          search: d => ({
            ...(d ?? {}),
            __data: {
              matchId: routeMatch.matchId
            }
          })
        });

        // Refresh:
        // '/dashboard'
        // '/dashboard/invoices/'
        // '/dashboard/invoices/123'

        // New:
        // '/dashboard/invoices/456'

        // TODO: batch requests when possible

        const res = await fetch(next.href, {
          method: 'GET'
          // signal: routeMatch.__.abortController.signal,
        });

        if (res.ok) {
          return res.json();
        }
        throw new Error('Failed to fetch match data');
      }
    },
    invalidateRoute: opts => {
      const next = router.buildNext(opts);
      const unloadedMatchIds = router.matchRoutes(next.pathname).map(d => d.matchId);
      [...store.currentMatches, ...(store.pendingMatches ?? [])].forEach(match => {
        if (unloadedMatchIds.includes(match.matchId)) {
          match.invalidate();
        }
      });
    },
    reload: () => navigate({
      fromCurrent: true,
      replace: true,
      search: true
    }),
    resolvePath: (from, path$1) => {
      return path.resolvePath(router.basepath, from, path.cleanPath(path$1));
    },
    matchRoute: (location, opts) => {
      // const location = router.buildNext(opts)

      location = {
        ...location,
        to: location.to ? router.resolvePath(location.from ?? '', location.to) : undefined
      };
      const next = router.buildNext(location);
      if (opts != null && opts.pending) {
        if (!store.pendingLocation) {
          return false;
        }
        return !!path.matchPathname(router.basepath, store.pendingLocation.pathname, {
          ...opts,
          to: next.pathname
        });
      }
      return path.matchPathname(router.basepath, store.currentLocation.pathname, {
        ...opts,
        to: next.pathname
      });
    },
    navigate: async _ref => {
      let {
        from,
        to = '.',
        search,
        hash,
        replace,
        params
      } = _ref;
      // If this link simply reloads the current route,
      // make sure it has a new key so it will trigger a data refresh

      // If this `to` is a valid external URL, return
      // null for LinkUtils
      const toString = String(to);
      const fromString = String(from);
      let isExternal;
      try {
        new URL(`${toString}`);
        isExternal = true;
      } catch (e) {}
      invariant__default["default"](!isExternal, 'Attempting to navigate to external url with router.navigate!');
      return navigate({
        from: fromString,
        to: toString,
        search,
        hash,
        replace,
        params
      });
    },
    buildLink: _ref2 => {
      let {
        from,
        to = '.',
        search,
        params,
        hash,
        target,
        replace,
        activeOptions,
        preload,
        preloadMaxAge: userPreloadMaxAge,
        preloadGcMaxAge: userPreloadGcMaxAge,
        preloadDelay: userPreloadDelay,
        disabled
      } = _ref2;
      // If this link simply reloads the current route,
      // make sure it has a new key so it will trigger a data refresh

      // If this `to` is a valid external URL, return
      // null for LinkUtils

      try {
        new URL(`${to}`);
        return {
          type: 'external',
          href: to
        };
      } catch (e) {}
      const nextOpts = {
        from,
        to,
        search,
        params,
        hash,
        replace
      };
      const next = router.buildNext(nextOpts);
      preload = preload ?? router.options.defaultPreload;
      const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;

      // Compare path/hash for matches
      const pathIsEqual = store.currentLocation.pathname === next.pathname;
      const currentPathSplit = store.currentLocation.pathname.split('/');
      const nextPathSplit = next.pathname.split('/');
      const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);
      const hashIsEqual = store.currentLocation.hash === next.hash;
      // Combine the matches based on user options
      const pathTest = activeOptions != null && activeOptions.exact ? pathIsEqual : pathIsFuzzyEqual;
      const hashTest = activeOptions != null && activeOptions.includeHash ? hashIsEqual : true;

      // The final "active" test
      const isActive = pathTest && hashTest;

      // The click handler
      const handleClick = e => {
        if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {
          e.preventDefault();
          if (pathIsEqual && !search && !hash) {
            router.invalidateRoute(nextOpts);
          }

          // All is well? Navigate!
          navigate(nextOpts);
        }
      };

      // The click handler
      const handleFocus = e => {
        if (preload) {
          router.preloadRoute(nextOpts, {
            maxAge: userPreloadMaxAge,
            gcMaxAge: userPreloadGcMaxAge
          }).catch(err => {
            console.log(err);
            console.warn('Error preloading route! â˜ï¸');
          });
        }
      };
      const handleEnter = e => {
        const target = e.target || {};
        if (preload) {
          if (target.preloadTimeout) {
            return;
          }
          target.preloadTimeout = setTimeout(() => {
            target.preloadTimeout = null;
            router.preloadRoute(nextOpts, {
              maxAge: userPreloadMaxAge,
              gcMaxAge: userPreloadGcMaxAge
            }).catch(err => {
              console.log(err);
              console.warn('Error preloading route! â˜ï¸');
            });
          }, preloadDelay);
        }
      };
      const handleLeave = e => {
        const target = e.target || {};
        if (target.preloadTimeout) {
          clearTimeout(target.preloadTimeout);
          target.preloadTimeout = null;
        }
      };
      return {
        type: 'internal',
        next,
        handleFocus,
        handleClick,
        handleEnter,
        handleLeave,
        isActive,
        disabled
      };
    },
    buildNext: opts => {
      const next = buildLocation(opts);
      const matches = router.matchRoutes(next.pathname);
      const __preSearchFilters = matches.map(match => match.options.preSearchFilters ?? []).flat().filter(Boolean);
      const __postSearchFilters = matches.map(match => match.options.postSearchFilters ?? []).flat().filter(Boolean);
      return buildLocation({
        ...opts,
        __preSearchFilters,
        __postSearchFilters
      });
    }
  };
  router.update(userOptions);

  // Allow frameworks to hook into the router creation
  router.options.createRouter == null ? void 0 : router.options.createRouter(router);
  return router;
}
function isCtrlEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function linkMatches(matches) {
  matches.forEach((match, index) => {
    const parent = matches[index - 1];
    if (parent) {
      match.__.setParentMatch(parent);
    } else {
      match.__.setParentMatch(undefined);
    }
  });
}

exports.createRouter = createRouter;
//# sourceMappingURL=router.js.map

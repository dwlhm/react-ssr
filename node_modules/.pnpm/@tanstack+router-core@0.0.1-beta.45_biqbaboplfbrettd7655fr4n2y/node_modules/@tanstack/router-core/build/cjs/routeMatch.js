/**
 * router-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reactivity = require('@solidjs/reactivity');
var sharedClone = require('./sharedClone.js');

const componentTypes = ['component', 'errorComponent', 'pendingComponent'];
function createRouteMatch(router, route, opts) {
  let componentsPromise;
  let dataPromise;
  let latestId = '';
  let resolve = () => {};
  function setLoaderData(loaderData) {
    reactivity.batch(() => {
      setStore(s => {
        s.routeLoaderData = sharedClone.sharedClone(s.routeLoaderData, loaderData);
      });
      updateLoaderData();
    });
  }
  function updateLoaderData() {
    setStore(s => {
      var _store$parentMatch;
      s.loaderData = sharedClone.sharedClone(s.loaderData, {
        ...((_store$parentMatch = store.parentMatch) == null ? void 0 : _store$parentMatch.store.loaderData),
        ...s.routeLoaderData
      });
    });
  }
  const [store, setStore] = reactivity.createStore({
    routeSearch: {},
    search: {},
    status: 'idle',
    routeLoaderData: {},
    loaderData: {},
    isFetching: false,
    invalid: false,
    invalidAt: Infinity,
    get isInvalid() {
      const now = Date.now();
      return this.invalid || this.invalidAt < now;
    }
  });
  const routeMatch = {
    ...route,
    ...opts,
    store,
    // setStore,
    router,
    childMatches: [],
    __: {
      setParentMatch: parentMatch => {
        reactivity.batch(() => {
          setStore(s => {
            s.parentMatch = parentMatch;
          });
          updateLoaderData();
        });
      },
      abortController: new AbortController(),
      validate: () => {
        var _store$parentMatch2;
        // Validate the search params and stabilize them
        const parentSearch = ((_store$parentMatch2 = store.parentMatch) == null ? void 0 : _store$parentMatch2.store.search) ?? router.store.currentLocation.search;
        try {
          const prevSearch = store.routeSearch;
          const validator = typeof routeMatch.options.validateSearch === 'object' ? routeMatch.options.validateSearch.parse : routeMatch.options.validateSearch;
          let nextSearch = sharedClone.sharedClone(prevSearch, (validator == null ? void 0 : validator(parentSearch)) ?? {});
          reactivity.batch(() => {
            // Invalidate route matches when search param stability changes
            if (prevSearch !== nextSearch) {
              setStore(s => s.invalid = true);
            }

            // TODO: Alright, do we need batch() here?
            setStore(s => {
              s.routeSearch = nextSearch;
              s.search = sharedClone.sharedClone(parentSearch, {
                ...parentSearch,
                ...nextSearch
              });
            });
          });
          componentTypes.map(async type => {
            const component = routeMatch.options[type];
            if (typeof routeMatch.__[type] !== 'function') {
              routeMatch.__[type] = component;
            }
          });
        } catch (err) {
          console.error(err);
          const error = new Error('Invalid search params found', {
            cause: err
          });
          error.code = 'INVALID_SEARCH_PARAMS';
          setStore(s => {
            s.status = 'error';
            s.error = error;
          });

          // Do not proceed with loading the route
          return;
        }
      }
    },
    cancel: () => {
      var _routeMatch$__$abortC;
      (_routeMatch$__$abortC = routeMatch.__.abortController) == null ? void 0 : _routeMatch$__$abortC.abort();
    },
    invalidate: () => {
      setStore(s => s.invalid = true);
    },
    hasLoaders: () => {
      return !!(route.options.loader || componentTypes.some(d => {
        var _route$options$d;
        return (_route$options$d = route.options[d]) == null ? void 0 : _route$options$d.preload;
      }));
    },
    load: async loaderOpts => {
      const now = Date.now();
      const minMaxAge = loaderOpts != null && loaderOpts.preload ? Math.max(loaderOpts == null ? void 0 : loaderOpts.maxAge, loaderOpts == null ? void 0 : loaderOpts.gcMaxAge) : 0;

      // If this is a preload, add it to the preload cache
      if (loaderOpts != null && loaderOpts.preload && minMaxAge > 0) {
        // If the match is currently active, don't preload it
        if (router.store.currentMatches.find(d => d.matchId === routeMatch.matchId)) {
          return;
        }
        router.store.matchCache[routeMatch.matchId] = {
          gc: now + loaderOpts.gcMaxAge,
          match: routeMatch
        };
      }

      // If the match is invalid, errored or idle, trigger it to load
      if (store.status === 'success' && store.isInvalid || store.status === 'error' || store.status === 'idle') {
        const maxAge = loaderOpts != null && loaderOpts.preload ? loaderOpts == null ? void 0 : loaderOpts.maxAge : undefined;
        await routeMatch.fetch({
          maxAge
        });
      }
    },
    fetch: async opts => {
      const loadId = '' + Date.now() + Math.random();
      latestId = loadId;
      const checkLatest = async () => {
        if (loadId !== latestId) {
          // warning(true, 'Data loader is out of date!')
          return new Promise(() => {});
        }
      };
      reactivity.batch(() => {
        // If the match was in an error state, set it
        // to a loading state again. Otherwise, keep it
        // as loading or resolved
        if (store.status === 'idle') {
          setStore(s => s.status = 'loading');
        }

        // We started loading the route, so it's no longer invalid
        setStore(s => s.invalid = false);
      });
      routeMatch.__.loadPromise = new Promise(async r => {
        // We are now fetching, even if it's in the background of a
        // resolved state
        setStore(s => s.isFetching = true);
        resolve = r;
        componentsPromise = (async () => {
          // then run all component and data loaders in parallel
          // For each component type, potentially load it asynchronously

          await Promise.all(componentTypes.map(async type => {
            var _routeMatch$__$type;
            const component = routeMatch.options[type];
            if ((_routeMatch$__$type = routeMatch.__[type]) != null && _routeMatch$__$type.preload) {
              routeMatch.__[type] = await router.options.loadComponent(component);
            }
          }));
        })();
        dataPromise = Promise.resolve().then(async () => {
          try {
            if (routeMatch.options.loader) {
              const data = await router.loadMatchData(routeMatch);
              await checkLatest();
              setLoaderData(data);
            }
            setStore(s => {
              s.error = undefined;
              s.status = 'success';
              s.updatedAt = Date.now();
              s.invalidAt = s.updatedAt + ((opts == null ? void 0 : opts.maxAge) ?? routeMatch.options.loaderMaxAge ?? router.options.defaultLoaderMaxAge ?? 0);
            });
            return store.routeLoaderData;
          } catch (err) {
            await checkLatest();
            if (process.env.NODE_ENV !== 'production') {
              console.error(err);
            }
            setStore(s => {
              s.error = err;
              s.status = 'error';
              s.updatedAt = Date.now();
            });
            throw err;
          }
        });
        const after = async () => {
          await checkLatest();
          setStore(s => s.isFetching = false);
          delete routeMatch.__.loadPromise;
          resolve();
        };
        try {
          await Promise.all([componentsPromise, dataPromise.catch(() => {})]);
          after();
        } catch {
          after();
        }
      });
      await routeMatch.__.loadPromise;
      await checkLatest();
    }
  };
  if (!routeMatch.hasLoaders()) {
    setStore(s => s.status = 'success');
  }
  return routeMatch;
}

exports.createRouteMatch = createRouteMatch;
//# sourceMappingURL=routeMatch.js.map

/**
 * router-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * This function returns `a` if `b` is deeply equal.
 * If not, it will replace any deeply equal children of `b` with those of `a`.
 * This can be used for structural sharing between JSON values for example.
 */
function sharedClone(prev, next, touchAll) {
  const things = new Map();
  function recurse(prev, next) {
    if (prev === next) {
      return prev;
    }
    if (things.has(next)) {
      return things.get(next);
    }
    const prevIsArray = Array.isArray(prev);
    const nextIsArray = Array.isArray(next);
    const prevIsObj = isPlainObject(prev);
    const nextIsObj = isPlainObject(next);
    const isArray = prevIsArray && nextIsArray;
    const isObj = prevIsObj && nextIsObj;
    const isSameStructure = isArray || isObj;

    // Both are arrays or objects
    if (isSameStructure) {
      const aSize = isArray ? prev.length : Object.keys(prev).length;
      const bItems = isArray ? next : Object.keys(next);
      const bSize = bItems.length;
      const copy = isArray ? [] : {};
      let equalItems = 0;
      for (let i = 0; i < bSize; i++) {
        const key = isArray ? i : bItems[i];
        if (copy[key] === prev[key]) {
          equalItems++;
        }
      }
      if (aSize === bSize && equalItems === aSize) {
        things.set(next, prev);
        return prev;
      }
      things.set(next, copy);
      for (let i = 0; i < bSize; i++) {
        const key = isArray ? i : bItems[i];
        if (typeof bItems[i] === 'function') {
          copy[key] = prev[key];
        } else {
          copy[key] = recurse(prev[key], next[key]);
        }
        if (copy[key] === prev[key]) {
          equalItems++;
        }
      }
      return copy;
    }
    if (nextIsArray) {
      const copy = [];
      things.set(next, copy);
      for (let i = 0; i < next.length; i++) {
        copy[i] = recurse(undefined, next[i]);
      }
      return copy;
    }
    if (nextIsObj) {
      const copy = {};
      things.set(next, copy);
      const nextKeys = Object.keys(next);
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        copy[key] = recurse(undefined, next[key]);
      }
      return copy;
    }
    return next;
  }
  return recurse(prev, next);
}

// Copied from: https://github.com/jonschlinkert/is-plain-object
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }

  // If has modified constructor
  const ctor = o.constructor;
  if (typeof ctor === 'undefined') {
    return true;
  }

  // If has modified prototype
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }

  // If constructor does not have an Object-specific method
  if (!prot.hasOwnProperty('isPrototypeOf')) {
    return false;
  }

  // Most likely a plain Object
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

exports.sharedClone = sharedClone;
//# sourceMappingURL=sharedClone.js.map

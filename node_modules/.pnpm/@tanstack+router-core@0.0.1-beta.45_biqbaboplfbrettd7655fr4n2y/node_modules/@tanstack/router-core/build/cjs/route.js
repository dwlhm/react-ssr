/**
 * router-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reactivity = require('@solidjs/reactivity');

function createRoute(routeConfig, options, originalIndex, parent, router) {
  const {
    id,
    routeId,
    path: routePath,
    fullPath
  } = routeConfig;
  let route = {
    routeInfo: undefined,
    routeId: id,
    routeRouteId: routeId,
    originalIndex,
    routePath,
    fullPath,
    options,
    router,
    childRoutes: undefined,
    parentRoute: parent,
    get action() {
      let action = router.store.actions[id] || (() => {
        router.setStore(s => {
          s.actions[id] = {
            submissions: [],
            submit: async (submission, actionOpts) => {
              if (!route) {
                return;
              }
              const invalidate = (actionOpts == null ? void 0 : actionOpts.invalidate) ?? true;
              const [actionStore, setActionStore] = reactivity.createStore({
                submittedAt: Date.now(),
                status: 'pending',
                submission,
                isMulti: !!(actionOpts != null && actionOpts.multi)
              });
              router.setStore(s => {
                if (!(actionOpts != null && actionOpts.multi)) {
                  s.actions[id].submissions = action.submissions.filter(d => d.isMulti);
                }
                s.actions[id].current = actionStore;
                s.actions[id].latest = actionStore;
                s.actions[id].submissions.push(actionStore);
              });
              try {
                const res = await (route.options.action == null ? void 0 : route.options.action(submission));
                setActionStore(s => {
                  s.data = res;
                });
                if (invalidate) {
                  router.invalidateRoute({
                    to: '.',
                    fromCurrent: true
                  });
                  await router.reload();
                }
                setActionStore(s => {
                  s.status = 'success';
                });
                return res;
              } catch (err) {
                console.error(err);
                setActionStore(s => {
                  s.error = err;
                  s.status = 'error';
                });
              }
            }
          };
        });
        return router.store.actions[id];
      })();
      return action;
    },
    get loader() {
      let loader = router.store.loaders[id] || (() => {
        router.setStore(s => {
          s.loaders[id] = {
            pending: [],
            fetch: async loaderContext => {
              if (!route) {
                return;
              }
              const loaderState = {
                loadedAt: Date.now(),
                loaderContext
              };
              router.setStore(s => {
                s.loaders[id].current = loaderState;
                s.loaders[id].latest = loaderState;
                s.loaders[id].pending.push(loaderState);
              });
              try {
                return await (route.options.loader == null ? void 0 : route.options.loader(loaderContext));
              } finally {
                router.setStore(s => {
                  s.loaders[id].pending = s.loaders[id].pending.filter(d => d !== loaderState);
                });
              }
            }
          };
        });
        return router.store.loaders[id];
      })();
      return loader;
    }

    // buildLink: (options) => {
    //   return router.buildLink({
    //     ...options,
    //     from: fullPath,
    //   } as any) as any
    // },

    // navigate: (options) => {
    //   return router.navigate({
    //     ...options,
    //     from: fullPath,
    //   } as any) as any
    // },

    // matchRoute: (matchLocation, opts) => {
    //   return router.matchRoute(
    //     {
    //       ...matchLocation,
    //       from: fullPath,
    //     } as any,
    //     opts,
    //   ) as any
    // },
  };

  router.options.createRoute == null ? void 0 : router.options.createRoute({
    router,
    route
  });
  return route;
}

exports.createRoute = createRoute;
//# sourceMappingURL=route.js.map

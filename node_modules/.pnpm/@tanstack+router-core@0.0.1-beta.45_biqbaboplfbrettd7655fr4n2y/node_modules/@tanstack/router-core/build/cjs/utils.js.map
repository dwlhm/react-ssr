{"version":3,"file":"utils.js","sources":["../../src/utils.ts"],"sourcesContent":["export type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = Expand<{\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}>\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nexport function warning(cond: any, message: string): cond is true {\n  if (cond) {\n    if (typeof console !== 'undefined') console.warn(message)\n\n    try {\n      throw new Error(message)\n    } catch {}\n  }\n\n  return true\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult>,\n  previous: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n"],"names":["last","arr","length","warning","cond","message","console","warn","Error","isFunction","d","functionalUpdate","updater","previous","pick","parent","keys","reduce","obj","key"],"mappings":";;;;;;;;;;;;;;AA8DO,SAASA,IAAI,CAAIC,GAAQ,EAAE;AAChC,EAAA,OAAOA,GAAG,CAACA,GAAG,CAACC,MAAM,GAAG,CAAC,CAAC,CAAA;AAC5B,CAAA;AAEO,SAASC,OAAO,CAACC,IAAS,EAAEC,OAAe,EAAgB;AAChE,EAAA,IAAID,IAAI,EAAE;IACR,IAAI,OAAOE,OAAO,KAAK,WAAW,EAAEA,OAAO,CAACC,IAAI,CAACF,OAAO,CAAC,CAAA;IAEzD,IAAI;AACF,MAAA,MAAM,IAAIG,KAAK,CAACH,OAAO,CAAC,CAAA;KACzB,CAAC,MAAM,EAAC;AACX,GAAA;AAEA,EAAA,OAAO,IAAI,CAAA;AACb,CAAA;AAEA,SAASI,UAAU,CAACC,CAAM,EAAiB;EACzC,OAAO,OAAOA,CAAC,KAAK,UAAU,CAAA;AAChC,CAAA;AAEO,SAASC,gBAAgB,CAC9BC,OAAyB,EACzBC,QAAiB,EACjB;AACA,EAAA,IAAIJ,UAAU,CAACG,OAAO,CAAC,EAAE;IACvB,OAAOA,OAAO,CAACC,QAAQ,CAAY,CAAA;AACrC,GAAA;AAEA,EAAA,OAAOD,OAAO,CAAA;AAChB,CAAA;AAEO,SAASE,IAAI,CAAuBC,MAAS,EAAEC,IAAS,EAAc;EAC3E,OAAOA,IAAI,CAACC,MAAM,CAAC,CAACC,GAAQ,EAAEC,GAAM,KAAK;AACvCD,IAAAA,GAAG,CAACC,GAAG,CAAC,GAAGJ,MAAM,CAACI,GAAG,CAAC,CAAA;AACtB,IAAA,OAAOD,GAAG,CAAA;GACX,EAAE,EAAE,CAAQ,CAAA;AACf;;;;;;;"}
// src/core.ts
var CurrentReaction = void 0;
var CurrentGets = null;
var CurrentGetsIndex = 0;
var EffectQueue = null;
var CacheClean = 0;
var CacheCheck = 1;
var CacheDirty = 2;
var Root;
var Reactive = class {
  value;
  fn;
  observers = null;
  sources = null;
  state;
  effect;
  cleanups = null;
  alwaysUpdate = false;
  constructor(fnOrValue, type) {
    if (type != 0 /* Signal */) {
      this.fn = fnOrValue;
      this.value = void 0;
      this.state = CacheDirty;
      if (Root)
        Root.push(this);
      else
        console.error("Memos and effects must be wrapped in a createRoot");
      this.effect = type == 2 /* Effect */;
      if (this.effect)
        this.update();
    } else {
      this.fn = void 0;
      this.value = fnOrValue;
      this.state = CacheClean;
      this.effect = false;
    }
  }
  get() {
    if (CurrentReaction) {
      if (!CurrentGets && CurrentReaction.sources && CurrentReaction.sources[CurrentGetsIndex] == this) {
        CurrentGetsIndex++;
      } else {
        if (!CurrentGets)
          CurrentGets = [this];
        else
          CurrentGets.push(this);
      }
    }
    if (this.fn)
      this.updateIfNecessary();
    return this.value;
  }
  set(value) {
    const notInBatch = !EffectQueue;
    const newValue = typeof value === "function" ? value(this.value) : value;
    if ((this.value !== newValue || this.alwaysUpdate) && this.observers) {
      for (let i = 0; i < this.observers.length; i++) {
        this.observers[i].stale(CacheDirty);
      }
    }
    this.value = newValue;
    if (notInBatch)
      stabilize();
    return newValue;
  }
  stale(state) {
    if (this.state < state) {
      if (this.state === CacheClean && this.effect) {
        if (EffectQueue)
          EffectQueue.push(this);
        else
          EffectQueue = [this];
      }
      this.state = state;
      if (this.observers) {
        for (let i = 0; i < this.observers.length; i++) {
          this.observers[i].stale(CacheCheck);
        }
      }
    }
  }
  update() {
    const oldValue = this.value;
    const prevReaction = CurrentReaction;
    const prevGets = CurrentGets;
    const prevIndex = CurrentGetsIndex;
    CurrentReaction = this;
    CurrentGets = null;
    CurrentGetsIndex = 0;
    try {
      if (this.cleanups) {
        this.cleanups.forEach((c) => c());
        this.cleanups = null;
      }
      this.value = this.fn();
      if (CurrentGets) {
        this.removeParentObservers(CurrentGetsIndex);
        if (this.sources && CurrentGetsIndex > 0) {
          this.sources.length = CurrentGetsIndex + CurrentGets.length;
          for (let i = 0; i < CurrentGets.length; i++) {
            this.sources[CurrentGetsIndex + i] = CurrentGets[i];
          }
        } else {
          this.sources = CurrentGets;
        }
        for (let i = CurrentGetsIndex; i < this.sources.length; i++) {
          const source = this.sources[i];
          if (!source.observers) {
            source.observers = [this];
          } else {
            source.observers.push(this);
          }
        }
      } else if (this.sources && CurrentGetsIndex < this.sources.length) {
        this.removeParentObservers(CurrentGetsIndex);
        this.sources.length = CurrentGetsIndex;
      }
    } finally {
      CurrentGets = prevGets;
      CurrentReaction = prevReaction;
      CurrentGetsIndex = prevIndex;
    }
    if ((oldValue !== this.value || this.alwaysUpdate) && this.observers) {
      for (let i = 0; i < this.observers.length; i++) {
        this.observers[i].state = CacheDirty;
      }
    }
    this.state = CacheClean;
  }
  updateIfNecessary() {
    if (this.state === CacheCheck) {
      for (const source of this.sources) {
        source.updateIfNecessary();
        if (this.state === CacheDirty) {
          break;
        }
      }
    }
    if (this.state === CacheDirty) {
      this.update();
    }
    this.state = CacheClean;
  }
  removeParentObservers(index) {
    if (!this.sources)
      return;
    for (let i = index; i < this.sources.length; i++) {
      const source = this.sources[i];
      const swap = source.observers.findIndex((v) => v === this);
      source.observers[swap] = source.observers[source.observers.length - 1];
      source.observers.pop();
    }
  }
  destroy() {
    if (this.cleanups) {
      this.cleanups.forEach((c) => c());
      this.cleanups = null;
    }
    this.removeParentObservers(0);
  }
};
function onCleanup(fn) {
  if (CurrentReaction) {
    if (!CurrentReaction.cleanups)
      CurrentReaction.cleanups = [fn];
    else
      CurrentReaction.cleanups.push(fn);
  } else {
    console.error("onCleanup must be called from within a memo or effect");
  }
}
function stabilize() {
  if (!EffectQueue)
    return;
  for (let i = 0; i < EffectQueue.length; i++) {
    EffectQueue[i].get();
  }
  EffectQueue = null;
}
function createSignal(value, options) {
  const signal = new Reactive(value, 0 /* Signal */);
  if (options?.equals !== void 0)
    signal.alwaysUpdate = true;
  return [signal.get.bind(signal), signal.set.bind(signal)];
}
function createMemo(fn) {
  const memo = new Reactive(fn, 1 /* Memo */);
  return memo.get.bind(memo);
}
function createEffect(fn) {
  const effect = new Reactive(fn, 2 /* Effect */);
  return effect.get.bind(effect);
}
function createRoot(fn) {
  let root = [];
  Root = root;
  fn();
  Root = null;
  return () => {
    if (!root)
      return;
    root.forEach((r) => r.destroy());
    root = null;
  };
}
function batch(fn) {
  EffectQueue = [];
  let out = fn();
  stabilize();
  return out;
}
function untrack(fn) {
  const listener = CurrentReaction;
  CurrentReaction = void 0;
  try {
    return fn();
  } finally {
    CurrentReaction = listener;
  }
}

// src/store.ts
var $RAW = Symbol("store-raw");
var $TRACK = Symbol("track");
var $PROXY = Symbol("store-proxy");
var $NODE = Symbol("store-node");
function wrap(value) {
  let p = value[$PROXY];
  if (!p) {
    Object.defineProperty(value, $PROXY, {
      value: p = new Proxy(value, proxyTraps)
    });
    if (!Array.isArray(value)) {
      const keys = Object.keys(value);
      const desc = Object.getOwnPropertyDescriptors(value);
      for (let i = 0, l = keys.length; i < l; i++) {
        const prop = keys[i];
        if (desc[prop].get) {
          const get = desc[prop].get.bind(p);
          Object.defineProperty(value, prop, {
            enumerable: desc[prop].enumerable,
            get
          });
        }
      }
    }
  }
  return p;
}
function isWrappable(obj) {
  let proto;
  return obj != null && typeof obj === "object" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));
}
function unwrap(item, set = /* @__PURE__ */ new Set()) {
  let result, unwrapped, v, prop;
  if (result = item != null && item[$RAW])
    return result;
  if (!isWrappable(item) || set.has(item))
    return item;
  if (Array.isArray(item)) {
    if (Object.isFrozen(item))
      item = item.slice(0);
    else
      set.add(item);
    for (let i = 0, l = item.length; i < l; i++) {
      v = item[i];
      if ((unwrapped = unwrap(v, set)) !== v)
        item[i] = unwrapped;
    }
  } else {
    if (Object.isFrozen(item))
      item = Object.assign({}, item);
    else
      set.add(item);
    const keys = Object.keys(item);
    const desc = Object.getOwnPropertyDescriptors(item);
    for (let i = 0, l = keys.length; i < l; i++) {
      prop = keys[i];
      if (desc[prop].get)
        continue;
      v = item[prop];
      if ((unwrapped = unwrap(v, set)) !== v)
        item[prop] = unwrapped;
    }
  }
  return item;
}
function getDataNodes(target) {
  let nodes = target[$NODE];
  if (!nodes)
    Object.defineProperty(target, $NODE, { value: nodes = {} });
  return nodes;
}
function getDataNode(nodes, property, value) {
  return nodes[property] || (nodes[property] = createDataNode(value));
}
function proxyDescriptor(target, property) {
  const desc = Reflect.getOwnPropertyDescriptor(target, property);
  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)
    return desc;
  delete desc.value;
  delete desc.writable;
  desc.get = () => target[$PROXY][property];
  return desc;
}
function trackSelf(target) {
  if (CurrentReaction) {
    const nodes = getDataNodes(target);
    (nodes._ || (nodes._ = createDataNode())).get();
  }
}
function ownKeys(target) {
  trackSelf(target);
  return Reflect.ownKeys(target);
}
function createDataNode(value) {
  const s = new Reactive(value, 0);
  s.alwaysUpdate = true;
  return s;
}
var Writing = false;
var proxyTraps = {
  get(target, property, receiver) {
    if (property === $RAW)
      return target;
    if (property === $PROXY)
      return receiver;
    if (property === $TRACK) {
      trackSelf(target);
      return receiver;
    }
    const nodes = getDataNodes(target);
    const tracked = nodes.hasOwnProperty(property);
    let value = tracked ? nodes[property].get() : target[property];
    if (property === $NODE || property === "__proto__")
      return value;
    if (!tracked) {
      const desc = Object.getOwnPropertyDescriptor(target, property);
      if (CurrentReaction && (typeof value !== "function" || target.hasOwnProperty(property)) && !(desc && desc.get))
        value = getDataNode(nodes, property, value).get();
    }
    return isWrappable(value) ? wrap(value) : value;
  },
  has(target, property) {
    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === "__proto__")
      return true;
    this.get(target, property, target);
    return property in target;
  },
  set(target, property, value) {
    Writing && setProperty(target, property, unwrap(value));
    return true;
  },
  deleteProperty(target, property) {
    Writing && setProperty(target, property, void 0, true);
    return true;
  },
  ownKeys,
  getOwnPropertyDescriptor: proxyDescriptor
};
function setProperty(state, property, value, deleting = false) {
  if (!deleting && state[property] === value)
    return;
  const prev = state[property];
  const len = state.length;
  if (deleting)
    delete state[property];
  else
    state[property] = value;
  const nodes = getDataNodes(state);
  let node;
  if (node = getDataNode(nodes, property, prev))
    node.set(() => value);
  if (Array.isArray(state) && state.length !== len)
    (node = getDataNode(nodes, "length", len)) && node.set(state.length);
  (node = nodes._) && node.set();
}
function createStore(store) {
  const unwrappedStore = unwrap(store);
  const wrappedStore = wrap(unwrappedStore);
  const setStore = (fn) => {
    batch(() => {
      try {
        Writing = true;
        fn(wrappedStore);
      } finally {
        Writing = false;
      }
    });
  };
  return [wrappedStore, setStore];
}
export {
  batch,
  createEffect,
  createMemo,
  createRoot,
  createSignal,
  createStore,
  isWrappable,
  onCleanup,
  untrack,
  unwrap
};
